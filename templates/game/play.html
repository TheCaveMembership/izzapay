<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>IZZA GAME — Play</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <link rel="stylesheet" href="/static/themes.css">
  <style>
    :root{ --ui:rgba(255,255,255,.9); --bg0:#0b0f17; --card:#141a23; --line:#263042; }
    html,body{height:100%; margin:0; background:#0b0f17; color:#e8eef7; font-family:Arial,Helvetica,sans-serif}
    .wrap{max-width:1100px;margin:0 auto;padding:8px}
    .hud{
      position:sticky; top:0; z-index:5; display:flex; align-items:center; justify-content:space-between;
      background:rgba(10,12,18,.75); backdrop-filter:blur(8px); padding:8px 10px; border-bottom:1px solid var(--line)
    }
    .hud .left{display:flex;gap:12px;align-items:center}
    .hud .pill{background:#1b2433; border:1px solid var(--line); padding:6px 10px; border-radius:10px; font-size:13px}
    .hud .stars{display:flex; gap:4px}
    .star{width:16px; height:16px; border:1px solid #445; border-radius:3px; background:#111}
    .star.on{background:#ffd23f; border-color:#c59b00}
    #gameCard{background:var(--card); border:1px solid var(--line); border-radius:14px; padding:10px; margin-top:10px}
    canvas{display:block; width:100%; height:auto; border-radius:12px; background:#000}

    .controls{ position:fixed; right:12px; bottom:14px; z-index:6; display:flex; gap:8px; align-items:center }
    .btn{ background:#162134; color:#cfe0ff; border:1px solid #2a3550; border-radius:10px; padding:10px 12px;
      font-size:14px; user-select:none; -webkit-user-select:none; }
    .stick { position:fixed; left:12px; bottom:12px; width:120px; height:120px; z-index:6; touch-action:none }
    .stick .base{ position:absolute; inset:0; border-radius:60px; background:rgba(255,255,255,.07); border:1px solid #2a3550 }
    .stick .nub{ position:absolute; left:40px; top:40px; width:40px; height:40px; border-radius:20px; background:#1f2a3f; border:1px solid #2a3550 }
    @media (min-width:820px){ .stick{ display:none; } }

    /* Enter door tooltip */
    #prompt {
      position:absolute; transform:translate(-50%,-120%); padding:4px 8px; font-size:12px;
      background:#0b0f17; border:1px solid #263042; border-radius:8px; display:none; pointer-events:none
    }

    /* Simple modal for “entered building” */
    .modal{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:20; }
    .modal .backdrop{ position:absolute; inset:0; background:rgba(0,0,0,.55); }
    .modal .card{ position:relative; background:#121827; border:1px solid #2a3550; border-radius:14px; padding:16px; width:min(520px,92vw); color:#e8eef7 }
    .modal .card h3{ margin:0 0 8px }
    .modal .row{ display:flex; gap:10px; justify-content:flex-end; margin-top:12px }
    .ghost{ background:transparent; color:#cfe0ff; border:1px solid #394769; border-radius:10px; padding:8px 10px }
  </style>
</head>
<body class="cw-blue theme-a">
  <div class="wrap">
    <div class="hud">
      <div class="left">
        <div class="pill">IZZA GAME</div>
        <div class="pill">Player: {{ user.username }}</div>
      </div>
      <div class="stars" id="stars">
        <div class="star"></div><div class="star"></div><div class="star"></div><div class="star"></div><div class="star"></div>
      </div>
    </div>

    <div id="gameCard" style="position:relative">
      <canvas id="game" width="960" height="540" aria-label="IZZA City"></canvas>
      <div id="prompt">Press B to enter</div>
    </div>
  </div>

  <!-- Virtual joystick + quick buttons for mobile -->
  <div class="stick" id="stick">
    <div class="base"></div>
    <div class="nub" id="nub"></div>
  </div>
  <div class="controls">
    <button class="btn" id="btnA">A</button>
    <button class="btn" id="btnB">B</button>
  </div>

  <!-- World Map overlay (click mini-map to open) -->
  <div class="modal" id="mapModal">
    <div class="backdrop"></div>
    <div class="card">
      <h3>IZZA City — World Map</h3>
      <canvas id="bigmap" width="700" height="520" style="width:100%;height:auto;border-radius:10px;background:#0b0f17"></canvas>
      <div class="row"><button class="ghost" id="closeMap">Close</button></div>
      <div style="margin-top:8px; font-size:12px; opacity:.85">
        <span style="display:inline-block;width:12px;height:12px;background:#1c293e;border:1px solid #31415d;margin-right:6px;border-radius:3px"></span>Unlocked
        <span style="display:inline-block;width:12px;height:12px;background:rgba(163,176,197,.25);border:1px solid #485771;margin-right:6px;border-radius:3px;margin-left:12px"></span>Preview (semi-transparent)
        <span style="display:inline-block;width:12px;height:12px;background:#1b1f2a;border:1px solid #2a3140;margin-right:6px;border-radius:3px;margin-left:12px"></span>Locked
      </div>
    </div>
  </div>

  <!-- Enter building modal -->
  <div class="modal" id="enterModal">
    <div class="backdrop"></div>
    <div class="card">
      <h3>Welcome to The Hub</h3>
      <p>Talk to the NPC inside to get your first mission and start earning!</p>
      <div class="row">
        <button class="ghost" id="closeEnter">Close</button>
      </div>
    </div>
  </div>

  <script>
  (function(){
    const profile = {{ profile|tojson|safe }};
    const BODY   = profile.sprite_skin || "default";
    const HAIR   = profile.hair || "short";
    const OUTFIT = profile.outfit || "street";

    // --------- Canvas & Viewport ----------
    const cvs = document.getElementById('game');
    const ctx = cvs.getContext('2d');
    const TILE = 32;
    const SCALE = 3;              // a touch more zoomed out than 4x
    const DRAW  = TILE * SCALE;

    // --------- Unlocked rectangle (playable area) ----------
    // World size (tiles)
    const W = 90, H = 60;

    // Start region: a generous downtown rectangle; the rest renders black and is solid.
    const unlocked = { x0: 18, y0: 18, x1: 72, y1: 42 }; // inclusive bounds

    // --------- Building block + door ----------
    // One starter building centered-ish in the unlocked area, 10x6 tiles.
    const bW=10, bH=6;
    const bX = Math.floor((unlocked.x0 + unlocked.x1)/2) - Math.floor(bW/2);
    const bY = unlocked.y0 + 4;

    // Door centered on building bottom edge, on the sidewalk tile in front of wall.
    const door = {
      gx: bX + Math.floor(bW/2),
      gy: bY + bH,           // sidewalk tile directly in front
      width: 1,
      height: 1,
      inRange: false
    };

    // Player spawns on the sidewalk just **below** the door (not on the building).
    const spawnGX = door.gx;
    const spawnGY = door.gy + 1;

    // --------- Asset Loader ----------
    function loadImg(src){
      return new Promise((res, rej)=>{
        const i = new Image();
        i.onload = ()=>res(i);
        i.onerror = rej;
        i.src = src;
      });
    }
    const assetRoot = "/static/game/sprites";
    const assets = {
      body:   `${assetRoot}/body/${BODY}.png`,
      hair:   `${assetRoot}/hair/${HAIR}.png`,
      outfit: `${assetRoot}/outfit/${OUTFIT}.png`,
    };

    // --------- Player ----------
    const player = {
      x: spawnGX * TILE + 2,
      y: spawnGY * TILE + 2,
      vx: 0, vy: 0,
      speed: 2.0 * (TILE/16),
      wanted: 0
    };

    // --------- Input ----------
    const keys = {};
    window.addEventListener('keydown', e=>{ keys[e.key.toLowerCase()] = true; if(e.key==='b' || e.key==='B'){ tryEnter(); }});
    window.addEventListener('keyup',   e=>{ keys[e.key.toLowerCase()] = false; });

    // Mobile joystick
    const stick = document.getElementById('stick');
    const nub   = document.getElementById('nub');
    let dragging = false, baseRect=null, vec = {x:0,y:0};
    function setNub(dx,dy){
      const r = 40, mag = Math.hypot(dx,dy) || 1, clamped = Math.min(mag, r);
      const ux = dx / mag, uy = dy / mag;
      nub.style.left = (40 + ux*clamped) + 'px';
      nub.style.top  = (40 + uy*clamped) + 'px';
      vec.x = (clamped/r)*ux; vec.y = (clamped/r)*uy;
    }
    function resetNub(){ nub.style.left='40px'; nub.style.top='40px'; vec.x=0; vec.y=0; }
    function startDrag(){ dragging = true; baseRect = stick.getBoundingClientRect(); }
    function moveDrag(e){ if(!dragging) return; const t = e.touches ? e.touches[0] : e;
      const cx = baseRect.left + baseRect.width/2, cy = baseRect.top + baseRect.height/2;
      setNub(t.clientX - cx, t.clientY - cy);
    }
    function endDrag(){ dragging=false; resetNub(); }
    stick.addEventListener('touchstart', startDrag, {passive:true});
    stick.addEventListener('touchmove',  moveDrag,  {passive:true});
    stick.addEventListener('touchend',   endDrag,   {passive:true});
    stick.addEventListener('mousedown',  startDrag);
    window.addEventListener('mousemove', moveDrag);
    window.addEventListener('mouseup',   endDrag);

    // B / A buttons (mobile)
    document.getElementById('btnB').addEventListener('click', ()=> tryEnter());
    document.getElementById('btnA').addEventListener('click', ()=> setWanted(player.wanted+1));

    // --------- Wanted HUD ----------
    function setWanted(n){
      player.wanted = Math.max(0, Math.min(5, n|0));
      document.querySelectorAll('#stars .star').forEach((s,i)=> s.className = 'star' + (i<player.wanted?' on':'' ));
    }
    document.getElementById('btnA').addEventListener('dblclick', ()=> setWanted(0));

    // --------- Camera ----------
    const camera = { x:0, y:0 };
    function centerCamera(){
      camera.x = player.x - cvs.width/2;
      camera.y = player.y - cvs.height/2;
      const maxX = (unlocked.x1+1)*TILE - cvs.width;
      const maxY = (unlocked.y1+1)*TILE - cvs.height;
      camera.x = Math.max(unlocked.x0*TILE, Math.min(camera.x, maxX));
      camera.y = Math.max(unlocked.y0*TILE, Math.min(camera.y, maxY));
    }

    // --------- Solids / Collisions ----------
    function inUnlocked(gx,gy){
      return gx>=unlocked.x0 && gx<=unlocked.x1 && gy>=unlocked.y0 && gy<=unlocked.y1;
    }
    function isBuilding(gx,gy){
      return gx>=bX && gx<bX+bW && gy>=bY && gy<bY+bH;
    }
    function isSolid(gx,gy){
      if(!inUnlocked(gx,gy)) return true;          // outside region = solid (and renders black)
      if(isBuilding(gx,gy)) return true;           // walls/roof solid
      return false;
    }

    // --------- Door helpers ----------
    const prompt = document.getElementById('prompt');
    function doorInRange(){
      const px = Math.floor(player.x / TILE);
      const py = Math.floor(player.y / TILE);
      // directly on the door tile or 4-neighbour
      return (Math.abs(px - door.gx) + Math.abs(py - door.gy)) <= 1;
    }
    function tryEnter(){
      if(doorInRange()){
        // open modal
        document.getElementById('enterModal').style.display='flex';
      }
    }
    document.getElementById('enterModal').addEventListener('click', (e)=>{
      if(e.target.classList.contains('backdrop')) e.currentTarget.style.display='none';
    });
    document.getElementById('closeEnter').addEventListener('click', ()=> {
      document.getElementById('enterModal').style.display='none';
    });

    // --------- Map overlay ----------
    const mapModal = document.getElementById('mapModal');
    const bigmap   = document.getElementById('bigmap');
    const bctx     = bigmap.getContext('2d');
    function openMap(){ drawBigMap(); mapModal.style.display='flex'; }
    function closeMap(){ mapModal.style.display='none'; }
    document.getElementById('closeMap').addEventListener('click', closeMap);
    mapModal.addEventListener('click', (e)=>{ if(e.target.classList.contains('backdrop')) closeMap(); });

    // Tiny “click to open map” area: bottom-right of game canvas
    cvs.addEventListener('click', (e)=>{
      const r = cvs.getBoundingClientRect();
      const x = e.clientX - r.left, y = e.clientY - r.top;
      if(x > r.width - 220 && y > r.height - 160){ openMap(); }
    });

    function drawBigMap(){
      // background (locked)
      bctx.fillStyle = '#1b1f2a'; bctx.fillRect(0,0,bigmap.width,bigmap.height);

      // scale world to canvas
      const sx = bigmap.width  / W;
      const sy = bigmap.height / H;

      // preview (semi-transparent) outside unlocked but within a larger preview box
      bctx.fillStyle = 'rgba(163,176,197,.25)';
      bctx.fillRect(0, 0, bigmap.width, bigmap.height);

      // unlocked block
      bctx.fillStyle = '#1c293e';
      bctx.fillRect(unlocked.x0*sx, unlocked.y0*sy, (unlocked.x1-unlocked.x0+1)*sx, (unlocked.y1-unlocked.y0+1)*sy);

      // building
      bctx.fillStyle = '#7a3a3a';
      bctx.fillRect(bX*sx, bY*sy, bW*sx, bH*sy);

      // roads (simple cross)
      bctx.fillStyle = '#788292';
      bctx.fillRect(unlocked.x0*sx, (bY+bH+2)*sy, (unlocked.x1-unlocked.x0+1)*sx, 1.5*sy); // horizontal
      bctx.fillRect(((bX+Math.floor(bW/2)))*sx, unlocked.y0*sy, 1.5*sx, (unlocked.y1-unlocked.y0+1)*sy); // vertical

      // player dot
      bctx.fillStyle = '#35f1ff';
      bctx.fillRect((player.x/TILE)*sx - 1.5, (player.y/TILE)*sy - 1.5, 3, 3);
    }

    // --------- Drawing ----------
    function drawTile(gx,gy,screenX,screenY){
      const S = DRAW;

      // Outside unlocked: draw black (so it doesn't look like an invisible wall)
      if(!inUnlocked(gx,gy)){
        ctx.fillStyle = '#000'; ctx.fillRect(screenX, screenY, S, S);
        return;
      }

      // Sidewalk / grass / road baseline
      const roadY = bY + bH + 2; // a road below the building
      const grassRowTop = unlocked.y0;
      if (gy === roadY){
        // asphalt
        ctx.fillStyle = '#2a2a2a'; ctx.fillRect(screenX, screenY, S, S);
        // dashed center line
        ctx.fillStyle = '#ffd23f';
        ctx.fillRect(screenX + S*0.10, screenY + S*0.48, S*0.18, S*0.04);
      } else if (gy === roadY - 1){
        // sidewalk
        ctx.fillStyle = '#6a727b'; ctx.fillRect(screenX, screenY, S, S);
        ctx.strokeStyle = 'rgba(0,0,0,.25)'; ctx.strokeRect(screenX, screenY, S, S);
      } else if (gy < roadY - 1 && gy >= grassRowTop){
        // building area above sidewalk
        ctx.fillStyle = '#09371c'; ctx.fillRect(screenX, screenY, S, S); // park-like grass
      } else {
        // below road or elsewhere inside unlocked
        ctx.fillStyle = '#09371c'; ctx.fillRect(screenX, screenY, S, S);
      }

      // Building block
      if (isBuilding(gx,gy)){
        ctx.fillStyle = '#4a2d2d'; ctx.fillRect(screenX, screenY, S, S);
        ctx.fillStyle = 'rgba(0,0,0,.15)'; ctx.fillRect(screenX, screenY, S, 6);
      }

      // Door tile (on sidewalk row, not solid; turns green when in range)
      if (gx === door.gx && gy === door.gy){
        const near = doorInRange();
        ctx.fillStyle = near ? '#39cc69' : '#49a4ff';
        const w = Math.floor(S*0.30), h = Math.floor(S*0.70);
        ctx.fillRect(screenX + (S-w)/2, screenY + (S-h), w, h);
        // Show floating prompt above player when near
        if (near){
          door.inRange = true;
          const r = cvs.getBoundingClientRect();
          const px = Math.floor(player.x - camera.x);
          const py = Math.floor(player.y - camera.y);
          const prompt = document.getElementById('prompt');
          prompt.style.left = (px + r.left + S/2) + 'px';
          prompt.style.top  = (py + r.top  - 10) + 'px';
          prompt.style.display = 'block';
        }
      }
    }

    function drawPlayer(images){
      const S = DRAW;
      const sx = Math.floor(player.x - camera.x);
      const sy = Math.floor(player.y - camera.y);
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(images.body,   0,0,TILE,TILE, sx, sy, S, S);
      ctx.drawImage(images.outfit, 0,0,TILE,TILE, sx, sy, S, S);
      ctx.drawImage(images.hair,   0,0,TILE,TILE, sx, sy, S, S);
    }

    // --------- Update with collisions ----------
    function tryMove(nx, ny){
      // four corners of the player’s 32×32 footprint
      const corners = [
        {x:nx,           y:ny},
        {x:nx+TILE-1,    y:ny},
        {x:nx,           y:ny+TILE-1},
        {x:nx+TILE-1,    y:ny+TILE-1},
      ];
      // check per-axis to allow sliding along walls
      // X first
      let testX = nx, testY = player.y;
      let blockedX = corners.some(c=>{
        const gx = Math.floor((c.x) / TILE);
        const gy = Math.floor((c.y) / TILE);
        return isSolid(gx,gy);
      });
      if(!blockedX) player.x = nx;

      // Then Y
      testX = player.x; testY = ny;
      const cornersY = [
        {x:testX,        y:testY},
        {x:testX+TILE-1, y:testY},
        {x:testX,        y:testY+TILE-1},
        {x:testX+TILE-1, y:testY+TILE-1},
      ];
      let blockedY = cornersY.some(c=>{
        const gx = Math.floor((c.x) / TILE);
        const gy = Math.floor((c.y) / TILE);
        return isSolid(gx,gy);
      });
      if(!blockedY) player.y = ny;
    }

    function update(dt){
      // hide door prompt by default; show again if near while drawing
      door.inRange = false;
      document.getElementById('prompt').style.display='none';

      // input vector
      let dx = 0, dy = 0;
      if (keys['arrowup']||keys['w']) dy -= 1;
      if (keys['arrowdown']||keys['s']) dy += 1;
      if (keys['arrowleft']||keys['a']) dx -= 1;
      if (keys['arrowright']||keys['d']) dx += 1;
      dx += vec.x; dy += vec.y;

      const mag = Math.hypot(dx,dy);
      let vx=0, vy=0;
      if (mag > 0){ dx/=mag; dy/=mag; vx = dx * player.speed; vy = dy * player.speed; }

      const nx = player.x + vx * dt;
      const ny = player.y + vy * dt;

      tryMove(nx, ny);
      centerCamera();
    }

    function render(images){
      ctx.fillStyle = '#000';
      ctx.fillRect(0,0,cvs.width,cvs.height);

      // visible tile range
      const S = DRAW;
      const tilesX = Math.ceil(cvs.width / S) + 2;
      const tilesY = Math.ceil(cvs.height / S) + 2;
      const startX = Math.max(0, Math.floor(camera.x / TILE));
      const startY = Math.max(0, Math.floor(camera.y / TILE));

      for (let y=0; y<tilesY; y++){
        for (let x=0; x<tilesX; x++){
          const gx = startX + x;
          const gy = startY + y;
          if (gx>=0 && gx<W && gy>=0 && gy<H){
            const screenX = (gx*TILE - camera.x) * (S/TILE);
            const screenY = (gy*TILE - camera.y) * (S/TILE);
            drawTile(gx, gy, screenX, screenY);
          }
        }
      }

      drawPlayer(images);
    }

    // --------- Main Loop ---------
    Promise.all([ loadImg(assets.body), loadImg(assets.outfit), loadImg(assets.hair) ])
    .then(([body, outfit, hair])=>{
      const imgs = { body, outfit, hair };
      let last = performance.now();
      function loop(now){
        const dt = Math.min(32, now - last);
        last = now;
        update(dt/16.6667);
        render(imgs);
        requestAnimationFrame(loop);
      }
      centerCamera();
      requestAnimationFrame(loop);
    }).catch(err=> console.error("Sprite load failed", err));

  })();
  </script>
</body>
</html>
