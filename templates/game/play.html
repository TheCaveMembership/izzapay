<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>IZZA GAME — Play</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <link rel="stylesheet" href="/static/themes.css">
  <style>
    :root{ --ui:rgba(255,255,255,.9); --bg0:#0b0f17; --card:#141a23; --line:#263042; }
    html,body{height:100%; margin:0; background:#0b0f17; color:#e8eef7; font-family:Arial,Helvetica,sans-serif}
    .wrap{max-width:1100px;margin:0 auto;padding:8px}
    .hud{
      position:sticky; top:0; z-index:5; display:flex; align-items:center; justify-content:space-between;
      background:rgba(10,12,18,.75); backdrop-filter:blur(8px); padding:8px 10px; border-bottom:1px solid var(--line)
    }
    .hud .left{display:flex;gap:12px;align-items:center}
    .hud .pill{background:#1b2433; border:1px solid var(--line); padding:6px 10px; border-radius:10px; font-size:13px}
    .hud .stars{display:flex; gap:4px}
    .star{width:16px; height:16px; border:1px solid #445; border-radius:3px; background:#111}
    .star.on{background:#ffd23f; border-color:#c59b00}
    #gameCard{background:var(--card); border:1px solid var(--line); border-radius:14px; padding:10px; margin-top:10px}
    #game{display:block; width:100%; height:auto; border-radius:12px; background:#000}

    /* Mobile controls */
    .controls{
      position:fixed; right:12px; bottom:14px; z-index:6; display:flex; gap:8px; align-items:center
    }
    .btn{
      background:#162134; color:#cfe0ff; border:1px solid #2a3550; border-radius:10px; padding:10px 12px;
      font-size:14px; user-select:none; -webkit-user-select:none;
    }
    .stick { position:fixed; left:12px; bottom:12px; width:120px; height:120px; z-index:6; touch-action:none }
    .stick .base{
      position:absolute; left:0; top:0; width:100%; height:100%; border-radius:60px; background:rgba(255,255,255,.07); border:1px solid #2a3550
    }
    .stick .nub{
      position:absolute; left:40px; top:40px; width:40px; height:40px; border-radius:20px; background:#1f2a3f; border:1px solid #2a3550
    }
    @media (min-width:820px){ .stick{ display:none; } }

    /* Minimap */
    .minimapBox{
      position:fixed; right:20px; bottom:120px; z-index:5;
      background:rgba(10,12,18,.55); border:1px solid #2a3550; border-radius:18px; padding:8px;
    }
    #minimap{ width:240px; height:160px; display:block; border-radius:12px; background:#0b0f17; }

    /* World map modal */
    .modal{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:8; }
    .modal.on{ display:flex; }
    .modal .sheet{
      width:min(96vw, 760px); background:rgba(17,22,30,.96); border:1px solid #2a3550; border-radius:18px; padding:12px;
    }
    .modal .bar{ display:flex; align-items:center; justify-content:space-between; margin:4px 2px 8px }
    .modal h3{ margin:0; font-size:18px }
    .modal .close{ background:#1a2334; border:1px solid #31405a; color:#cfe0ff; border-radius:10px; padding:6px 10px }
    #worldmap{ width:100%; display:block; border-radius:12px; background:#0b0f17; }
    .legend{ display:flex; gap:16px; align-items:center; margin-top:8px; font-size:13px; opacity:.85 }
    .swatch{ width:18px; height:10px; border:1px solid #2a3550; border-radius:4px; display:inline-block; margin-right:6px }
    .sw-a{ background:#9bb2c9 }         /* unlocked */
    .sw-b{ background:rgba(155,178,201,.45) } /* preview */
    .sw-c{ background:#2a3344 }         /* locked */

    /* Simple in-shop overlay */
    .shopHUD{
      position:fixed; left:50%; top:14px; transform:translateX(-50%);
      background:rgba(20,26,35,.92); border:1px solid #2a3550; border-radius:10px; padding:8px 12px; z-index:7; display:none;
    }
    .shopHUD.on{ display:block; }
  </style>
</head>
<body class="cw-blue theme-a">
  <div class="wrap">
    <div class="hud">
      <div class="left">
        <div class="pill">IZZA GAME</div>
        <div class="pill">Player: {{ user.username }}</div>
      </div>
      <div class="stars" id="stars">
        <div class="star"></div><div class="star"></div><div class="star"></div><div class="star"></div><div class="star"></div>
      </div>
    </div>

    <div id="gameCard">
      <canvas id="game" width="960" height="540" aria-label="IZZA City"></canvas>
    </div>
  </div>

  <!-- Minimap (tap to open full map) -->
  <div class="minimapBox">
    <canvas id="minimap" width="240" height="160" aria-label="IZZA City minimap"></canvas>
  </div>

  <!-- World map modal (fog lives here only) -->
  <div class="modal" id="mapModal" role="dialog" aria-modal="true">
    <div class="sheet">
      <div class="bar">
        <h3>IZZA City — World Map</h3>
        <button class="close" id="closeMap">Close</button>
      </div>
      <canvas id="worldmap" width="1200" height="760"></canvas>
      <div class="legend">
        <span><i class="swatch sw-a"></i>Unlocked</span>
        <span><i class="swatch sw-b"></i>Preview (semi-transparent)</span>
        <span><i class="swatch sw-c"></i>Locked</span>
      </div>
    </div>
  </div>

  <!-- Entered-shop HUD -->
  <div class="shopHUD" id="shopHUD">Welcome to <b>IZZA HQ</b> — press B to exit</div>

  <!-- Virtual joystick + quick buttons for mobile -->
  <div class="stick" id="stick">
    <div class="base"></div>
    <div class="nub" id="nub"></div>
  </div>
  <div class="controls">
    <button class="btn" id="btnA">A</button>
    <button class="btn" id="btnB">B</button>
  </div>

  <script>
  (function(){
    const profile = {{ profile|tojson|safe }};
    const BODY   = profile.sprite_skin || "default";
    const HAIR   = profile.hair || "short";
    const OUTFIT = profile.outfit || "street";

    // --------- Canvas & Viewports ----------
    const cvs = document.getElementById('game');
    const ctx = cvs.getContext('2d');
    const mini = document.getElementById('minimap');
    const mtx  = mini.getContext('2d');
    const world = document.getElementById('worldmap');
    const wtx   = world.getContext('2d');

    // Tiles / scale
    const TILE = 32;
    const SCALE = 4;         // character zoom
    const DRAW = TILE * SCALE;

    // --------- Asset Loader ----------
    function loadImg(src){
      return new Promise((res, rej)=>{
        const i = new Image();
        i.onload = ()=>res(i);
        i.onerror = rej;
        i.src = src;
      });
    }
    const assetRoot = "/static/game/sprites";
    const assets = {
      body:   `${assetRoot}/body/${BODY}.png`,
      hair:   `${assetRoot}/hair/${HAIR}.png`,
      outfit: `${assetRoot}/outfit/${OUTFIT}.png`,
    };

    // --------- World layout (starter district) ----------
    // 0 grass, 1 road, 2 sidewalk, 3 building(solid), 4 doorway(passable)
    const W = 120, H = 90;            // full city grid for map rendering
    const map = new Array(H).fill(0).map(()=>new Array(W).fill(0));

    // Paint background grass
    for (let y=0;y<H;y++) for (let x=0;x<W;x++) map[y][x]=0;

    // Two main roads (vertical + horizontal) and a diagonal reference (drawn on map only)
    function placeRoadH(y0,x1,x2){
      for(let x=x1;x<=x2;x++) map[y0][x]=1;
    }
    function placeRoadV(x0,y1,y2){
      for(let y=y1;y<=y2;y++) map[y][x0]=1;
    }

    // Center cross
    placeRoadH(Math.floor(H/2)+8, 8, W-9);
    placeRoadV(Math.floor(W/2), 6, H-7);

    // Sidewalk belt above the horizontal road
    const sideY = Math.floor(H/2)+7;
    for(let x=8;x<W-8;x++) map[sideY][x]=2;

    // Starter building block with a working door at the curb
    const bx1 = Math.floor(W/2)-12, bx2 = Math.floor(W/2)+12;
    const by1 = sideY-12, by2 = sideY-1;
    for(let y=by1;y<=by2;y++){
      for(let x=bx1;x<=bx2;x++){
        map[y][x]=3; // solid building
      }
    }
    const door = { x: Math.floor((bx1+bx2)/2), y: sideY, w:1, h:1 }; // doorway tile on sidewalk
    map[door.y][door.x]=4; // passable doorway tile marker

    // --------- Unlocked region (hard boundary in gameplay) ----------
    const unlocked = {
      x1: bx1-20,
      y1: sideY-20,
      x2: bx2+20,
      y2: sideY+30
    };

    // --------- Player ----------
    const player = {
      x: (Math.floor(W/2))*TILE,    // world px
      y: (sideY+1)*TILE,
      vx: 0, vy: 0,
      speed: 2.1 * (TILE/16),
      facing: 'down',
      wanted: 0,
      inShop: false
    };

    // --------- Input ----------
    const keys = {};
    window.addEventListener('keydown', e=>{ keys[e.key.toLowerCase()] = true; });
    window.addEventListener('keyup',   e=>{ keys[e.key.toLowerCase()] = false; });

    // Mobile joystick
    const stick = document.getElementById('stick');
    const nub   = document.getElementById('nub');
    let dragging = false, baseRect=null, vec = {x:0,y:0};
    function setNub(dx,dy){
      const r = 40;
      const mag = Math.hypot(dx,dy) || 1;
      const clamped = Math.min(mag, r);
      const ux = dx / mag, uy = dy / mag;
      nub.style.left = (40 + ux*clamped) + 'px';
      nub.style.top  = (40 + uy*clamped) + 'px';
      vec.x = (clamped/r)*ux; vec.y=(clamped/r)*uy;
    }
    function resetNub(){ nub.style.left='40px'; nub.style.top='40px'; vec.x=0; vec.y=0; }
    function startDrag(){ dragging = true; baseRect = stick.getBoundingClientRect(); }
    function moveDrag(e){
      if(!dragging) return;
      const t = e.touches ? e.touches[0] : e;
      const cx = baseRect.left + baseRect.width/2;
      const cy = baseRect.top  + baseRect.height/2;
      setNub(t.clientX - cx, t.clientY - cy);
    }
    function endDrag(){ dragging=false; resetNub(); }
    stick.addEventListener('touchstart', startDrag, {passive:true});
    stick.addEventListener('touchmove',  moveDrag,  {passive:true});
    stick.addEventListener('touchend',   endDrag,   {passive:true});
    stick.addEventListener('mousedown',  startDrag);
    window.addEventListener('mousemove', moveDrag);
    window.addEventListener('mouseup',   endDrag);

    // Buttons
    document.getElementById('btnA').addEventListener('click', ()=> setWanted(player.wanted+1));
    document.getElementById('btnB').addEventListener('click', onPressB);
    window.addEventListener('keydown', e=>{ if(e.key.toLowerCase()==='b'){ onPressB(); }});

    function onPressB(){
      if (atDoor()) {
        player.inShop = !player.inShop;
        document.getElementById('shopHUD').classList.toggle('on', player.inShop);
        // small feedback
        if (player.inShop) setWanted(0);
        return;
      }
      // not at a door -> clear wanted (for now)
      setWanted(0);
    }

    // --------- HUD helpers ----------
    function setWanted(n){
      player.wanted = Math.max(0, Math.min(5, n|0));
      const stars = document.querySelectorAll('#stars .star');
      stars.forEach((s,i)=> s.className = 'star' + (i<player.wanted?' on':'' ));
    }

    // --------- Camera ----------
    const camera = { x:0, y:0 };
    function centerCamera(){
      camera.x = player.x - cvs.width/2;
      camera.y = player.y - cvs.height/2;
      // Clamp to city bounds (so you never see outside image area)
      camera.x = Math.max(0, Math.min(camera.x, W*TILE - cvs.width));
      camera.y = Math.max(0, Math.min(camera.y, H*TILE - cvs.height));
    }

    // --------- Collision ----------
    function tileAt(px,py){
      const tx = Math.floor(px / TILE);
      const ty = Math.floor(py / TILE);
      if (tx<0||ty<0||tx>=W||ty>=H) return 99; // outside
      return map[ty][tx];
    }

    function isSolidTile(t){
      // 3 = building solid; 1/2 are passable; 4 = doorway passable
      return t===3 || t===99;
    }

    function clampToUnlocked(px,py){
      const minx = unlocked.x1*TILE;
      const maxx = (unlocked.x2+1)*TILE - TILE;
      const miny = unlocked.y1*TILE;
      const maxy = (unlocked.y2+1)*TILE - TILE;
      return {
        x: Math.max(minx, Math.min(px, maxx)),
        y: Math.max(miny, Math.min(py, maxy)),
      };
    }

    function atDoor(){
      const tx = Math.floor(player.x / TILE);
      const ty = Math.floor(player.y / TILE);
      return (tx===door.x && ty===door.y);
    }

    // --------- Drawing (tiles) ----------
    function drawTile(gx,gy,screenX,screenY){
      const t = map[gy][gx];
      const S = DRAW;
      if (t===0){ // grass
        ctx.fillStyle = '#0c3f21';
        ctx.fillRect(screenX, screenY, S, S);
        ctx.fillStyle = 'rgba(255,255,255,.03)';
        ctx.fillRect(screenX, screenY, S, 2);
      } else if (t===2){ // sidewalk
        ctx.fillStyle = '#6b7380';
        ctx.fillRect(screenX, screenY, S, S);
        ctx.strokeStyle = 'rgba(0,0,0,.25)';
        ctx.strokeRect(screenX, screenY, S, S);
      } else if (t===1){ // road (with dashed center line only for horizontal segments)
        ctx.fillStyle = '#2b2b2b';
        ctx.fillRect(screenX, screenY, S, S);
        // dashed line: draw only on horizontal main road row
        const roadY = (Math.floor(H/2)+8);
        if (gy===roadY){
          ctx.fillStyle = '#ffd23f';
          const dashW = 10 * (S/64);
          const gap   = 14 * (S/64);
          let x = screenX + 4;
          while (x < screenX + S - dashW){
            ctx.fillRect(x, screenY + (S/2 - 2), dashW, 4);
            x += dashW + gap;
          }
        }
      } else if (t===3){ // building
        ctx.fillStyle = '#4a2d2d';
        ctx.fillRect(screenX, screenY, S, S);
        ctx.fillStyle = 'rgba(0,0,0,.15)';
        ctx.fillRect(screenX, screenY, S, 6);
      } else if (t===4){ // doorway tile
        ctx.fillStyle = '#6b7380'; // sidewalk base
        ctx.fillRect(screenX, screenY, S, S);
        ctx.fillStyle = '#7fc7ff'; // door marker
        ctx.fillRect(screenX + S/2 - S*0.12, screenY + S*0.15, S*0.24, S*0.55);
      }
    }

    function drawPlayer(images){
      const S = DRAW;
      const sx = Math.floor(player.x - camera.x);
      const sy = Math.floor(player.y - camera.y);
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(images.body,   0,0,TILE,TILE, sx, sy, S, S);
      ctx.drawImage(images.outfit, 0,0,TILE,TILE, sx, sy, S, S);
      ctx.drawImage(images.hair,   0,0,TILE,TILE, sx, sy, S, S);
    }

    // --------- Update ----------
    function update(dt){
      if (player.inShop){ return; } // frozen while in “shop” for now

      let dx = 0, dy = 0;
      if (keys['arrowup']||keys['w']) dy -= 1;
      if (keys['arrowdown']||keys['s']) dy += 1;
      if (keys['arrowleft']||keys['a']) dx -= 1;
      if (keys['arrowright']||keys['d']) dx += 1;

      dx += vec.x; dy += vec.y;

      const mag = Math.hypot(dx,dy);
      if (mag > 0){
        dx /= mag; dy /= mag;
        player.vx = dx * player.speed;
        player.vy = dy * player.speed;
      } else {
        player.vx = 0; player.vy = 0;
      }

      // attempt move, then collide against solids + hard unlocked bounds
      let nx = player.x + player.vx * dt;
      let ny = player.y + player.vy * dt;

      // hard region clamp (prevents any black-area slip)
      const clamped = clampToUnlocked(nx, ny);
      nx = clamped.x; ny = clamped.y;

      // check solid tiles at the new position (simple point-in-tile test)
      if (!isSolidTile(tileAt(nx, player.y))) player.x = nx;
      if (!isSolidTile(tileAt(player.x, ny))) player.y = ny;

      centerCamera();
    }

    function render(images){
      ctx.fillStyle = '#000';
      ctx.fillRect(0,0,cvs.width,cvs.height);

      const S = DRAW;
      const tilesX = Math.ceil(cvs.width / S) + 2;
      const tilesY = Math.ceil(cvs.height / S) + 2;
      const startX = Math.max(0, Math.floor(camera.x / TILE));
      const startY = Math.max(0, Math.floor(camera.y / TILE));

      for (let y=0; y<tilesY; y++){
        for (let x=0; x<tilesX; x++){
          const gx = startX + x;
          const gy = startY + y;
          if (gx>=0 && gx<W && gy>=0 && gy<H){
            const screenX = (gx*TILE - camera.x) * (S/TILE);
            const screenY = (gy*TILE - camera.y) * (S/TILE);
            drawTile(gx, gy, screenX, screenY);
          }
        }
      }

      drawPlayer(images);
    }

    // --------- Minimap (no fog) ----------
    function renderMini(){
      mtx.clearRect(0,0,mini.width, mini.height);
      const sx = mini.width / W;
      const sy = mini.height / H;
      for (let y=0;y<H;y++){
        for (let x=0;x<W;x++){
          const t = map[y][x];
          if (t===0) mtx.fillStyle='#254e33';
          else if (t===1) mtx.fillStyle='#4a4a4a';
          else if (t===2) mtx.fillStyle='#7b8493';
          else if (t===3) mtx.fillStyle='#6b3b3b';
          else if (t===4) mtx.fillStyle='#7fc7ff';
          mtx.fillRect(x*sx, y*sy, sx, sy);
        }
      }
      // player dot
      mtx.fillStyle='#00ffd0';
      mtx.fillRect((player.x/TILE)*sx-1, (player.y/TILE)*sy-1, 3, 3);
    }

    // --------- World map (with fog) ----------
    const modal = document.getElementById('mapModal');
    mini.addEventListener('click', ()=>{ drawWorld(); modal.classList.add('on'); });
    document.getElementById('closeMap').addEventListener('click', ()=> modal.classList.remove('on'));

    // simple unlocked/preview/locked masks
    const preview = {
      x1: unlocked.x1-30, y1: unlocked.y1-30,
      x2: unlocked.x2+30, y2: unlocked.y2+30
    };

    function inRect(x,y, r){ return x>=r.x1&&x<=r.x2&&y>=r.y1&&y<=r.y2; }

    function drawWorld(){
      const sx = world.width  / W;
      const sy = world.height / H;
      // base map
      for (let y=0;y<H;y++){
        for (let x=0;x<W;x++){
          const t = map[y][x];
          if (t===0) wtx.fillStyle='#2a5a3a';
          else if (t===1) wtx.fillStyle='#70757a';
          else if (t===2) wtx.fillStyle='#9aa2af';
          else if (t===3) wtx.fillStyle='#8a4a4a';
          else if (t===4) wtx.fillStyle='#9bd4ff';
          wtx.fillRect(x*sx, y*sy, sx, sy);
        }
      }
      // fog overlays (map-only)
      wtx.fillStyle='rgba(155,178,201,.45)'; // preview
      for (let y=0;y<H;y++){
        for (let x=0;x<W;x++){
          if (!inRect(x,y,unlocked) && inRect(x,y,preview) ){
            wtx.fillRect(x*sx, y*sy, sx, sy);
          }
        }
      }
      wtx.fillStyle='#2a3344'; // locked (full)
      for (let y=0;y<H;y++){
        for (let x=0;x<W;x++){
          if (!inRect(x,y,preview)){
            wtx.fillRect(x*sx, y*sy, sx, sy);
          }
        }
      }
      // player
      wtx.fillStyle='#00ffd0';
      wtx.fillRect((player.x/TILE)*sx-2, (player.y/TILE)*sy-2, 4, 4);
    }

    // --------- Main Loop ---------
    Promise.all([ loadImg(assets.body), loadImg(assets.outfit), loadImg(assets.hair) ])
    .then(([body, outfit, hair])=>{
      const imgs = { body, outfit, hair };
      let last = performance.now();
      function loop(now){
        const dt = Math.min(32, now - last); last = now;
        update(dt/16.6667);
        render(imgs);
        renderMini();
        requestAnimationFrame(loop);
      }
      centerCamera();
      requestAnimationFrame(loop);
    }).catch(err=> console.error("Sprite load failed", err));
  })();
  </script>
</body>
</html>
