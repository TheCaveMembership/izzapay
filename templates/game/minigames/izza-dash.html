<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>IZZA DASH — IZZA GAME</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <script>window.IZZA_PERSIST_BASE='https://izzagame.onrender.com';</script>

  <!-- username before persist (same pattern as Arena/Basketball) -->
  <script>
  (function(){
    try{
      const q=new URLSearchParams(location.search);
      let u=(q.get('u')||localStorage.getItem('izzaUserU')||'').toString().trim();
      if(!u){
        const raw=localStorage.getItem('piAuthUser'); if(raw){ try{u=(JSON.parse(raw)||{}).username||'';}catch{} }
      }
      if(u){
        u=u.replace(/^@+/, '').toLowerCase();
        window.__IZZA_PROFILE__=Object.assign({},window.__IZZA_PROFILE__,{username:u});
        window.izzaUserKey={ get:()=>u };
        try{ localStorage.setItem('izzaUserU', u); }catch(_){}
        try{ if(!localStorage.getItem('piAuthUser')) localStorage.setItem('piAuthUser', JSON.stringify({ username:u })); }catch(_){}
      }
    }catch(_){}
  })();
  </script>
  <script src="/static/game/js/izza-persist.js"></script>
  <!-- Three.js -->
  <script src="https://unpkg.com/three@0.157.0/build/three.min.js"></script>

  <link rel="stylesheet" href="/static/themes.css">
  <style>
    :root{
      --hud:rgba(0,0,0,.55); --hudLine:rgba(255,255,255,.18);
      --ok:#72ff9d; --warn:#ffd36b; --bad:#ff6b6b; --arcade:#ffed8a;
    }
    *{box-sizing:border-box}
    body{margin:0;background:#0b0f1a;color:var(--txt);font-family:Arial,Helvetica,sans-serif}

    .wrap{max-width:1100px;margin:0 auto;padding:12px}
    .top{display:flex;justify-content:space-between;align-items:center;gap:8px;margin:10px 0}
    .btn{display:inline-flex;align-items:center;gap:8px;border:1px solid var(--line);
         background:var(--chip-bg);padding:8px 12px;border-radius:10px;color:inherit;text-decoration:none}
    .btn:hover{filter:brightness(1.06)}

    .arena{position:relative;height:74vh;min-height:560px;border:1px solid var(--line);
           border-radius:14px;background:#000;overflow:hidden}
    /* prevent selection/callout ONLY inside the game surface */
    .arena #gl, .arena .overlayUi, .arena .hud, .arena .playerAvatar{
      -webkit-user-select:none; user-select:none; -webkit-touch-callout:none;
    }

    /* HUD — allow wrap on small screens to avoid overlap */
    .hud{position:absolute;left:12px;right:12px;top:12px;display:none;z-index:9;padding-right:8px}
    .hud .left,.hud .right{display:flex;gap:8px;align-items:center;min-width:0}
    .hud{display:flex;flex-wrap:wrap;align-items:flex-start;column-gap:8px;row-gap:6px}
    .hud .left{flex:1 1 320px}
    .hud .right{flex:1 1 200px;justify-content:flex-end}
    .pill{background:var(--hud);border:1px solid var(--hudLine);backdrop-filter:blur(6px);
          padding:6px 12px;border-radius:999px;font-size:12px;font-weight:700;letter-spacing:.2px;display:flex;gap:6px;align-items:center;white-space:nowrap;min-width:0;max-width:100%;overflow:hidden;text-overflow:ellipsis}
    .pill strong{ font-size:14px; font-variant-numeric:tabular-nums; display:inline-block; white-space:nowrap; }
    .pill.button{cursor:pointer; min-width:44px; max-width:none;}

    /* overlays */
    .startOverlay,.endOverlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:11;
      background:linear-gradient(180deg,rgba(0,0,0,.18),rgba(0,0,0,.32));}
    .startCard,.endCard{background:rgba(0,0,0,.55);border:1px solid var(--hudLine);border-radius:14px;padding:18px;
      display:flex;flex-direction:column;gap:10px;align-items:center;max-width:90vw}
    .startBtns{display:flex;gap:8px;flex-wrap:wrap;justify-content:center}
    .startBtn{padding:10px 16px;border-radius:10px;border:1px solid var(--line);background:var(--chip-bg);font-weight:800}

    /* big message */
    .bigmsg{position:absolute;left:50%;top:50%;transform:translate(-50%, -50%);
      font-weight:900;letter-spacing:.6px;font-size:42px;opacity:0;transition:opacity .2s,transform .2s;
      pointer-events:none;text-shadow:0 10px 34px rgba(0,0,0,.45);color:var(--arcade);z-index:10}
    .bigmsg.show{opacity:1;transform:translate(-50%,-56%) scale(1.04)}
    .scoreGlow{color:var(--ok)} .warn{color:var(--warn)} .miss{color:var(--bad)}

    /* avatar — under AMMO pill, but render IN FRONT of HUD */
    .playerAvatar{
      position:absolute; top:84px; left:12px;
      width:64px; height:64px; z-index:12; pointer-events:none
    }
    .playerAvatar canvas{width:64px;height:64px;image-rendering:pixelated;image-rendering:crisp-edges}

    /* webgl canvas + overlay */
    #gl{position:absolute;inset:0;display:block;touch-action:none;width:100%;height:100%}
    .overlayUi{position:absolute;left:0;right:0;bottom:0;display:flex;justify-content:center;gap:10px;padding:10px;z-index:8}
    .chip{background:rgba(255,255,255,.08);border:1px solid var(--hudLine);padding:6px 10px;border-radius:999px;font-size:12px}

    .finish{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
  </style>
</head>
<body class="cw-blue theme-a">
  <div class="wrap">
    <div class="top">
      <a class="btn" id="endBtn" href="#">End Game</a>
      <a class="btn" id="cityBtn" href="/izza-game/play">Enter IZZA City</a>
    </div>

    <div class="arena" id="arena">
      <!-- HUD -->
      <div class="hud" id="hud">
        <div class="left">
          <div class="pill">LEVEL: <strong id="level" class="arc">1</strong></div>
          <div class="pill">AMMO: <strong id="ammo" class="arc">0</strong></div>
          <div class="pill">TIME: <strong id="time" class="arc">30</strong> s</div>
        </div>
        <div class="right">
          <button id="muteBtn" class="pill button" type="button" aria-pressed="false" title="Mute/Unmute (M)">🔊</button>
          <div class="pill">COINS: <strong id="coinsRun" class="arc"></strong></div>
        </div>
      </div>

      <!-- start -->
      <div id="startOverlay" class="startOverlay">
        <div class="startCard">
          <h3 style="margin:0 0 4px">IZZA DASH</h3>
          <p style="margin:0;max-width:28ch;text-align:center">
            Drag to stack the glass blocks. Tap to fire metal balls at incoming crystal spheres.
          </p>
          <div class="startBtns">
            <button id="startBtn" class="startBtn">START</button>
          </div>
        </div>
      </div>

      <!-- WebGL -->
      <canvas id="gl" width="1280" height="720"></canvas>
      <div class="overlayUi"><span class="chip">Drag & Stack • Shatter the Spheres</span></div>

      <!-- Avatar -->
      <div class="playerAvatar" id="playerAvatar"><canvas id="avatarCanvas" width="128" height="128"></canvas></div>

      <div id="bigmsg" class="bigmsg" aria-live="polite">GO!</div>

      <!-- End Game overlay -->
      <div id="endOverlay" class="endOverlay" style="display:none">
        <div class="endCard">
          <h3 style="margin:0 0 4px">Run Complete</h3>
          <div class="finish" id="finish">
            <span class="pill">Run Score: <strong id="finalScore">0</strong></span>
            <span class="pill">Coins Earned: <strong id="finalCoins">0</strong></span>
            <span class="pill">Craft Credits: <strong id="finalCraft">0</strong></span>
          </div>
          <div class="startBtns">
            <button class="btn" id="againBtn">Play Again</button>
            <a class="btn" id="backBtn" href="/izza-game/minigames">Return to Arcade</a>
            <a class="btn" id="cityBtn2" href="/izza-game/play">Enter IZZA City</a>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Optional chill bgm (muted by default until user gesture) -->
  <audio id="bgm" src="/static/game/audio/dash_bgm.mp3" preload="none" loop></audio>

<script>
/* =======================
   Shared auth / links
======================= */
(function(){
  const T_KEY='izzaTokenT', U_KEY='izzaUserU';
  const qs=new URLSearchParams(location.search);
  let T=qs.get('t')||''; let U=(qs.get('u')||'').toString().trim();
  try{
    if(T) localStorage.setItem(T_KEY,T);
    else{ const s=localStorage.getItem(T_KEY)||''; if(s){ const u=new URL(location.href); u.searchParams.set('t',s); history.replaceState(null,'',u.toString()); T=s; } }
  }catch(_){}
  function publishU(u){ if(!u) return u; u=u.replace(/^@+/, '').toLowerCase();
    try{ localStorage.setItem(U_KEY,u); }catch(_){}
    window.__IZZA_PROFILE__=Object.assign({},window.__IZZA_PROFILE__,{username:u});
    window.izzaUserKey={get:()=>u};
    try{ if(!localStorage.getItem('piAuthUser')) localStorage.setItem('piAuthUser', JSON.stringify({ username:u })); }catch(_){}
    return u;
  }
  try{
    if(U) publishU(U);
    else{
      const su=(localStorage.getItem(U_KEY)||'').toString().trim();
      if(su){ const u=new URL(location.href); u.searchParams.set('u',su); history.replaceState(null,'',u.toString()); U=publishU(su); }
    }
  }catch(_){}
  function withAuth(h){ const u=new URL(h, location.origin); if(T) u.searchParams.set('t',T); if(U) u.searchParams.set('u',U); return u.pathname+(u.search?u.search:''); }
  document.querySelectorAll('#cityBtn,#cityBtn2,#backBtn').forEach(a=>{ a.href = withAuth(a.getAttribute('href')); });
  window._withAuth = withAuth;

  /* Seed totals coming from Mini Game Arena (coins/craft) if provided */
  try{
    const coinsParam = qs.get('coins') ?? qs.get('c');
    if(coinsParam!=null && coinsParam!==''){
      const n = Math.max(0, parseInt(coinsParam,10)|0);
      const cur = parseInt(localStorage.getItem('izzaCoins')||'0',10)|0;
      if(n!==cur){ localStorage.setItem('izzaCoins', String(n)); }
    }
    const craftParam = qs.get('craft') ?? qs.get('k');
    if(craftParam!=null && craftParam!==''){
      const n = Math.max(0, parseInt(craftParam,10)|0);
      const keys=['izzaCrafting','craftingCredits','izzaCraftCredits'];
      const cur = parseInt(localStorage.getItem(keys[0])||'0',10)|0;
      if(n!==cur){ for(const k of keys){ localStorage.setItem(k,String(n)); } }
    }
  }catch(_){}
})();

/* =======================
   Wallet helpers
======================= */
(function(){
  const CRAFT_KEYS=['izzaCrafting','craftingCredits','izzaCraftCredits'];
  function readCraftAny(){ for(const k of CRAFT_KEYS){ const v=parseInt(localStorage.getItem(k)||'0',10); if(Number.isFinite(v)&&v>0) return v|0; } return (parseInt(localStorage.getItem(CRAFT_KEYS[0])||'0',10)||0)|0; }
  function writeCraftAll(v){ const n=Math.max(0,v|0); for(const k of CRAFT_KEYS) localStorage.setItem(k,String(n)); try{window.dispatchEvent(new Event('izza-crafting-changed'));}catch(_){ } }
  function readCoins(){ return (parseInt(localStorage.getItem('izzaCoins')||'0',10)|0); }
  function writeCoins(v){ localStorage.setItem('izzaCoins', String((v|0))); try{window.dispatchEvent(new Event('izza-coins-changed'));}catch(_){} }

  window._wallet = { readCraftAny, writeCraftAll, readCoins, writeCoins };
})();

/* =======================
   BGM + SFX
======================= */
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx=null, master=null;
const bgmEl=document.getElementById('bgm');
let desiredMasterGain=0.35, desiredBgmVol=0.25;
function initAudio(){ if(audioCtx) return; audioCtx=new AudioCtx(); master=audioCtx.createGain(); master.gain.value=desiredMasterGain; master.connect(audioCtx.destination); }
function bleep(type='match'){
  if(!audioCtx) return;
  const o=audioCtx.createOscillator(), g=audioCtx.createGain();
  o.connect(g); g.connect(master);
  const now=audioCtx.currentTime;
  if(type==='match'){ o.type='triangle'; o.frequency.setValueAtTime(420,now); o.frequency.exponentialRampToValueAtTime(720,now+0.08); }
  else if(type==='explode'){ o.type='sawtooth'; o.frequency.setValueAtTime(180,now); o.frequency.exponentialRampToValueAtTime(90,now+0.18); }
  else if(type==='tick'){ o.type='square'; o.frequency.setValueAtTime(680,now); o.frequency.exponentialRampToValueAtTime(520,now+0.05); }
  g.gain.setValueAtTime(0.001,now);
  g.gain.exponentialRampToValueAtTime(0.55,now+0.02);
  g.gain.exponentialRampToValueAtTime(0.001,now+0.22);
  o.start(now); o.stop(now+0.24);
}
const muteBtn=document.getElementById('muteBtn');
function applyMuteState(m){
  try{ localStorage.setItem('izzaMute',''+(m?1:0)); }catch(_){}
  muteBtn.textContent = m ? '🔇' : '🔊';
  muteBtn.setAttribute('aria-pressed', m?'true':'false');
  if(bgmEl){ bgmEl.muted = !!m; if(!m) bgmEl.volume = desiredBgmVol; }
  if(master){ master.gain.value = m?0:desiredMasterGain; }
}
muteBtn.addEventListener('click',()=>applyMuteState(!(muteBtn.getAttribute('aria-pressed')==='true')), {passive:true});
window.addEventListener('keydown',(e)=>{ if(e.key==='m'||e.key==='M'){ e.preventDefault(); applyMuteState(!(muteBtn.getAttribute('aria-pressed')==='true')); }},{passive:false});
applyMuteState(localStorage.getItem('izzaMute')==='1');

/* =======================
   Snapshot hydrate
======================= */
async function ensureSession(){
  try{
    const r=await fetch(_withAuth('/izza-game/api/character'),{credentials:'include',headers:{'content-type':'application/json'}});
    if(r.ok){ const j=await r.json().catch(()=>({})); try{ localStorage.setItem('izzaCharacter', JSON.stringify(j)); }catch(_){}
      const uname=(j.user&&j.user.username)||j.username||j.handle||''; if(uname){ /* seeded earlier */ }
      return j;
    }
  }catch(_){}
  return JSON.parse(localStorage.getItem('izzaCharacter')||'{}')||{};
}

/* =======================
   UI refs
======================= */
const levelEl = document.getElementById('level');
const ammoEl  = document.getElementById('ammo');
const timeEl  = document.getElementById('time');
const coinsRunEl=document.getElementById('coinsRun');
const startBtn= document.getElementById('startBtn');
const startOverlay=document.getElementById('startOverlay');
const endOverlay=document.getElementById('endOverlay');
const bigmsg = document.getElementById('bigmsg');
const hudEl  = document.getElementById('hud');
const endBtn = document.getElementById('endBtn');

function showMsg(t, cls){ bigmsg.textContent=t; bigmsg.className='bigmsg show ' + (cls||''); setTimeout(()=>bigmsg.className='bigmsg',820); }
function paintCoinsHUD(n){ coinsRunEl.textContent=String(Math.max(0, n|0)); }

/* =======================
   Avatar (trimmed)
======================= */
const SPRITES={ body:{ default:"/static/game/sprites/body/default.png", street_a:"/static/game/sprites/body/street_a.png", street_b:"/static/game/sprites/body/street_b.png" },
                hair:{ short:"/static/game/sprites/hair/short.png", buzz:"/static/game/sprites/hair/buzz.png", long:"/static/game/sprites/hair/long.png" },
                outfit:{ street:"/static/game/sprites/outfit/street.png", athletic:"/static/game/sprites/outfit/athletic.png", luxury:"/static/game/sprites/outfit/luxury.png" } };
const SKIN_BASE=["#F7D7C6","#E8BEA8","#D6A48E"];
const SKIN_TO={ light:["#FFE7D6","#F3C6A7","#D8A187"], medium:["#F1BD94","#D79A73","#B67955"], tan:["#E2A878","#C88756","#9F663C"], dark:["#B9825B","#9A6644","#714A31"], deep:["#8B5A3B","#6A402A","#432818"] };
const FEMALE_DRESS_BASE=["#7AB6FF","#4E84E3","#2F5CB5"];
const FEMALE_DRESS_TO={ blue:["#7AB6FF","#4E84E3","#2F5CB5"], red:["#FF7A7A","#E24C4C","#B12F2F"], green:["#7DD68A","#4CB56B","#2F7F47"], purple:["#B796FF","#8C6BE0","#6A49B8"], yellow:["#FFE08A","#E7C45A","#B89433"], pink:["#FFA6D6","#E57CB2","#C45C96"], black:["#3A3A3D","#232326","#0E0E10"], white:["#FFFFFF","#E6E6E6","#C9C9C9"] };
const HAIR_TO={ black:["#2C2C31","#17171B","#0A0A0D"], brown:["#7A5336","#5C3E28","#3A3A1B"], blonde:["#FBE58F","#E5C35A","#B89433"], red:["#E65F35","#B54426","#8E321A"], white:["#FFFFFF","#E6E6E6","#C9C9C9"], blue:["#7AB6FF","#4E84E3","#2F5CB5"], green:["#7DD68A","#4CB56B","#2F7F47"], pink:["#FFA6D6","#E57CB2","#C45C96"] };
function loadImg(src){ return new Promise(res=>{ const i=new Image(); i.crossOrigin='anonymous'; i.onload=()=>res(i); i.onerror=()=>res(null); i.src=src; }); }
function paletteSwap(img, fromHex, toHex, tol=4000){
  const hexToRgb=h=>{ const n=parseInt(h.replace('#',''),16); return {r:(n>>16)&255,g:(n>>8)&255,b:n&255}; };
  const from=fromHex.map(h=>hexToRgb(h)), to=toHex.map(h=>hexToRgb(h));
  const w=img.width,h=img.height, oc=document.createElement('canvas'); oc.width=w; oc.height=h;
  const cx=oc.getContext('2d',{willReadFrequently:true}); cx.imageSmoothingEnabled=false; cx.drawImage(img,0,0);
  const id=cx.getImageData(0,0,w,h),d=id.data;
  function sd(a,b){const dr=a.r-b.r,dg=a.g-b.g,db=a.b-b.b;return dr*dr+dg*dg+db*db;}
  for(let i=0;i<d.length;i+=4){
    if(d[i+3]===0) continue; const p={r:d[i],g:d[i+1],b:d[i+2]}; let best=-1,score=1e9;
    for(let k=0;k<from.length;k++){ const s=sd(p,from[k]); if(s<score){score=s;best=k;} }
    if(score<=tol){ const t=to[best]||to[1]||to[0]; d[i]=t.r; d[i+1]=t.g; d[i+2]=t.b; }
  }
  cx.putImageData(id,0,0); return oc;
}
async function buildAvatarCanvas(dstCtx,size,profile){
  const DW=size,DH=size,X=0,Y=0;
  const type=profile.body_type||'male', tone=profile.skin_tone||'light', theme=profile.sprite_skin||'default';
  const outfitKey=profile.outfit||'street', hairKey=profile.hair||'short', hairCol=profile.hair_color||'black';
  const femaleOut=profile.female_outfit_color||'blue';
  let body=null;
  if(type==='female'){ const femaleWide=`/static/game/sprites/body/${theme}__female_wide.png`; const femaleSlim=`/static/game/sprites/body/${theme}__female.png`; body=await loadImg(femaleWide)||await loadImg(femaleSlim); }
  if(!body) body=await loadImg(SPRITES.body[theme]||SPRITES.body.default);
  const hair=await loadImg(SPRITES.hair[hairKey]||SPRITES.hair.short);
  const outfit=(type==='female')?null:(await loadImg(SPRITES.outfit[outfitKey]||SPRITES.outfit.street));
  let bodyCanvas=null;
  if(body){ const target=SKIN_TO[tone]||SKIN_TO.light; const ramp=paletteSwap(body, ["#F7D7C6","#E8BEA8","#D6A48E"], target, 4000); bodyCanvas=ramp; }
  if(type==='female'&&bodyCanvas){ const target=FEMALE_DRESS_TO[femaleOut]||FEMALE_DRESS_TO.blue; bodyCanvas=paletteSwap(bodyCanvas, ["#7AB6FF","#4E84E3","#2F5CB5"], target, 4000); }
  dstCtx.clearRect(0,0,DW,DH);
  if(bodyCanvas) dstCtx.drawImage(bodyCanvas, X, Y, DW, DH);
  if(outfit) dstCtx.drawImage(outfit, X, Y, DW, DH);
  if(hair){
    const ramp=["#C8C8C8","#9C9C9C","#6E6E6E"], target=HAIR_TO[hairCol]||HAIR_TO.black;
    const hairCanvas=paletteSwap(hair, ramp, target, 4000);
    dstCtx.drawImage(hairCanvas, X, Y, DW, DH);
  }
  try{ await drawEquippedOverlaysForAvatar(dstCtx, size); }catch(_){}
}
/* equipped overlay */
(function(){
  const BOX128=Object.freeze({ head:{w:59,h:59,ox:64,oy:32,scale:1.12}, chest:{w:61,h:61,ox:64,oy:60,scale:1.15}, arms:{w:75,h:59,ox:64,oy:60,scale:1.15}, legs:{w:72,h:61,ox:64,oy:88,scale:1.18}, hands:{w:85,h:61,ox:86,oy:72,scale:1.34} });
  const cache=new Map(); const imgFromSvg=s=>{ if(!s) return null; if(cache.has(s)) return cache.get(s); const i=new Image(); i.decoding='async'; i.src='data:image/svg+xml;utf8,'+encodeURIComponent(s); cache.set(s,i); return i; };
  function readInv(){ try{ const iz=window.IZZA?.api?.getInventory?.(); if(iz) return JSON.parse(JSON.stringify(iz)); }catch(_){}
    try{ return JSON.parse(localStorage.getItem('izzaInventory')||'{}'); }catch(_){ return {}; } }
  function isEq(it){ return !!(it&&(it.equipped===true||it.equip===true||((it.equippedCount|0)>0))); }
  function equippedIn(slot){ const inv=readInv(); for(const k in inv){ const it=inv[k]; if(!it) continue; if((it.slot||'').toLowerCase()!==slot) continue; if(!isEq(it)) continue; const svg=(it.overlaySvg&&String(it.overlaySvg).trim())||(it.iconSvg&&String(it.iconSvg).trim())||''; return {key:k,it,svg}; } return null; }
  function drawOne(ctx, svg, box, mul=1){ const im=imgFromSvg(svg); if(!im||!im.complete) return false; const w=Math.max(8,box.w|0),h=Math.max(8,box.h|0); const s=(box.scale||1)*mul;
    ctx.save(); ctx.imageSmoothingEnabled=false; ctx.translate(box.ox|0, box.oy|0); if(s!==1) ctx.scale(s,s);
    try{ ctx.drawImage(im, -(w/2)|0, -(h/2)|0, w,h); }catch(_){ } ctx.restore(); return true; }
  async function drawEquippedOverlaysForAvatar(ctx, size){
    const k=(size>0?size/128:1);
    function scaled(b){ return { w:Math.round(b.w+k-k),h:Math.round(b.h+k-k),ox:Math.round(b.ox*k),oy:Math.round(b.oy*k),scale:b.scale }; }
    const legs =equippedIn('legs');  if(legs ) drawOne(ctx, legs .svg, scaled(BOX128.legs ));
    const chest=equippedIn('chest'); if(chest) drawOne(ctx, chest.svg, scaled(BOX128.chest));
    const arms =equippedIn('arms');  if(arms ) drawOne(ctx, arms .svg, scaled(BOX128.arms ));
    const head =equippedIn('head');  if(head ) drawOne(ctx, head .svg, scaled(BOX128.head ));
    const hands=equippedIn('hands'); if(hands) drawOne(ctx, hands.svg, scaled(BOX128.hands));
  }
  window.drawEquippedOverlaysForAvatar=drawEquippedOverlaysForAvatar;
})();

/* =======================
   THREE.js — Basic Stack Game
======================= */
const glCanvas = document.getElementById('gl');
const arenaEl  = document.getElementById('arena');
let scene, camera, renderer, raycaster, pointer, dragging=false, dragObj=null;
let world, floorRing, floorPlate, spheres=[], ammo=0, level=1, timeLeft=30, ended=false, runStartCoins=0, score=0;

/* per-level scaling */
function ringScaleForLevel(lv){ return 1 + 0.10 * Math.max(0, lv-1); }
function pieceScaleForLevel(lv){ return 1 / (1 + 0.06 * Math.max(0, lv-1)); }
function projScaleForLevel(lv){ return 1 / (1 + 0.06 * Math.max(0, lv-1)); }
function cameraForLevel(lv){
  const baseY=3.4, baseZ=9.8;
  const y=baseY + Math.min(lv*0.18, 3.5);
  const z=baseZ + Math.min(lv*0.9, 22);
  camera.position.set(0,y,z);
  camera.lookAt(0,0,0);
}

let currentPieceS=1, baseY= -0.5; // updated per level

function hardResize(){
  const r = (arenaEl || glCanvas).getBoundingClientRect();
  const W = Math.max(1, Math.floor(r.width));
  const H = Math.max(1, Math.floor(r.height));
  const dpr = Math.min(window.devicePixelRatio||1, 2);
  if(renderer){
    renderer.setSize(W,H,false);
    renderer.setPixelRatio(dpr);
  }
  if(camera){
    camera.aspect=W/H; camera.updateProjectionMatrix();
  }
}
window.addEventListener('resize', hardResize, {passive:true});

/* materials */
function glass(tint){
  return new THREE.MeshStandardMaterial({
    color: new THREE.Color(tint),
    metalness: 0.15,
    roughness: 0.35,
    transparent: true,
    opacity: 0.85,
    emissive: new THREE.Color(0x0c1220),
    emissiveIntensity: 0.25
  });
}
function metal(){ return new THREE.MeshStandardMaterial({ color: 0xb7c1cf, metalness: 0.95, roughness: 0.25 }); }
const COLORS=[0x7fd4ff,0x6cf0b0,0xff9cff,0xffe266,0x9ae1ff,0x9dffcc];

function makeCube(size=1,tint=0x7fd4ff){
  const m=new THREE.Mesh(new THREE.BoxGeometry(size,size,size), glass(tint));
  m.castShadow=true; m.receiveShadow=true; m.userData.kind='cube';
  return m;
}
function makeRectPrism(w=1.4,h=1,d=1,tint=0x7fd4ff){
  const m=new THREE.Mesh(new THREE.BoxGeometry(w,h,d), glass(tint));
  m.castShadow=true; m.receiveShadow=true; m.userData.kind='rect';
  return m;
}
function makeCrystal(){
  const s=new THREE.Mesh(new THREE.SphereGeometry(0.5,28,20), glass(0xcee9ff));
  s.castShadow=true; s.receiveShadow=true; s.userData.v=new THREE.Vector3();
  return s;
}

function initThree(){
  scene=new THREE.Scene(); scene.background=new THREE.Color(0x0f182b);
  camera=new THREE.PerspectiveCamera(55,1,0.1,300); camera.position.set(0,3.4,9.8); camera.lookAt(0,0,0);
  renderer=new THREE.WebGLRenderer({canvas:glCanvas,antialias:true,alpha:false,powerPreference:'high-performance'});
  renderer.shadowMap.enabled=true; renderer.toneMapping=THREE.ACESFilmicToneMapping; renderer.toneMappingExposure=1.8;

  scene.add(new THREE.AmbientLight(0x9fbfff,0.8));
  const k=new THREE.DirectionalLight(0xd8ecff,1.6); k.position.set(-4,7,6); k.castShadow=true; scene.add(k);
  const hemi=new THREE.HemisphereLight(0x89b4ff,0x102036,0.6); scene.add(hemi);

  world=new THREE.Group(); scene.add(world);

  // base plate + ring (scaled per level)
  floorPlate=new THREE.Mesh(new THREE.CircleGeometry(3.6,64), new THREE.MeshStandardMaterial({color:0x0e2448,metalness:.2,roughness:.7}));
  floorPlate.rotation.x=-Math.PI/2; floorPlate.position.y=-1; floorPlate.receiveShadow=true; world.add(floorPlate);
  floorRing=new THREE.Mesh(new THREE.TorusGeometry(2.6,0.03,16,100), new THREE.MeshBasicMaterial({color:0x7dc3ff,transparent:true,opacity:.9}));
  floorRing.rotation.x=Math.PI/2; floorRing.position.y=-0.98; world.add(floorRing);

  raycaster=new THREE.Raycaster(); pointer=new THREE.Vector2();
  hardResize();
}

/* ---------- Level logic ---------- */
let blocks=[], projectilePool=[];
function clearScene(){
  for(const m of blocks){ world.remove(m); }
  for(const s of spheres){ world.remove(s); }
  for(const p of projectilePool){ world.remove(p); }
  blocks.length=0; spheres.length=0; projectilePool.length=0;
}

function layoutLevel(){
  clearScene();

  // camera & board scaling
  cameraForLevel(level);
  const rS = ringScaleForLevel(level);
  floorPlate.scale.set(rS,rS,1);
  floorRing.scale.set(rS,rS,rS);

  currentPieceS = pieceScaleForLevel(level);
  baseY = -0.5 * currentPieceS; // <-- board surface anchor

  const pieceCount = Math.max(2, 1 + level);
  const baseRingR = 2.6 * rS;
  const safeRadiusX = baseRingR*0.85, safeRadiusZ = baseRingR*0.50;
  const spacing = 1.25*currentPieceS + 0.15;
  const startX = -((pieceCount-1)/2)*spacing;

  for(let i=0;i<pieceCount;i++){
    const tint = COLORS[(Math.random()*COLORS.length)|0];
    const mesh = (level>=4 && i===pieceCount-1)
      ? makeRectPrism(1.6*currentPieceS,1*currentPieceS,1*currentPieceS,tint)
      : makeCube(1*currentPieceS,tint);
    const x = Math.max(-safeRadiusX, Math.min(safeRadiusX, startX + i*spacing));
    const z = Math.max(-safeRadiusZ, Math.min(safeRadiusZ, (Math.random()*2*safeRadiusZ - safeRadiusZ)));
    mesh.position.set(x, baseY, z);               // <-- sits flat on surface
    world.add(mesh); blocks.push(mesh);
  }

  /* Incoming spheres — EXACTLY 2, falling from the TOP CORNERS */
  spheres.length=0;
  const yTop = 6 + Math.random()*1.2;
  const zTop = -baseRingR * 0.45;       // back/top edge of board
  const xOff = baseRingR * 0.9;
  const corners = [ new THREE.Vector3(-xOff, yTop, zTop), new THREE.Vector3(xOff, yTop, zTop) ];
  for(const pos of corners){
    const s=makeCrystal();
    s.position.copy(pos);
    const target = new THREE.Vector3(0, 0, 0);
    const dir = target.clone().sub(s.position).normalize();
    const speed = (0.75 + 0.05*level) / rS; // tuned against zoom so not too fast
    s.userData.v.copy(dir.multiplyScalar(speed));
    world.add(s); spheres.push(s);
  }

  ammo = Math.min(2+level, 12);
  ammoEl.textContent = ammo;
  levelEl.textContent = level;

  /* reset timer to 30s for THIS level */
  timeLeft = 30;
  timeEl.textContent = timeLeft;

  showMsg('LEVEL '+level,'');
}

/* ----- coin → craft awarding (additional) ----- */
let craftsGrantedThisRun = 0;
function maybeGrantCraftCredits(){
  const gained = Math.max(0, _wallet.readCoins() - runStartCoins);
  const shouldHave = Math.floor(gained / 1000);
  if(shouldHave > craftsGrantedThisRun){
    const delta = shouldHave - craftsGrantedThisRun;
    _wallet.writeCraftAll(_wallet.readCraftAny() + delta);
    craftsGrantedThisRun = shouldHave;
  }
}

function awardAndNext(){
  const coinsWon = 100*level;
  _wallet.writeCoins(_wallet.readCoins()+coinsWon);
  paintCoinsHUD(_wallet.readCoins());
  maybeGrantCraftCredits();

  const justBeat = level;
  showMsg('LEVEL '+justBeat+' COMPLETE!', 'scoreGlow');
  setTimeout(()=>{
    level++; score = level-1;
    showMsg('LEVEL '+level+' — GO!', '');
    setTimeout(()=>{ layoutLevel(); }, 420);
  }, 700);
}

/* ---------- Drag & place ---------- */
function screenToPlane(e, planeY=0){
  const rect=(arenaEl||glCanvas).getBoundingClientRect();
  pointer.x=((e.clientX-rect.left)/rect.width)*2-1;
  pointer.y=-((e.clientY-rect.top)/rect.height)*2+1;
  raycaster.setFromCamera(pointer,camera);
  const plane=new THREE.Plane(new THREE.Vector3(0,1,0), -planeY);
  const hit=new THREE.Vector3();
  raycaster.ray.intersectPlane(plane,hit);
  return hit;
}
function pickBlock(e){
  const rect=(arenaEl||glCanvas).getBoundingClientRect();
  pointer.x=((e.clientX-rect.left)/rect.width)*2-1;
  pointer.y=-((e.clientY-rect.top)/rect.height)*2+1;
  raycaster.setFromCamera(pointer,camera);
  const hits=raycaster.intersectObjects(blocks,false);
  if(hits.length){ return hits[0].object; }
  return null;
}
function onDown(e){
  if(ended) return;
  const p=pickBlock(e);
  if(p){ dragging=true; dragObj=p; }
}
function onMove(e){
  if(!dragging||!dragObj) return;
  const h=screenToPlane(e, 0);
  const rS = ringScaleForLevel(level);
  const baseRingR = 2.6 * rS;
  const safeX = THREE.MathUtils.clamp(h.x, -baseRingR*0.92, baseRingR*0.92);
  const safeZ = THREE.MathUtils.clamp(h.z, -baseRingR*0.55, baseRingR*0.55);
  dragObj.position.set(safeX, baseY, safeZ);      // <-- stays on surface while dragging
}

/* helpers for stacking */
function halfH(mesh){ return (mesh.geometry?.parameters?.height || 1) * 0.5; }
function hDistVec(a, b){ const dx=a.x-b.x, dz=a.z-b.z; return Math.hypot(dx, dz); }

function onUp(){
  if(!dragging||!dragObj) return;

  // magnetize to nearest stack center in XZ
  let best=null, bestD=1e9;
  for(const b of blocks){
    if(b===dragObj) continue;
    const d = hDistVec(b.position, dragObj.position);
    if(d < bestD){ best=b; bestD=d; }
  }

  const SNAP_R = 1.05;
  const STACK_TOL = 0.12;

  if(best && bestD < SNAP_R){
    const baseX = best.position.x, baseZ = best.position.z;
    let highestTopY = -Infinity;

    for(const b of blocks){
      if(b===dragObj) continue;
      if(hDistVec({x:baseX,z:baseZ}, b.position) < STACK_TOL){
        const topY = b.position.y + halfH(b);
        if(topY > highestTopY) highestTopY = topY;
      }
    }
    // If no block exists at that spot, anchor to the floor (no floating base block)
    if(!Number.isFinite(highestTopY)){ highestTopY = baseY + 0.0; }

    dragObj.position.x = baseX;
    dragObj.position.z = baseZ;
    dragObj.position.y = highestTopY + halfH(dragObj);
    try{ bleep('match'); }catch(_){}
  }else{
    // If no snap, ensure the block remains on the floor
    dragObj.position.y = baseY;
  }

  dragging=false; dragObj=null;
  checkWin();
}
glCanvas.addEventListener('pointerdown', onDown, {passive:true});
glCanvas.addEventListener('pointermove', onMove, {passive:true});
window.addEventListener('pointerup', onUp, {passive:true});

/* ---------- Shoot metal balls FROM TAP, with auto-aim at nearest sphere ---------- */
function fireMetal(e){
  if(ended) return;
  if(ammo<=0) return;
  if(pickBlock(e)) return; // let dragging win if user tapped a block

  ammo--; ammoEl.textContent=ammo;

  // Spawn at tap point (on board plane), slightly above the surface
  const origin=screenToPlane(e, 0);
  origin.y = baseY + 0.1;

  // Pick the nearest active sphere to this tap point
  let target = null, best=1e9;
  for(const s of spheres){
    const d = origin.distanceTo(s.position);
    if(d<best){best=d; target=s;}
  }
  const dir = target ? target.position.clone().sub(origin).normalize() : new THREE.Vector3(0,1,0);

  const pScale = projScaleForLevel(level);
  const b=new THREE.Mesh(new THREE.SphereGeometry(0.22*pScale,20,16), metal());
  b.position.copy(origin);

  const rS = ringScaleForLevel(level);
  b.userData.v=dir.multiplyScalar(9.0*rS);
  b.userData.ttl=5.0;

  b.castShadow=true; world.add(b); projectilePool.push(b);
}
glCanvas.addEventListener('click', fireMetal, {passive:true});

/* ---------- Collisions / win / fail ---------- */
function checkWin(){
  const xs=blocks.map(b=>b.position.x), zs=blocks.map(b=>b.position.z);
  const xOk = Math.max(...xs)-Math.min(...xs) < 0.05;
  const zOk = Math.max(...zs)-Math.min(...zs) < 0.05;
  if(!(xOk && zOk)) return;
  const ys=blocks.map(b=>b.position.y).sort((a,b)=>a-b);
  for(let i=1;i<ys.length;i++){ if(ys[i]-ys[i-1] < 0.8*currentPieceS) return; }
  awardAndNext();
}
function fail(){
  showMsg('IZZA DASH STACK SMASHED','miss');
  setTimeout(()=>{ showEndOverlay(); }, 420); /* show message, then end screen */
}

/* --- geometric helper: distance from point C to segment AB --- */
function distPointToSegment(c,a,b){
  const ab = b.clone().sub(a);
  const t = THREE.MathUtils.clamp(c.clone().sub(a).dot(ab)/ab.lengthSq(), 0, 1);
  const proj = a.clone().add(ab.multiplyScalar(t));
  return proj.distanceTo(c);
}

/* ---------- Loop ---------- */
let last=performance.now();
function loop(t){
  const dt=Math.min(0.033,(t-last)/1000); last=t;

  const pRad = 0.22*projScaleForLevel(level);
  const sRad = 0.5;
  const hitR = (pRad + sRad) * 1.35;

  for(let i=spheres.length-1;i>=0;i--){
    const s=spheres[i];
    s.position.addScaledVector(s.userData.v, dt);

    // Any contact with any block → GAME OVER
    for(const b of blocks){
      if(s.position.distanceTo(b.position) < 0.8*currentPieceS){
        fail();
        return requestAnimationFrame(loop);
      }
    }

    // Projectile collision (swept)
    for(let j=projectilePool.length-1;j>=0;j--){
      const p=projectilePool[j];
      const nextP = p.position.clone().addScaledVector(p.userData.v, dt);
      const d = distPointToSegment(s.position, p.position, nextP);
      if(d < hitR){
        world.remove(s); spheres.splice(i,1);
        world.remove(p); projectilePool.splice(j,1);
        try{ bleep('explode'); }catch(_){}
        break;
      }
    }

    if(s.position.y <= baseY){ fail(); return requestAnimationFrame(loop); } // reached board → GAME OVER
  }

  for(let j=projectilePool.length-1;j>=0;j--){
    const p=projectilePool[j];
    p.position.addScaledVector(p.userData.v, dt);
    p.userData.ttl -= dt;
    if(p.userData.ttl<=0){ world.remove(p); projectilePool.splice(j,1); }
  }
  renderer.render(scene,camera);
  if(!ended) requestAnimationFrame(loop);
}

/* =======================
   Timer + Boot + End
======================= */
function tickTimer(){
  if(ended) return;
  timeLeft--; timeEl.textContent=timeLeft;
  try{ bleep('tick'); }catch(_){}
  if(timeLeft<=0){
    showMsg('TIME OUT','miss');
    showEndOverlay(); /* TIME OUT → end screen */
  }
}

/* ===== Leaderboard submit (uses IZZA_LEADERBOARD; game id = 'puzzle') ===== */
async function submitLeaderboard(finalScore){
  try{
    if(window.IZZA_LEADERBOARD && typeof IZZA_LEADERBOARD.submit==='function'){
      await IZZA_LEADERBOARD.submit({ game:'puzzle', score: finalScore|0 });
    }else{
      // legacy-compatible fallback; persist shim intercepts this too
      await fetch(_withAuth('/izza-game/api/leaderboard/submit'),{
        method:'POST',credentials:'include',
        headers:{'content-type':'application/json'},
        body:JSON.stringify({ game:'puzzle', score: finalScore|0 })
      }).catch(()=>{});
    }
    // cache locally so it shows up offline/in snapshot — keep ONLY the user's highest score
    const u=(window.izzaUserKey&&izzaUserKey.get&&izzaUserKey.get())||'guest';
    const row={u, s:finalScore|0, ts:Date.now()};
    const z=n=>String(n).padStart(2,'0'); const d=new Date();
    const stamps={ day:`${d.getFullYear()}-${z(d.getMonth()+1)}-${z(d.getDate())}`, month:`${d.getFullYear()}-${z(d.getMonth()+1)}`, year:String(d.getFullYear()) };

    // helper to upsert by username, keeping the highest score only
    function upsertHigh(key, r){
      try{
        const arr=JSON.parse(localStorage.getItem(key)||'[]');
        let found=false;
        for(let i=0;i<arr.length;i++){
          if(arr[i] && arr[i].u===r.u){
            found=true;
            if((arr[i].s|0) < (r.s|0)) arr[i]=r; // replace only if higher
            break;
          }
        }
        if(!found){ arr.push(r); }
        arr.sort((a,b)=>b.s-a.s);
        localStorage.setItem(key, JSON.stringify(arr.slice(0,20)));
      }catch(_){}
    }

    // all-time
    upsertHigh('izzaLb2::puzzle::alltime', row);

    // daily / monthly / annual
    upsertHigh(`izzaLb2::puzzle::day::${stamps.day}`, row);
    upsertHigh(`izzaLb2::puzzle::month::${stamps.month}`, row);
    upsertHigh(`izzaLb2::puzzle::year::${stamps.year}`, row);
  }catch(_){}
}

function showEndOverlay(){
  if(ended) return;
  ended=true;
  const totalCoins = _wallet.readCoins();
  const runCoins = Math.max(0,totalCoins - runStartCoins);
  document.getElementById('finalScore').textContent = String(score|0);
  document.getElementById('finalCoins').textContent = String(runCoins|0);
  document.getElementById('finalCraft').textContent = String(craftsGrantedThisRun|0);
  endOverlay.style.display='flex';
  submitLeaderboard(score|0); // ensure IZZA DASH (puzzle) posts & persists
}

async function refreshAvatar(){
  try{
    const cvs=document.getElementById('avatarCanvas'), ctx=cvs.getContext('2d'); ctx.imageSmoothingEnabled=false;
    const prof=JSON.parse(localStorage.getItem('izzaCharacter')||'{}')||{};
    await buildAvatarCanvas(ctx, 96, prof);
  }catch(_){}
}

async function start(){
  try{
    await ensureSession();
    if(window.IZZA_PERSIST?.load) await IZZA_PERSIST.load();
  }catch(_){}
  paintCoinsHUD(_wallet.readCoins());
  runStartCoins=_wallet.readCoins();
  craftsGrantedThisRun = 0;

  // avatar (+ retry once after a short delay)
  await refreshAvatar(); setTimeout(refreshAvatar, 400);

  try{
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    window.audioCtx = window.audioCtx || new AudioCtx();
    await audioCtx.resume();
    initAudio();
    bgmEl.volume=0.25; bgmEl.muted=(localStorage.getItem('izzaMute')==='1'); bgmEl.currentTime=0; bgmEl.play().catch(()=>{});
  }catch(_){}

  // 3D
  initThree();
  level=1; timeLeft=30; ended=false; score=0;
  layoutLevel();
  setInterval(()=>{ if(!ended) tickTimer(); }, 1000);

  // Reveal HUD only after start
  hudEl.style.display='flex';
  startOverlay.style.display='none';
  showMsg('GO!');
  requestAnimationFrame(loop);
}
document.getElementById('startBtn').addEventListener('click', start, {passive:true});

/* “End Game” button -> popup with results */
endBtn.addEventListener('click', (e)=>{ e.preventDefault(); showEndOverlay(); }, {passive:false});

/* Play Again (reset state, restart run) */
document.addEventListener('click', (e)=>{
  const btn = e.target && e.target.id==='againBtn';
  if(!btn) return;
  e.preventDefault();
  endOverlay.style.display='none';
  // reset run state
  score = 0; level = 1; timeLeft = 30; ended = false;
  runStartCoins = _wallet.readCoins();
  craftsGrantedThisRun = 0;
  // clear scene if needed and layout level 1
  if(!scene || !renderer) initThree();
  layoutLevel();
  requestAnimationFrame(loop);
}, {passive:false});

/* keep HUD coins synced if other tabs alter wallet */
window.addEventListener('storage', (e)=>{ if(e && e.key==='izzaCoins'){ paintCoinsHUD(_wallet.readCoins()); } }, {passive:true});
window.addEventListener('izza-coins-changed', ()=>paintCoinsHUD(_wallet.readCoins()), {passive:true});
window.addEventListener('pageshow', ()=>paintCoinsHUD(_wallet.readCoins()), {passive:true});

/* prevent long-press menu only inside the game display (not the START card) */
document.getElementById('gl').addEventListener('contextmenu', e=>e.preventDefault(), {passive:false});
document.getElementById('arena').addEventListener('selectstart', e=>{
  if(e.target.id==='gl' || e.target.closest('#gl')) e.preventDefault();
},{passive:false});

window.addEventListener('pagehide', ()=>{ try{ IZZA_PERSIST?.save?.(); }catch(_){} }, {passive:true});
</script>
</body>
</html>
