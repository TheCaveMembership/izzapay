<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>IZZA SOLITAIRE â€” IZZA GAME</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no">
  <script>window.IZZA_PERSIST_BASE='https://izzagame.onrender.com';</script>

  <!-- Make username available before persist loads (Arena pattern) -->
  <script>
  (function(){
    try{
      const q=new URLSearchParams(location.search);
      let u=(q.get('u')||localStorage.getItem('izzaUserU')||'').toString().trim();
      if(!u){
        const raw=localStorage.getItem('piAuthUser');
        if(raw){ try{ u=(JSON.parse(raw)||{}).username||''; }catch{} }
      }
      if(u){
        u=u.replace(/^@+/, '').toLowerCase();
        window.__IZZA_PROFILE__=Object.assign({},window.__IZZA_PROFILE__,{username:u});
        window.izzaUserKey={ get:()=>u };
        try{ localStorage.setItem('izzaUserU', u); }catch(_){}
        try{ if(!localStorage.getItem('piAuthUser')) localStorage.setItem('piAuthUser', JSON.stringify({ username:u })); }catch(_){}
      }
    }catch(_){}
  })();
  </script>
  <script src="/static/game/js/izza-persist.js"></script>

  <link rel="stylesheet" href="/static/themes.css">
  <style>
    :root{
      --hud:rgba(0,0,0,.55); --hudLine:rgba(255,255,255,.18);
      --ok:#72ff9d; --warn:#ffd36b; --bad:#ff6b6b; --arcade:#ffed8a;
      --safe-t: env(safe-area-inset-top, 0px);
      --safe-b: env(safe-area-inset-bottom, 0px);
      /* these are computed by JS to guarantee 7 cols fit */
      --cardW: 86px;
      --cardH: calc(var(--cardW) * 1.45);
      --fanY:  calc(var(--cardH) * 0.26);
      --gutter: 10px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:#0b0f1a;color:var(--txt);font-family:Arial,Helvetica,sans-serif}

    .wrap{max-width:1100px;margin:0 auto;padding:12px}
    .top{display:flex;justify-content:space-between;align-items:center;gap:8px;margin:6px 0 10px}
    .btn{display:inline-flex;align-items:center;gap:8px;border:1px solid var(--line);
         background:var(--chip-bg);padding:9px 14px;border-radius:12px;color:inherit;text-decoration:none;line-height:1.1}
    .btn:hover{filter:brightness(1.06)}
    .btn.small{padding:6px 10px;border-radius:10px;font-size:13px}

    /* Arena fills the screen and respects the notch/home indicator */
    .arena{
      position:relative;
      height:calc(100vh - 110px - var(--safe-b));
      min-height:520px;
      border:1px solid var(--line); border-radius:14px; background:#042b1d;
      overflow:hidden;
    }
    @media (max-width:640px){
      .arena{ height:calc(100vh - 96px - var(--safe-b)); min-height:520px; }
    }

    /* HUD â€” wraps nicely on small screens */
    .hud{position:absolute;left:10px;right:10px;top:calc(8px + var(--safe-t));z-index:9;display:flex;flex-wrap:wrap;gap:8px 8px;align-items:center}
    .hud .left,.hud .right{display:flex;gap:8px;align-items:center;min-width:0;flex-wrap:wrap}
    .hud .left{flex:1 1 260px} .hud .right{flex:1 1 200px;justify-content:flex-end}
    .pill{background:var(--hud);border:1px solid var(--hudLine);backdrop-filter:blur(6px);
          padding:6px 10px;border-radius:999px;font-size:12px;font-weight:800;letter-spacing:.2px;
          display:inline-flex;gap:6px;align-items:center;white-space:nowrap}
    .pill strong{font-variant-numeric:tabular-nums}

    /* Board area under HUD, scrolls if extremely small screens */
    .board{
      position:absolute; inset:64px 12px 12px 12px;
      display:grid; gap:var(--gutter);
      grid-template-rows:auto 1fr; /* top row, then tableau */
      overflow:auto; padding-bottom:calc(10px + var(--safe-b));
      border-radius:12px; background:#0e5b3f;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);
    }
    .row{display:grid;grid-template-columns:repeat(7, minmax(0,1fr));gap:var(--gutter)}
    .row .cell{
      background:rgba(255,255,255,.04);border:1px dashed rgba(255,255,255,.18);
      border-radius:12px;min-height:var(--cardH);display:flex;align-items:flex-start;justify-content:flex-start;
      position:relative; overflow:hidden;
    }
    .row .cell.stack{min-height:calc(var(--cardH) + var(--fanY) * 6)}
    .row .cell.foundation{background:rgba(255,255,255,.03)}
    .row .cell > span{
      position:absolute; left:10px; top:8px; color:#9bd7b2; font-size:12px; pointer-events:none
    }
    .pile{position:relative;width:100%;height:100%}

    /* Cards: clean indexes and no bleed past rounded corners */
    .card{
      position:absolute; width:var(--cardW); height:var(--cardH);
      border-radius:12px; background:#fff; border:1px solid rgba(0,0,0,.14);
      box-shadow:0 4px 12px rgba(0,0,0,.28); user-select:none; touch-action:none;
      overflow:hidden; /* ðŸ”’ stops pip text from leaking off edges */
    }
    .card.back{
      background:linear-gradient(180deg,#184a86,#0f2c54);
      border-color:rgba(0,0,0,.28);
    }
    .pip{position:absolute; font-weight:900; line-height:1; font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial}
    .pip.tl{left:8px; top:6px}
    .pip.br{right:8px; bottom:6px; transform:rotate(180deg)}
    .pip .rank{display:block; font-size:calc(var(--cardW) * 0.23)}
    .pip .suit{display:block; font-size:calc(var(--cardW) * 0.20); margin-top:2px}
    .centerSuit{position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
      font-size:calc(var(--cardW) * 0.45); opacity:.16}
    .red{color:#c31e2e} .black{color:#111}

    /* tableau fanning handled by translateY */
    .pile.tableau .card{will-change:transform}

    .ghost{opacity:.85; outline:2px dashed rgba(0,0,0,.25)}

    /* Messages / overlays */
    .bigmsg{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:8;
      font-size:40px;font-weight:900;letter-spacing:.5px;color:var(--arcade);text-shadow:0 10px 32px rgba(0,0,0,.45);opacity:0;transition:opacity .18s,transform .18s}
    .bigmsg.show{opacity:1;transform:translate(-50%,-56%) scale(1.04)}
    .endOverlay,.rulesOverlay{position:fixed;inset:0;display:none;z-index:9999;align-items:center;justify-content:center;background:rgba(0,0,0,.45)}
    .endOverlay.show,.rulesOverlay.show{display:flex}
    .cardPanel{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:16px;max-width:92vw}

    .finish{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
  </style>
</head>
<body class="cw-blue theme-a">
  <div class="wrap">
    <div class="top">
      <a class="btn" id="endBtn" href="#">End Game</a>
      <div class="right" style="display:flex;gap:8px;align-items:center">
        <button id="rulesBtn" class="btn small" type="button">Rules</button>
        <a class="btn" id="backBtn" href="/izza-game/minigames">Return to Arcade</a>
      </div>
    </div>

    <div class="arena" id="arena">
      <!-- HUD -->
      <div class="hud">
        <div class="left">
          <span class="pill">TIME: <strong id="time">00:00</strong></span>
          <span class="pill">MOVES: <strong id="moves">0</strong></span>
        </div>
        <div class="right">
          <span class="pill">COINS: <strong id="coinsHUD">0</strong></span>
          <span class="pill">CRAFT: <strong id="craftHUD">0</strong></span>
        </div>
      </div>

      <div id="board" class="board" aria-label="Solitaire board">
        <!-- Row 1: stock + waste + 4 foundations -->
        <div class="row" id="rowTop">
          <div class="cell"><div class="pile" id="stock"></div><span>STOCK</span></div>
          <div class="cell"><div class="pile" id="waste"></div><span>WASTE</span></div>
          <div class="cell foundation"><div class="pile" id="f1"></div><span>â™  FOUNDATION</span></div>
          <div class="cell foundation"><div class="pile" id="f2"></div><span>â™¥ FOUNDATION</span></div>
          <div class="cell foundation"><div class="pile" id="f3"></div><span>â™£ FOUNDATION</span></div>
          <div class="cell foundation"><div class="pile" id="f4"></div><span>â™¦ FOUNDATION</span></div>
          <div class="cell"></div>
        </div>

        <!-- Row 2: seven tableau columns -->
        <div class="row" id="rowBottom">
          <div class="cell stack"><div class="pile tableau" id="t1"></div></div>
          <div class="cell stack"><div class="pile tableau" id="t2"></div></div>
          <div class="cell stack"><div class="pile tableau" id="t3"></div></div>
          <div class="cell stack"><div class="pile tableau" id="t4"></div></div>
          <div class="cell stack"><div class="pile tableau" id="t5"></div></div>
          <div class="cell stack"><div class="pile tableau" id="t6"></div></div>
          <div class="cell stack"><div class="pile tableau" id="t7"></div></div>
        </div>
      </div>

      <div id="bigmsg" class="bigmsg">GO!</div>

      <!-- Rules -->
      <div id="rules" class="rulesOverlay" aria-hidden="true">
        <div class="cardPanel" style="max-width:680px">
          <h3 style="margin:0 0 8px">How to play Solitaire (Klondike)</h3>
          <ol style="margin:8px 0 0; padding-left:18px; line-height:1.45">
            <li>Build down in alternating colors on the 7 tableau columns (e.g., red 9 on black 10).</li>
            <li>Only a King (K) may be moved to an empty tableau column.</li>
            <li>Foundations build up by suit from Ace â†’ King.</li>
            <li>Tap the STOCK to flip cards to the WASTE (draw 1).</li>
            <li>Drag a face-up run (e.g., 7â™£-6â™¦-5â™£) as a group.</li>
            <li>Win by moving all cards to the four foundations.</li>
          </ol>
          <div class="finish">
            <button class="btn" id="rulesClose">Close</button>
          </div>
        </div>
      </div>

      <!-- End overlay -->
      <div id="end" class="endOverlay" aria-hidden="true">
        <div class="cardPanel">
          <h3 style="margin:0 0 6px">Game Over</h3>
          <div class="finish">
            <span class="pill">Result: <strong id="resText">â€”</strong></span>
            <span class="pill">Time: <strong id="resTime">00:00</strong></span>
            <span class="pill">Moves: <strong id="resMoves">0</strong></span>
            <span class="pill">Coins: <strong id="resCoins">0</strong></span>
            <span class="pill">Craft: <strong id="resCraft">0</strong></span>
          </div>
          <div class="finish" style="margin-top:10px">
            <a class="btn" id="againBtn" href="#">Play Again</a>
            <a class="btn" id="backBtn2" href="/izza-game/minigames">Return to Arcade</a>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
/* =======================
   Auth / withAuth like Arena
======================= */
(function(){
  const T_KEY='izzaTokenT', U_KEY='izzaUserU';
  const qs=new URLSearchParams(location.search);
  let T=qs.get('t')||''; let U=(qs.get('u')||'').toString().trim();
  try{
    if(T) localStorage.setItem(T_KEY,T);
    else{ const s=localStorage.getItem(T_KEY)||''; if(s){ const u=new URL(location.href); u.searchParams.set('t',s); history.replaceState(null,'',u.toString()); T=s; } }
  }catch(_){}
  function publishU(u){ if(!u) return u; u=u.replace(/^@+/,'').toLowerCase();
    try{ localStorage.setItem(U_KEY,u); }catch(_){}
    window.__IZZA_PROFILE__=Object.assign({},window.__IZZA_PROFILE__,{username:u});
    window.izzaUserKey={get:()=>u};
    try{ if(!localStorage.getItem('piAuthUser')) localStorage.setItem('piAuthUser', JSON.stringify({ username:u })); }catch(_){}
    return u;
  }
  try{
    if(U) publishU(U); else{
      const su=(localStorage.getItem(U_KEY)||'').toString().trim();
      if(su){ const u=new URL(location.href); u.searchParams.set('u',su); history.replaceState(null,'',u.toString()); U=publishU(su); }
    }
  }catch(_){}
  function withAuth(h){ const u=new URL(h, location.origin); if(T) u.searchParams.set('t',T); if(U) u.searchParams.set('u',U); return u.pathname+(u.search?u.search:''); }
  document.querySelectorAll('#backBtn,#backBtn2').forEach(a=>a.href = withAuth(a.getAttribute('href')));
  window._withAuth = withAuth;
})();

/* =======================
   Wallet helpers (Persist-synced)
======================= */
(function(){
  const CRAFT_KEYS=['izzaCrafting','craftingCredits','izzaCraftCredits'];
  const toInt=v=>{const n=parseInt(v,10);return Number.isFinite(n)?n:0;};
  function readCraftAny(){
    try{ if(window.IZZA_PERSIST?.get){ const p=IZZA_PERSIST.get('craftingCredits') ?? IZZA_PERSIST.get('izzaCrafting'); if(p!=null) return toInt(p);} }catch(_){}
    for(const k of CRAFT_KEYS){ const v=toInt(localStorage.getItem(k)||'0'); if(v>0) return v|0; }
    return toInt(localStorage.getItem(CRAFT_KEYS[0])||'0')|0;
  }
  function writeCraftAll(v){
    const n=Math.max(0,v|0);
    for(const k of CRAFT_KEYS) localStorage.setItem(k,String(n));
    try{ window.IZZA_PERSIST?.set?.('craftingCredits', n); }catch(_){}
    try{window.dispatchEvent(new Event('izza-crafting-changed'));}catch(_){}
    saveSoon();
  }
  function readCoins(){
    try{
      if(window.IZZA_PERSIST?.get){
        const c = IZZA_PERSIST.get('coins') ?? IZZA_PERSIST.get('izzaCoins') ?? IZZA_PERSIST.state?.coins;
        if(c!=null) return toInt(c);
      }
    }catch(_){}
    const z=localStorage.getItem('izzaWallet');
    if(z){ try{ const w=JSON.parse(z); if(w&&w.coins!=null) return toInt(w.coins);}catch(_){} }
    return toInt(localStorage.getItem('izzaCoins')||'0');
  }
  function writeCoins(v){
    const n=v|0; localStorage.setItem('izzaCoins', String(n));
    try{
      const w={coins:n, updatedAt:Date.now(), u:(window.izzaUserKey&&izzaUserKey.get&&izzaUserKey.get())||null};
      localStorage.setItem('izzaWallet', JSON.stringify(w));
    }catch(_){}
    try{ window.IZZA_PERSIST?.set?.('coins', n); }catch(_){}
    try{ window.dispatchEvent(new Event('izza-coins-changed')); }catch(_){}
    saveSoon();
  }
  async function syncFromPersist(){
    try{
      if(window.IZZA_PERSIST?.load) await IZZA_PERSIST.load();
      const c=readCoins(); localStorage.setItem('izzaCoins', String(c));
      const craft=readCraftAny(); CRAFT_KEYS.forEach(k=>localStorage.setItem(k,String(craft)));
    }catch(_){}
  }
  let saveTimer=null;
  function saveSoon(){ try{ if(saveTimer) clearTimeout(saveTimer); saveTimer=setTimeout(async()=>{ try{ await IZZA_PERSIST?.save?.(); }catch(_){} },120);}catch(_){} }

  window._wallet = { readCraftAny, writeCraftAll, readCoins, writeCoins, syncFromPersist, saveSoon };
})();

/* =======================
   Responsive card sizing: fit 7 cols exactly
======================= */
function sizeBoard(){
  const board = document.querySelector('.board');
  if (!board) return;
  const r = board.getBoundingClientRect();
  const cols = 7;
  const minW = 56;   // absolute floor
  const maxW = 96;   // pleasant cap
  const gutter = 10;
  let w = Math.floor((r.width - gutter * (cols - 1)) / cols);
  w = Math.max(minW, Math.min(maxW, w));
  document.documentElement.style.setProperty('--cardW', w + 'px');
  const h = Math.round(w * 1.45);
  const fan = Math.max(18, Math.min(Math.round(h * 0.28), 38));
  document.documentElement.style.setProperty('--cardH', h + 'px');
  document.documentElement.style.setProperty('--fanY', fan + 'px');
}
window.addEventListener('resize', sizeBoard, { passive:true });
window.addEventListener('orientationchange', sizeBoard, { passive:true });

/* =======================
   UI refs / HUD paint
======================= */
const elCoins=document.getElementById('coinsHUD');
const elCraft=document.getElementById('craftHUD');
const elTime=document.getElementById('time');
const elMoves=document.getElementById('moves');
function paintWallet(){ elCoins.textContent=String(_wallet.readCoins()); elCraft.textContent=String(_wallet.readCraftAny()); }
window.addEventListener('izza-coins-changed', paintWallet, {passive:true});
window.addEventListener('izza-crafting-changed', paintWallet, {passive:true});

/* =======================
   Solitaire core (draw-1 Klondike)
======================= */
const SUITS = ['â™ ','â™¥','â™£','â™¦'];
const COLORS = { 'â™ ':'black', 'â™£':'black', 'â™¥':'red', 'â™¦':'red' };
const RANKS = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];

function makeDeck(){
  const d=[];
  for(const s of SUITS){
    for(let i=0;i<RANKS.length;i++){
      d.push({ id:s+RANKS[i], suit:s, rank:i+1, face:false, color:COLORS[s] });
    }
  }
  for(let i=d.length-1;i>0;i--){ const j=(Math.random()* (i+1))|0; const t=d[i]; d[i]=d[j]; d[j]=t; }
  return d;
}

const P = { stock:[], waste:[], f:[[],[],[],[]], t:[[],[],[],[],[],[],[]] };
let dragSel=null, startTs=null, timerId=null, moves=0, ended=false, winTs=null;
let FAN=26; // will update from CSS var

function cssVarInt(name, fallback){ const v=getComputedStyle(document.documentElement).getPropertyValue(name).trim(); const n=parseInt(v,10); return Number.isFinite(n)?n:fallback; }
function fmtTime(ms){ const s=Math.max(0,Math.floor(ms/1000)); const m=(s/60)|0; const ss=String(s%60).padStart(2,'0'); return `${String(m).padStart(2,'0')}:${ss}`; }

function layoutNew(){
  // reset
  for(let i=0;i<4;i++) P.f[i]=[];
  for(let i=0;i<7;i++) P.t[i]=[];
  P.waste=[]; P.stock=makeDeck();
  moves=0; ended=false; winTs=null;
  elMoves.textContent='0';

  // update FAN from CSS
  FAN = cssVarInt('--fanY', 26);

  // deal tableau (1..7), flip top of each
  for(let col=0; col<7; col++){
    for(let n=0; n<=col; n++){
      const c=P.stock.pop(); P.t[col].push(c);
      c.face = (n===col);
    }
  }
  // remaining stay face-down in stock
  P.stock.forEach(c=>c.face=false);

  // start timer
  if(timerId) clearInterval(timerId);
  startTs=Date.now();
  elTime.textContent='00:00';
  timerId=setInterval(()=>{ if(!ended){ elTime.textContent = fmtTime(Date.now()-startTs); } }, 250);

  renderAll();
  showMsg('GO!');
  paintWallet();
}

function showMsg(t){ const m=document.getElementById('bigmsg'); m.textContent=t; m.classList.add('show'); setTimeout(()=>m.classList.remove('show'),850); }

function renderAll(){
  const piles={ stock:'stock', waste:'waste', t:['t1','t2','t3','t4','t5','t6','t7'], f:['f1','f2','f3','f4'] };
  // clear
  [...document.querySelectorAll('.pile')].forEach(p=>p.innerHTML='');

  // STOCK
  const sEl=document.getElementById(piles.stock);
  if(P.stock.length){
    const card=spawnCardBack();
    card.addEventListener('click', onDraw, {passive:true});
    sEl.appendChild(card);
  }
  // WASTE
  const wEl=document.getElementById(piles.waste);
  if(P.waste.length){
    const top=P.waste[P.waste.length-1]; top.face=true;
    const el=spawnCard(top); el.style.zIndex=10; placeStack(el,0);
    wEl.appendChild(el);
  }

  // FOUNDATIONS
  for(let i=0;i<4;i++){
    const fEl=document.getElementById(piles.f[i]);
    P.f[i].forEach((c,k)=>{ const el=spawnCard(c); el.style.zIndex=k+1; placeStack(el,k*12); fEl.appendChild(el); });
  }

  // TABLEAU
  for(let i=0;i<7;i++){
    const col=P.t[i], tEl=document.getElementById(piles.t[i]);
    col.forEach((c,k)=>{
      const el=spawnCard(c);
      el.style.zIndex=k+1;
      el.dataset.where='t'; el.dataset.col=String(i);
      placeStack(el,k*FAN);
      tEl.appendChild(el);
    });
    // tap empty column: allow King run
    tEl.parentElement.addEventListener('click', (e)=>{
      if(e.target.closest('.card')) return;
      if(!col.length){
        const sel = dragSel && dragSel.cards ? dragSel.cards : null;
        if(sel && sel[0] && +sel[0].dataset.rank===13){ moveRunToTableau(sel.map(cardFromDataset), i); }
      }
    }, {passive:true});
  }

  // enable drag on face-up
  enableDrag();
}

function spawnCardBack(){
  const el=document.createElement('div');
  el.className='card back';
  el.style.left='0'; el.style.top='0';
  return el;
}
function spawnCard(c){
  const el=document.createElement('div');
  el.className='card '+(c.face ? (c.color==='red'?'red':'black') : 'back');
  el.style.left='0'; el.style.top='0';
  el.dataset.id=c.id; el.dataset.rank=c.rank; el.dataset.suit=c.suit; el.dataset.color=c.color; el.dataset.face=String(!!c.face);

  if(c.face){
    // proper pip layout: TL + BR (rotated), faint center suit
    const tl=document.createElement('div'); tl.className='pip tl';
    tl.innerHTML=`<span class="rank">${RANKS[c.rank-1]}</span><span class="suit">${c.suit}</span>`;
    const br=document.createElement('div'); br.className='pip br';
    br.innerHTML=`<span class="rank">${RANKS[c.rank-1]}</span><span class="suit">${c.suit}</span>`;
    const mid=document.createElement('div'); mid.className='centerSuit'; mid.textContent=c.suit;
    el.appendChild(tl); el.appendChild(br); el.appendChild(mid);
  }
  return el;
}
function placeStack(el, y){ el.style.transform=`translateY(${y}px)`; }

/* ==== moves & rules ==== */
function onDraw(){
  if(!P.stock.length){
    while(P.waste.length){ const c=P.waste.pop(); c.face=false; P.stock.push(c); }
  }else{
    const c=P.stock.pop(); c.face=true; P.waste.push(c);
  }
  bumpMoves(); renderAll();
}

function bumpMoves(){ moves++; elMoves.textContent=String(moves); }

function cardFromDataset(el){
  return { id:el.dataset.id, suit:el.dataset.suit, rank:+el.dataset.rank, face:(el.dataset.face==='true'), color:el.dataset.color };
}
function canStackOn(a,b){ return b && a.face && b.face && a.color!==b.color && a.rank===b.rank-1; }
function canGoFoundation(c, idx){
  const f=P.f[idx]; if(!c.face) return false;
  if(!f.length) return c.rank===1;
  const top=f[f.length-1];
  return c.suit===top.suit && c.rank===top.rank+1;
}

/* ---- drag basics (runs allowed) ---- */
function enableDrag(){
  document.querySelectorAll('.card').forEach(el=>{
    if(el.classList.contains('back')) return;
    el.style.touchAction='none';
    el.onpointerdown = (e)=>{
      if(ended) return;
      const srcEl = e.currentTarget;
      const where = srcEl.dataset.where || inferWhere(srcEl);
      const run = collectRunFromElement(srcEl, where);
      if(!run.cards.length) return;

      dragSel={ cards: run.cards, from: run.from, col: run.col, dy: e.clientY, dx:e.clientX };
      run.cards.forEach((cEl,i)=>{ cEl.classList.add('ghost'); cEl.style.zIndex=100+i; document.body.appendChild(cEl); followPointer(cEl, e); });
      window.addEventListener('pointermove', onDragMove, {passive:false});
      window.addEventListener('pointerup', onDragEnd, {once:true, passive:false});
      e.preventDefault();
    };
  });
}

function inferWhere(el){
  const p = el.closest('.pile');
  if(!p) return '';
  const id=p.id;
  if(id==='waste') return 'w';
  if(id[0]==='t') return 't';
  if(id[0]==='f') return 'f';
  return '';
}
function collectRunFromElement(el, where){
  if(where==='w'){
    const top=P.waste[P.waste.length-1]; if(!top || top.id!==el.dataset.id) return {cards:[],from:'w'};
    return { cards:[el], from:'w' };
  }
  if(where==='f'){
    return { cards:[], from:'f' }; // no pulling from foundations
  }
  if(where==='t'){
    const col=+el.dataset.col; const pile=P.t[col];
    const idx = pile.findIndex(c=>c.id===el.dataset.id);
    const take = [];
    for(let i=idx;i<pile.length;i++){
      const c = pile[i];
      if(!c.face){ return {cards:[],from:'t',col}; }
      const el2 = findCardEl(c.id); if(el2) take.push(el2);
    }
    return { cards:take, from:'t', col };
  }
  return {cards:[],from:''};
}
function findCardEl(id){ return [...document.querySelectorAll('.card')].find(n=>n.dataset.id===id); }
function followPointer(el, e){ el.style.position='fixed'; el.style.left=(e.clientX- el.offsetWidth/2)+'px'; el.style.top=(e.clientY- el.offsetHeight/2)+'px'; }
function onDragMove(e){ if(!dragSel) return; dragSel.cards.forEach(el=>followPointer(el,e)); e.preventDefault(); }

function hitPileId(e){
  const el=document.elementFromPoint(e.clientX, e.clientY);
  const pile = el && (el.closest('.pile') || (el.classList?.contains('pile')?el:null));
  return pile ? pile.id : '';
}
function onDragEnd(e){
  window.removeEventListener('pointermove', onDragMove);
  const target=hitPileId(e);
  let placed=false;

  if(target.startsWith('t')){ // to tableau
    const tIdx = +target.slice(1)-1;
    placed = tryPlaceToTableau(dragSel.cards.map(cardFromDataset), tIdx);
  }else if(target.startsWith('f') && dragSel.cards.length===1){ // to foundation
    const fIdx = +target.slice(1)-1;
    placed = tryPlaceToFoundation(cardFromDataset(dragSel.cards[0]), fIdx);
  }

  dragSel.cards.forEach(el=>el.classList.remove('ghost'));
  dragSel=null;
  renderAll();
  if(placed){ bumpMoves(); flipIfNeeded(); checkWin(); }
}

function moveRunToTableau(cards, destIdx){
  if(!cards || !cards.length) return false;
  const ok = acceptOnTableau(cards, destIdx);
  if(ok){ takeFromSource(cards[0].id); cards.forEach(c=>P.t[destIdx].push(c)); bumpMoves(); renderAll(); flipIfNeeded(); checkWin(); }
  return ok;
}
function tryPlaceToTableau(cards, destIdx){
  if(!cards.length) return false;
  const ok= acceptOnTableau(cards, destIdx);
  if(ok){ takeFromSource(cards[0].id); cards.forEach(c=>P.t[destIdx].push(c)); return true; }
  return false;
}
function acceptOnTableau(cards, destIdx){
  const dest=P.t[destIdx];
  const head = cards[0];
  // entire run must be descending + alternating
  for(let i=0;i<cards.length-1;i++){
    const a=cards[i], b=cards[i+1];
    if(!(a.face && b.face && a.rank===b.rank+1 && a.color!==b.color)) return false;
  }
  if(!dest.length) return head.rank===13; // K to empty
  const top=dest[dest.length-1];
  return head.color!==top.color && head.rank===top.rank-1;
}

function tryPlaceToFoundation(card, fIdx){
  if(!card.face) return false;
  if(canGoFoundation(card,fIdx)){
    takeFromSource(card.id);
    P.f[fIdx].push(card);
    return true;
  }
  return false;
}
function takeFromSource(id){
  // from waste?
  if(P.waste.length && P.waste[P.waste.length-1].id===id){ P.waste.pop(); return; }
  // from tableau run head
  for(let i=0;i<7;i++){
    const pile=P.t[i];
    const idx=pile.findIndex(c=>c.id===id);
    if(idx>=0){ pile.splice(idx); return; }
  }
}
function flipIfNeeded(){
  for(let i=0;i<7;i++){
    const pile=P.t[i];
    if(pile.length && !pile[pile.length-1].face){ pile[pile.length-1].face=true; }
  }
}
/* Win if all foundations have 13 */
function checkWin(){
  if(P.f.every(f=>f.length===13)){
    winTs = Date.now();
    endGame(true);
  }
}

/* =======================
   Rewards & Leaderboard (WIN ONLY)
======================= */
const COINS_ON_WIN = 1000;
const CRAFT_ON_WIN = 1;
/* IMPORTANT: use Target Range id for LB (per Arena/Persist mapping) */
const LB_GAME_ID = 'targets';

/* Rank by speed (faster is better). Convert to a high score:
   score = (1h - elapsedMs) * 1000 + (1000 - min(1000,moves))
*/
function makeLeaderboardScore(elapsedMs, moves){
  const base = 3600000 - Math.max(0,elapsedMs|0);
  const tie  = Math.max(0, 1000 - Math.min(1000,moves|0));
  return (base*1000 + tie)|0;
}
async function submitLeaderboard(score){
  try{
    if(window.IZZA_LEADERBOARD && typeof IZZA_LEADERBOARD.submit==='function'){
      await IZZA_LEADERBOARD.submit({ game:LB_GAME_ID, score: score|0 });
    }else{
      await fetch(_withAuth('/izza-game/api/leaderboard/submit'),{
        method:'POST',credentials:'include',
        headers:{'content-type':'application/json'},
        body:JSON.stringify({ game:LB_GAME_ID, score: score|0 })
      }).catch(()=>{});
    }
    // Cache locally for snapshot/Arena modal
    const u=(window.izzaUserKey&&izzaUserKey.get&&izzaUserKey.get())||'guest';
    const row={u, s:score|0, ts:Date.now()};
    const z=n=>String(n).padStart(2,'0'); const d=new Date();
    const stamps={ day:`${d.getFullYear()}-${z(d.getMonth()+1)}-${z(d.getDate())}`, month:`${d.getFullYear()}-${z(d.getMonth()+1)}`, year:String(d.getFullYear()) };
    function upsertHigh(key, r){
      try{
        const arr=JSON.parse(localStorage.getItem(key)||'[]');
        let found=false;
        for(let i=0;i<arr.length;i++){
          if(arr[i] && arr[i].u===r.u){ found=true; if((arr[i].s|0) < (r.s|0)) arr[i]=r; break; }
        }
        if(!found) arr.push(r);
        arr.sort((a,b)=>b.s-a.s);
        localStorage.setItem(key, JSON.stringify(arr.slice(0,20)));
      }catch(_){}
    }
    upsertHigh(`izzaLb2::${LB_GAME_ID}::alltime`, row);
    upsertHigh(`izzaLb2::${LB_GAME_ID}::day::${stamps.day}`, row);
    upsertHigh(`izzaLb2::${LB_GAME_ID}::month::${stamps.month}`, row);
    upsertHigh(`izzaLb2::${LB_GAME_ID}::year::${stamps.year}`, row);
  }catch(_){}
}

/* =======================
   End / overlay / controls
======================= */
const endEl=document.getElementById('end');
const resText=document.getElementById('resText');
const resTime=document.getElementById('resTime');
const resMoves=document.getElementById('resMoves');
const resCoins=document.getElementById('resCoins');
const resCraft=document.getElementById('resCraft');

function endGame(won){
  if(ended) return;
  ended=true;
  if(timerId) clearInterval(timerId);
  const elapsed = (won ? (winTs||Date.now()) : Date.now()) - (startTs||Date.now());
  const coinsStart=_wallet.readCoins();
  let coinsDelta=0, craftDelta=0;

  if(won){
    coinsDelta=COINS_ON_WIN; craftDelta=CRAFT_ON_WIN;
    _wallet.writeCoins(coinsStart + coinsDelta);
    _wallet.writeCraftAll(_wallet.readCraftAny() + craftDelta);
    _wallet.saveSoon();

    // leaderboard submit (time-based rank)
    const score = makeLeaderboardScore(elapsed, moves);
    submitLeaderboard(score);
  }

  resText.textContent = won ? 'WIN' : 'Game Ended';
  resTime.textContent = fmtTime(elapsed);
  resMoves.textContent = String(moves);
  resCoins.textContent = String(coinsDelta);
  resCraft.textContent = String(craftDelta);
  paintWallet();

  endEl.classList.add('show');
}

document.getElementById('endBtn').addEventListener('click', (e)=>{ e.preventDefault(); endGame(false); }, {passive:false});
document.getElementById('againBtn').addEventListener('click', (e)=>{ e.preventDefault(); endEl.classList.remove('show'); layoutNew(); }, {passive:false});

/* Rules toggle */
const rulesEl=document.getElementById('rules');
document.getElementById('rulesBtn').addEventListener('click', ()=>rulesEl.classList.add('show'), {passive:true});
document.getElementById('rulesClose').addEventListener('click', ()=>rulesEl.classList.remove('show'), {passive:true});
rulesEl.addEventListener('click', (e)=>{ if(e.target===rulesEl) rulesEl.classList.remove('show'); }, {passive:true});

/* Back to Arcade: try a save first so totals are fresh */
document.querySelectorAll('#backBtn,#backBtn2').forEach(a=>{
  a.addEventListener('click', async (e)=>{
    e.preventDefault();
    try{ await _wallet.syncFromPersist(); await IZZA_PERSIST?.save?.(); }catch(_){}
    location.href = a.href;
  }, {passive:false});
});

/* =======================
   Boot
======================= */
(async function(){
  try{ await _wallet.syncFromPersist(); }catch(_){}
  sizeBoard();           // compute card size
  paintWallet();
  layoutNew();
})();
</script>
</body>
</html>
<!-- build: 2025-10-06 -->
