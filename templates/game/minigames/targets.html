<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>IZZA SOLITAIRE — IZZA GAME</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no">
  <script>window.IZZA_PERSIST_BASE='https://izzagame.onrender.com';</script>

  <!-- Publish username before persist loads -->
  <script>
  (function(){
    try{
      const q=new URLSearchParams(location.search);
      let u=(q.get('u')||localStorage.getItem('izzaUserU')||'').toString().trim();
      if(!u){
        const raw=localStorage.getItem('piAuthUser');
        if(raw){ try{ u=(JSON.parse(raw)||{}).username||''; }catch{} }
      }
      if(u){
        u=u.replace(/^@+/, '').toLowerCase();
        window.__IZZA_PROFILE__=Object.assign({},window.__IZZA_PROFILE__,{username:u});
        window.izzaUserKey={ get:()=>u };
        try{ localStorage.setItem('izzaUserU', u); }catch(_){}
        try{ if(!localStorage.getItem('piAuthUser')) localStorage.setItem('piAuthUser', JSON.stringify({ username:u })); }catch(_){}
      }
    }catch(_){}
  })();
  </script>
  <script src="/static/game/js/izza-persist.js"></script>

  <link rel="stylesheet" href="/static/themes.css">
  <style>
    :root{
      --hud:rgba(0,0,0,.55); --hudLine:rgba(255,255,255,.18);
      --ok:#72ff9d; --warn:#ffd36b; --bad:#ff6b6b; --arcade:#ffed8a;
      --safe-t: env(safe-area-inset-top, 0px);
      --safe-b: env(safe-area-inset-bottom, 0px);
      --cardW: 86px;
      --cardH: calc(var(--cardW) * 1.45);
      --fanY:  calc(var(--cardH) * 0.26);
      --gutter: 10px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:#0b0f1a;color:var(--txt);font-family:Arial,Helvetica,sans-serif}

    .wrap{max-width:1100px;margin:0 auto;padding:12px}
    .top{display:flex;justify-content:space-between;align-items:center;gap:8px;margin:6px 0 10px}
    .btn{display:inline-flex;align-items:center;gap:8px;border:1px solid var(--line);
         background:var(--chip-bg);padding:9px 14px;border-radius:12px;color:inherit;text-decoration:none;line-height:1.1}
    .btn:hover{filter:brightness(1.06)}
    .btn.small{padding:6px 10px;border-radius:10px;font-size:13px}

    .arena{
      position:relative;
      height:calc(100vh - 110px - var(--safe-b));
      min-height:520px;
      border:1px solid var(--line); border-radius:14px; background:#042b1d;
      overflow:hidden;
    }
    @media (max-width:640px){
      .arena{ height:calc(100vh - 96px - var(--safe-b)); min-height:520px; }
    }

    /* HUD — no draw control here (moved to start screen) */
    .hud{position:absolute;left:10px;right:10px;top:calc(8px + var(--safe-t));z-index:9;display:flex;gap:8px;align-items:center;justify-content:space-between;flex-wrap:nowrap}
    .hud .left,.hud .right{display:flex;gap:8px;align-items:center;min-width:0}
    .pill{background:var(--hud);border:1px solid var(--hudLine);backdrop-filter:blur(6px);
          padding:4px 8px;border-radius:999px;font-size:11px;font-weight:800;letter-spacing:.2px;
          display:inline-flex;gap:6px;align-items:center;white-space:nowrap}
    .pill strong{font-variant-numeric:tabular-nums}
    @media (max-width:420px){
      .pill{font-size:10px;padding:3px 7px}
    }

    /* Board area */
    .board{
      position:absolute; inset:60px 10px 10px 10px;
      display:grid; gap:var(--gutter);
      grid-template-rows:auto 1fr;
      overflow:auto; padding-bottom:calc(10px + var(--safe-b));
      border-radius:12px; background:#0e5b3f;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);
    }
    .row{display:grid;grid-template-columns:repeat(7, minmax(0,1fr));gap:var(--gutter)}
    .row .cell{
      background:rgba(255,255,255,.04);border:1px dashed rgba(255,255,255,.18);
      border-radius:12px;min-height:var(--cardH);display:flex;align-items:flex-start;justify-content:flex-start;
      position:relative; overflow:hidden;
    }
    .row .cell.stack{min-height:calc(var(--cardH) + var(--fanY) * 6)}
    .row .cell.foundation{background:rgba(255,255,255,.03)}
    .row .cell > span{
      position:absolute; left:8px; top:6px; color:#9bd7b2; font-size:10px; pointer-events:none;
      letter-spacing:.5px
    }
    .row .cell.foundation > span{opacity:.85}
    .pile{position:relative;width:100%;height:100%}

    /* Cards */
    .card{
      position:absolute; width:var(--cardW); height:var(--cardH);
      border-radius:12px; background:#fff; border:1px solid rgba(0,0,0,.14);
      box-shadow:0 4px 12px rgba(0,0,0,.28); user-select:none; touch-action:none;
      overflow:hidden;
    }
    .card.back{
      background:linear-gradient(180deg,#184a86,#0f2c54);
      border-color:rgba(0,0,0,.28);
    }
    .pip{position:absolute; font-weight:900; line-height:1; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
    .pip.tl{left:8px; top:6px}
    .pip.br{right:8px; bottom:6px; transform:rotate(180deg)}
    .pip .rank{display:block; font-size:calc(var(--cardW) * 0.23)}
    .pip .suit{display:block; font-size:calc(var(--cardW) * 0.20); margin-top:2px}
    .centerSuit{position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
      font-size:calc(var(--cardW) * 0.45); opacity:.16}
    .red{color:#c31e2e} .black{color:#111}

    .being-dragged{visibility:hidden}
    #dragLayer{position:fixed;left:0;top:0;right:0;bottom:0;pointer-events:none;z-index:9998}

    .bigmsg{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:8;
      font-size:40px;font-weight:900;letter-spacing:.5px;color:var(--arcade);text-shadow:0 10px 32px rgba(0,0,0,.45);opacity:0;transition:opacity .18s,transform .18s}
    .bigmsg.show{opacity:1;transform:translate(-50%,-56%) scale(1.04)}
    .endOverlay,.rulesOverlay,.startOverlay{position:fixed;inset:0;display:none;z-index:9999;align-items:center;justify-content:center;background:rgba(0,0,0,.45)}
    .endOverlay.show,.rulesOverlay.show,.startOverlay.show{display:flex}
    .cardPanel{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:16px;max-width:92vw}
    .finish{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}

    /* Start screen */
    .startOverlay{background:rgba(0,0,0,.6)}
    .startOverlay::before{
      content:"";
      position:absolute; inset:0;
      background:url("/static/game/img/solitaire-start-bg.jpg") center/cover no-repeat;
      filter:brightness(.8);
    }
    .startSheet{
      position:relative; z-index:1; width:min(760px,92vw);
      background:var(--card); border:1px solid var(--line); border-radius:14px; padding:16px;
      box-shadow:0 20px 60px rgba(0,0,0,.5)
    }
    .drawSelect{display:flex; gap:8px; flex-wrap:wrap}
    .chip{
      display:inline-flex; align-items:center; gap:8px; padding:8px 12px; border-radius:999px;
      border:1px solid var(--line); background:var(--chip-bg); cursor:pointer; user-select:none
    }
    .chip input{appearance:none; width:14px; height:14px; border-radius:50%; border:1px solid var(--line); display:inline-block}
    .chip input:checked{background:#5bd68a}

    /* --- Surgical: widen the WASTE cell to two slots on the top row --- */
    #rowTop .cell.wasteWide{ grid-column: span 2; }
    /* make sure the WASTE area can visually hold a wider fan */
    #waste{ padding-right: 6px; }
  </style>
</head>
<body class="cw-blue theme-a">
  <div class="wrap">
    <div class="top">
      <a class="btn" id="endBtn" href="#">End Game</a>
      <div class="right" style="display:flex;gap:8px;align-items:center">
        <button id="rulesBtn" class="btn small" type="button">Rules</button>
        <a class="btn" id="backBtn" href="/izza-game/minigames">Return to Arcade</a>
      </div>
    </div>

    <div class="arena" id="arena">
      <!-- HUD -->
      <div class="hud">
        <div class="left">
          <span class="pill">TIME: <strong id="time">00:00</strong></span>
          <span class="pill">MOVES: <strong id="moves">0</strong></span>
        </div>
        <div class="right">
          <span class="pill">COINS: <strong id="coinsHUD">0</strong></span>
          <span class="pill">CRAFT: <strong id="craftHUD">0</strong></span>
        </div>
      </div>

      <div id="board" class="board" aria-label="Solitaire board">
        <!-- Row 1: stock + waste(2 cols) + 4 foundations -->
        <div class="row" id="rowTop">
          <div class="cell"><div class="pile" id="stock"></div><span>STOCK</span></div>
          <div class="cell wasteWide"><div class="pile" id="waste"></div><span>WASTE</span></div>
          <div class="cell foundation"><div class="pile" id="f1"></div><span>♠ FOUND.</span></div>
          <div class="cell foundation"><div class="pile" id="f2"></div><span>♥ FOUND.</span></div>
          <div class="cell foundation"><div class="pile" id="f3"></div><span>♣ FOUND.</span></div>
          <div class="cell foundation"><div class="pile" id="f4"></div><span>♦ FOUND.</span></div>
          <!-- surgical: hide the previously unused extra slot to keep the grid on one row -->
          <div class="cell" style="display:none"></div>
        </div>

        <!-- Row 2: seven tableau columns -->
        <div class="row" id="rowBottom">
          <div class="cell stack"><div class="pile tableau" id="t1"></div></div>
          <div class="cell stack"><div class="pile tableau" id="t2"></div></div>
          <div class="cell stack"><div class="pile tableau" id="t3"></div></div>
          <div class="cell stack"><div class="pile tableau" id="t4"></div></div>
          <div class="cell stack"><div class="pile tableau" id="t5"></div></div>
          <div class="cell stack"><div class="pile tableau" id="t6"></div></div>
          <div class="cell stack"><div class="pile tableau" id="t7"></div></div>
        </div>
      </div>

      <div id="bigmsg" class="bigmsg">GO!</div>

      <!-- Start Screen -->
      <div id="start" class="startOverlay show" aria-hidden="false">
        <div class="startSheet">
          <h2 style="margin:0 0 6px">IZZA Solitaire — Klondike</h2>
          <p class="muted" style="margin:0 0 10px">Choose your deal and start. You can view the rules any time.</p>
          <div class="drawSelect" style="margin:8px 0 2px">
            <span class="pill">Deal:</span>
            <label class="chip"><input type="radio" name="draw" value="1"> Draw-1</label>
            <label class="chip"><input type="radio" name="draw" value="3"> Draw-3</label>
          </div>
          <div class="finish">
            <button id="startPlay" class="btn">Start</button>
            <button id="startRules" class="btn">Rules</button>
            <a class="btn" id="startBack" href="/izza-game/minigames">Return to Arcade</a>
          </div>
          <p class="muted" style="margin:10px 0 0; font-size:12px">
            Tap a top card to auto-send it to its foundation when allowed, or drag as usual.
          </p>
        </div>
      </div>

      <!-- Rules -->
      <div id="rules" class="rulesOverlay" aria-hidden="true">
        <div class="cardPanel" style="max-width:680px">
          <h3 style="margin:0 0 8px">How to play Solitaire (Klondike)</h3>
          <ol style="margin:8px 0 0; padding-left:18px; line-height:1.45">
            <li>Build down in alternating colors on the 7 tableau columns.</li>
            <li>Only a King (K) may be moved to an empty tableau column.</li>
            <li>Foundations build up by suit from Ace → King.</li>
            <li>Tap the STOCK to flip to the WASTE (draw-1 or draw-3 from Start screen).</li>
            <li>When STOCK is empty and no tableau cards are face-down, auto-play sends everything up.</li>
          </ol>
          <div class="finish">
            <button class="btn" id="rulesClose">Close</button>
          </div>
        </div>
      </div>

      <!-- End overlay -->
      <div id="end" class="endOverlay" aria-hidden="true">
        <div class="cardPanel">
          <h3 style="margin:0 0 6px">Game Over</h3>
          <div class="finish">
            <span class="pill">Result: <strong id="resText">—</strong></span>
            <span class="pill">Time: <strong id="resTime">00:00</strong></span>
            <span class="pill">Moves: <strong id="resMoves">0</strong></span>
            <span class="pill">Coins: <strong id="resCoins">0</strong></span>
            <span class="pill">Craft: <strong id="resCraft">0</strong></span>
          </div>
          <div class="finish" style="margin-top:10px">
            <a class="btn" id="againBtn" href="#">Play Again</a>
            <a class="btn" id="backBtn2" href="/izza-game/minigames">Return to Arcade</a>
          </div>
        </div>
      </div>

      <div id="dragLayer" aria-hidden="true"></div>
    </div>
  </div>

<script>
/* ===== Auth / withAuth ===== */
(function(){
  const T_KEY='izzaTokenT', U_KEY='izzaUserU';
  const qs=new URLSearchParams(location.search);
  let T=qs.get('t')||''; let U=(qs.get('u')||'').toString().trim();
  try{
    if(T) localStorage.setItem(T_KEY,T);
    else{ const s=localStorage.getItem(T_KEY)||''; if(s){ const u=new URL(location.href); u.searchParams.set('t',s); history.replaceState(null,'',u.toString()); T=s; } }
  }catch(_){}
  function publishU(u){ if(!u) return u; u=u.replace(/^@+/,'').toLowerCase();
    try{ localStorage.setItem(U_KEY,u); }catch(_){}
    window.__IZZA_PROFILE__=Object.assign({},window.__IZZA_PROFILE__,{username:u});
    window.izzaUserKey={get:()=>u};
    try{ if(!localStorage.getItem('piAuthUser')) localStorage.setItem('piAuthUser', JSON.stringify({ username:u })); }catch(_){}
    return u;
  }
  try{
    if(U) publishU(U); else{
      const su=(localStorage.getItem(U_KEY)||'').toString().trim();
      if(su){ const u=new URL(location.href); u.searchParams.set('u',su); history.replaceState(null,'',u.toString()); U=publishU(su); }
    }
  }catch(_){}
  function withAuth(h){ const u=new URL(h, location.origin); if(T) u.searchParams.set('t',T); if(U) u.searchParams.set('u',U); return u.pathname+(u.search?u.search:''); }

  // Ensure ALL nav links (arena/city/game) carry t & u
  document.querySelectorAll('a').forEach(a=>{
    const href=a.getAttribute('href')||'';
    if(href.startsWith('/izza-game/') || href.startsWith('/izza-city') || href.startsWith('/izza')){
      a.href = withAuth(href);
    }
  });

  document.querySelectorAll('#backBtn,#backBtn2,#startBack').forEach(a=>a.href = withAuth(a.getAttribute('href')));
  window._withAuth = withAuth;
})();

/* ===== Wallet helpers ===== */
(function(){
  const CRAFT_KEYS=['izzaCrafting','craftingCredits','izzaCraftCredits'];
  const toInt=v=>{const n=parseInt(v,10);return Number.isFinite(n)?n:0;};
  function readCraftAny(){
    try{
      if(window.IZZA_PERSIST?.get){
        const p=IZZA_PERSIST.get('craftingCredits') ?? IZZA_PERSIST.get('izzaCrafting');
        if(p!=null) return toInt(p);
      }
    }catch(_){}
    for(const k of CRAFT_KEYS){ const v=toInt(localStorage.getItem(k)||'0'); if(v>0) return v|0; }
    return toInt(localStorage.getItem(CRAFT_KEYS[0])||'0')|0;
  }
  function writeCraftAll(v){
    const n=Math.max(0,v|0);
    for(const k of CRAFT_KEYS) localStorage.setItem(k,String(n));
    try{ window.IZZA_PERSIST?.set?.('craftingCredits', n); }catch(_){}
    try{ window.dispatchEvent(new Event('izza-crafting-changed')); }catch(_){}
    saveSoon();
  }
  function readCoins(){
    try{
      if(window.IZZA_PERSIST?.get){
        const c=IZZA_PERSIST.get('coins') ?? IZZA_PERSIST.get('izzaCoins') ?? IZZA_PERSIST.state?.coins;
        if(c!=null) return toInt(c);
      }
    }catch(_){}
    const z=localStorage.getItem('izzaWallet');
    if(z){ try{ const w=JSON.parse(z); if(w&&w.coins!=null) return toInt(w.coins);}catch(_){ } }
    return toInt(localStorage.getItem('izzaCoins')||'0');
  }
  function writeCoins(v){
    const n=v|0; localStorage.setItem('izzaCoins', String(n));
    try{
      const w={coins:n, updatedAt:Date.now(), u:(window.izzaUserKey&&izzaUserKey.get&&izzaUserKey.get())||null};
      localStorage.setItem('izzaWallet', JSON.stringify(w));
    }catch(_){}
    try{ window.IZZA_PERSIST?.set?.('coins', n); }catch(_){}
    try{ window.dispatchEvent(new Event('izza-coins-changed')); }catch(_){}
    saveSoon();
  }
  async function syncFromPersist(){
    try{
      if(window.IZZA_PERSIST?.load) await IZZA_PERSIST.load();
      const c=readCoins(); localStorage.setItem('izzaCoins', String(c));
      const craft=readCraftAny(); CRAFT_KEYS.forEach(k=>localStorage.setItem(k,String(craft)));
    }catch(_){}
  }
  let saveTimer=null;
  function saveSoon(){ try{ if(saveTimer) clearTimeout(saveTimer); saveTimer=setTimeout(async()=>{ try{ await IZZA_PERSIST?.save?.(); }catch(_){} },120);}catch(_){} }

  window._wallet={ readCraftAny, writeCraftAll, readCoins, writeCoins, syncFromPersist, saveSoon };
})();

/* ===== Responsive 7-col sizing ===== */
function sizeBoard(){
  const board=document.querySelector('.board');
  if(!board) return;
  const r=board.getBoundingClientRect();
  const cols=7, gutter=10, minW=56, maxW=96;
  let w=Math.floor((r.width - gutter*(cols-1))/cols);
  w=Math.max(minW, Math.min(maxW, w));
  document.documentElement.style.setProperty('--cardW', w+'px');
  const h=Math.round(w*1.45);
  const fan=Math.max(18, Math.min(Math.round(h*0.28), 38));
  document.documentElement.style.setProperty('--cardH', h+'px');
  document.documentElement.style.setProperty('--fanY', fan+'px');
}
window.addEventListener('resize', sizeBoard, {passive:true});
window.addEventListener('orientationchange', sizeBoard, {passive:true});

/* ===== HUD refs ===== */
const elCoins=document.getElementById('coinsHUD');
const elCraft=document.getElementById('craftHUD');
const elTime=document.getElementById('time');
const elMoves=document.getElementById('moves');
function paintWallet(){ elCoins.textContent=String(_wallet.readCoins()); elCraft.textContent=String(_wallet.readCraftAny()); }
window.addEventListener('izza-coins-changed', paintWallet, {passive:true});
window.addEventListener('izza-crafting-changed', paintWallet, {passive:true});

/* ===== Draw mode preference ===== */
const DRAW_KEY='izza_sol_draw';
function getDrawPref(){ const v=parseInt(localStorage.getItem(DRAW_KEY)||'1',10); return (v===3)?3:1; }
function setDrawPref(n){ localStorage.setItem(DRAW_KEY, String(n===3?3:1)); }

/* ===== Solitaire core ===== */
const SUITS=['♠','♥','♣','♦'];
const SUIT_FIDX={ '♠':0,'♥':1,'♣':2,'♦':3 };
const COLORS={ '♠':'black','♣':'black','♥':'red','♦':'red' };
const RANKS=['A','2','3','4','5','6','7','8','9','10','J','Q','K'];

function makeDeck(){
  const d=[];
  for(const s of SUITS) for(let i=0;i<RANKS.length;i++)
    d.push({ id:s+RANKS[i], suit:s, rank:i+1, face:false, color:COLORS[s] });
  for(let i=d.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; const t=d[i]; d[i]=d[j]; d[j]=t; }
  return d;
}

const P={ stock:[], waste:[], f:[[],[],[],[]], t:[[],[],[],[],[],[],[]] };
let dragRun=null, startTs=null, timerId=null, moves=0, ended=false, winTs=null;
let FAN=26;

// 5 minute hard cap
const MAX_MS = 300000;

function cssVarInt(name,fallback){ const v=getComputedStyle(document.documentElement).getPropertyValue(name).trim(); const n=parseInt(v,10); return Number.isFinite(n)?n:fallback; }
function fmtTime(ms){ const s=Math.max(0,Math.floor(ms/1000)); const m=(s/60)|0; const ss=String(s%60).padStart(2,'0'); return `${String(m).padStart(2,'0')}:${ss}`; }

function layoutNew(){
  for(let i=0;i<4;i++) P.f[i]=[];
  for(let i=0;i<7;i++) P.t[i]=[];
  P.waste=[]; P.stock=makeDeck();
  moves=0; ended=false; winTs=null; elMoves.textContent='0';

  FAN=cssVarInt('--fanY',26);

  // deal tableau
  for(let col=0; col<7; col++){
    for(let n=0; n<=col; n++){
      const c=P.stock.pop(); P.t[col].push(c);
      c.face=(n===col);
    }
  }
  P.stock.forEach(c=>c.face=false);

  if(timerId) clearInterval(timerId);
  startTs=Date.now(); elTime.textContent='00:00';
  timerId=setInterval(()=>{
    if(ended) return;
    const elapsed = Date.now()-startTs;
    elTime.textContent=fmtTime(elapsed);
    if(elapsed >= MAX_MS){ endGame(false); }
  },250);

  renderAll();
  showMsg('GO!');
  paintWallet(); // show current wallet on entry
}

function showMsg(t){ const m=document.getElementById('bigmsg'); m.textContent=t; m.classList.add('show'); setTimeout(()=>m.classList.remove('show'),850); }

/* ----- Rendering ----- */
function placeXY(el,x,y){ el.style.transform=`translate(${x}px, ${y}px)`; }
function renderAll(){
  const piles={ stock:'stock', waste:'waste', t:['t1','t2','t3','t4','t5','t6','t7'], f:['f1','f2','f3','f4'] };
  [...document.querySelectorAll('.pile')].forEach(p=>p.innerHTML='');

  // STOCK (clickable even when empty to recycle)
  const sEl=document.getElementById(piles.stock);
  if(P.stock.length || P.waste.length){
    const back=spawnCardBack(); back.addEventListener('click', onDraw, {passive:true}); sEl.appendChild(back);
  }

  // WASTE (wider + bigger fan; only the top is interactive)
  const wEl=document.getElementById(piles.waste);
  if(P.waste.length){
    const drawMode=getDrawPref();
    const N=Math.min(drawMode, P.waste.length);
    const start=P.waste.length - N;
    // wider horizontal spread for visibility, scaled to card width
    const gap = (drawMode===3) ? Math.max(18, Math.round(cssVarInt('--cardW',86)*0.42)) : 0;
    for(let i=0;i<N;i++){
      const idx=start+i;
      const c=P.waste[idx]; c.face=true;
      const el=spawnCard(c);
      el.style.zIndex=10+i;
      placeXY(el, i*gap, 0); // more separation for draw-3
      el.dataset.where='w';
      if(idx!==P.waste[P.waste.length-1]) el.dataset.locked='1'; // lock non-top
      wEl.appendChild(el);
    }
  }

  // FOUNDATIONS
  for(let i=0;i<4;i++){
    const fEl=document.getElementById(piles.f[i]);
    P.f[i].forEach((c,k)=>{ const el=spawnCard(c); el.dataset.where='f'; el.dataset.fidx=String(i); el.style.zIndex=k+1; placeStack(el,k*12); fEl.appendChild(el); });
  }

  // TABLEAU
  for(let i=0;i<7;i++){
    const col=P.t[i], tEl=document.getElementById(piles.t[i]);
    col.forEach((c,k)=>{
      const el=spawnCard(c); el.style.zIndex=k+1; el.dataset.where='t'; el.dataset.col=String(i);
      placeStack(el,k*FAN); tEl.appendChild(el);
    });
  }
  enableDrag();
}

function spawnCardBack(){ const el=document.createElement('div'); el.className='card back'; el.style.left='0'; el.style.top='0'; return el; }
function spawnCard(c){
  const el=document.createElement('div');
  el.className='card '+(c.face ? (c.color==='red'?'red':'black') : 'back');
  el.style.left='0'; el.style.top='0';
  el.dataset.id=c.id; el.dataset.rank=c.rank; el.dataset.suit=c.suit; el.dataset.color=c.color; el.dataset.face=String(!!c.face);
  if(c.face){
    const tl=document.createElement('div'); tl.className='pip tl';
    tl.innerHTML=`<span class="rank">${RANKS[c.rank-1]}</span><span class="suit">${c.suit}</span>`;
    const br=document.createElement('div'); br.className='pip br';
    br.innerHTML=`<span class="rank">${RANKS[c.rank-1]}</span><span class="suit">${c.suit}</span>`;
    const mid=document.createElement('div'); mid.className='centerSuit'; mid.textContent=c.suit;
    el.appendChild(tl); el.appendChild(br); el.appendChild(mid);
  }
  return el;
}
function placeStack(el,y){ el.style.transform=`translateY(${y}px)`; }

/* ----- Rules & helper checks ----- */
function canGoFoundation(c, idx){
  const f=P.f[idx]; if(!c.face) return false;
  if(!f.length) return c.rank===1;
  const top=f[f.length-1];
  return c.suit===top.suit && c.rank===top.rank+1;
}
function foundationIndexForSuit(suit){ return ({'♠':0,'♥':1,'♣':2,'♦':3})[suit]; }
function acceptOnTableau(cards,destIdx){
  const dest=P.t[destIdx];
  const head=cards[0];
  for(let i=0;i<cards.length-1;i++){
    const a=cards[i], b=cards[i+1];
    if(!(a.face && b.face && a.rank===b.rank+1 && a.color!==b.color)) return false;
  }
  if(!dest.length) return head.rank===13;
  const t=dest[dest.length-1];
  return head.color!==t.color && head.rank===t.rank-1;
}

/* ----- DRAW from stock (recycle + draw-1/3) ----- */
function recycleWasteToStock(){ while(P.waste.length){ const c=P.waste.pop(); c.face=false; P.stock.push(c); } }
function onDraw(){
  if(!P.stock.length && P.waste.length) recycleWasteToStock();
  const DRAW_N=getDrawPref();
  let drew=0;
  for(let i=0;i<DRAW_N;i++){
    if(!P.stock.length) break;
    const c=P.stock.pop(); c.face=true; P.waste.push(c); drew++;
  }
  if(drew>0){ moves++; elMoves.textContent=String(moves); renderAll(); }
  maybeAutoPlay();
}

/* ----- Autoplay helpers ----- */
function noHiddenCards(){
  for(let i=0;i<7;i++){
    const pile=P.t[i];
    for(let k=0;k<pile.length;k++) if(!pile[k].face) return false;
  }
  return true;
}
function autoMoveCardToFoundation(cardId){
  let c=null;
  if(P.waste.length && P.waste[P.waste.length-1].id===cardId){ c=P.waste[P.waste.length-1]; }
  if(!c){
    for(let i=0;i<7;i++){
      const pile=P.t[i];
      if(pile.length && pile[pile.length-1].id===cardId){ c=pile[pile.length-1]; break; }
    }
  }
  if(!c) return false;
  const fIdx=foundationIndexForSuit(c.suit);
  if(!canGoFoundation(c, fIdx)) return false;
  takeFromSource(c.id);
  P.f[fIdx].push(c);
  moves++; elMoves.textContent=String(moves);
  flipIfNeeded();
  renderAll();
  checkWin();
  return true;
}
function autoPlayAll(){
  let movedSomething=true;
  while(movedSomething){
    movedSomething=false;
    if(P.waste.length){
      const top=P.waste[P.waste.length-1];
      if(autoMoveCardToFoundation(top.id)){ movedSomething=true; continue; }
    }
    const tops=[];
    for(let i=0;i<7;i++){
      const pile=P.t[i]; if(pile.length && pile[pile.length-1].face) tops.push(pile[pile.length-1]);
    }
    tops.sort((a,b)=>a.rank-b.rank);
    for(const t of tops){
      if(autoMoveCardToFoundation(t.id)){ movedSomething=true; break; }
    }
  }
}
function maybeAutoPlay(){
  if(P.stock.length===0 && noHiddenCards()){
    autoPlayAll();
  }
}

/* ----- DRAG + Tap-to-Foundation ----- */
const dragLayer=document.getElementById('dragLayer');

function enableDrag(){
  document.querySelectorAll('.card').forEach(el=>{
    if(el.classList.contains('back')) return;
    if(el.dataset.locked==='1') return; // non-top waste is visual only
    el.onpointerdown=(e)=>{
      if(ended) return;
      const where=el.dataset.where || inferWhere(el);
      const run=buildRunModel(el, where);
      if(!run.cards.length) return;
      startDrag(run, e, el);
      e.preventDefault();
    };
  });
}
function inferWhere(el){
  const p=el.closest('.pile'); if(!p) return '';
  const id=p.id; if(id==='waste') return 'w'; if(id[0]==='t') return 't'; if(id[0]==='f') return 'f'; return '';
}
function buildRunModel(el, where){
  if(where==='w'){
    const top=P.waste[P.waste.length-1];
    if(!top || top.id!==el.dataset.id) return {cards:[],from:'w'};
    return {cards:[top], from:'w'};
  }
  if(where==='f') return {cards:[], from:'f'};
  if(where==='t'){
    const col=+el.dataset.col; const pile=P.t[col];
    const idx=pile.findIndex(c=>c.id===el.dataset.id);
    const take=[];
    for(let i=idx;i<pile.length;i++){
      const c=pile[i]; if(!c.face) return {cards:[],from:'t',col}; take.push(c);
    }
    return {cards:take, from:'t', col};
  }
  return {cards:[], from:''};
}
function startDrag(run,e,srcEl){
  const ids=new Set(run.cards.map(c=>c.id));
  document.querySelectorAll('.card').forEach(n=>{ if(ids.has(n.dataset.id)) n.classList.add('being-dragged'); });

  dragLayer.innerHTML='';
  const ghost=document.createElement('div');
  ghost.style.position='fixed'; ghost.style.left='0'; ghost.style.top='0'; ghost.style.pointerEvents='none'; ghost.style.zIndex='9999';
  run.cards.forEach((c,i)=>{ const g=spawnCard(c); g.style.position='absolute'; g.style.left='0'; g.style.top=(i*cssVarInt('--fanY',26))+'px'; ghost.appendChild(g); });
  dragLayer.appendChild(ghost);

  dragRun={ run, ghost, srcId:srcEl?.dataset?.id||null, moved:false, sx:e.clientX, sy:e.clientY };
  moveGhost(e.clientX, e.clientY);

  window.addEventListener('pointermove', onDragMove, {passive:false});
  window.addEventListener('pointerup', onDragEnd, {once:true, passive:false});
}
function moveGhost(x,y){
  const w=dragRun.ghost.firstChild?.offsetWidth||0;
  const h=dragRun.ghost.firstChild?.offsetHeight||0;
  dragRun.ghost.style.transform=`translate(${x - w/2}px, ${y - h/3}px)`;
}
function onDragMove(e){
  if(!dragRun) return;
  const dx=e.clientX - dragRun.sx, dy=e.clientY - dragRun.sy;
  if(!dragRun.moved && (dx*dx + dy*dy) > 9) dragRun.moved=true; // only mark as drag after small movement
  moveGhost(e.clientX, e.clientY);
  e.preventDefault();
}
function hitPileId(x,y){
  const el=document.elementFromPoint(x,y);
  const pile=el && (el.closest?.('.pile') || (el.classList?.contains('pile')?el:null));
  return pile ? pile.id : '';
}
function onDragEnd(e){
  window.removeEventListener('pointermove', onDragMove);
  let placed=false;

  if(dragRun.moved){
    const target=hitPileId(e.clientX, e.clientY);
    if(target && target.startsWith('t')){
      const tIdx=+target.slice(1)-1;
      placed=tryPlaceToTableau(dragRun.run.cards, tIdx);
    }else if(target && target.startsWith('f') && dragRun.run.cards.length===1){
      const fIdx=+target.slice(1)-1;
      placed=tryPlaceToFoundation(dragRun.run.cards[0], fIdx);
    }
  }else{
    // TAP: try to auto-send this top card to foundation
    const id=dragRun.srcId;
    if(id) placed = autoMoveCardToFoundation(id);
  }

  dragLayer.innerHTML='';
  const ids=new Set(dragRun.run.cards.map(c=>c.id));
  document.querySelectorAll('.card.being-dragged').forEach(n=>{ if(ids.has(n.dataset.id)) n.classList.remove('being-dragged'); });
  dragRun=null;

  if(placed && !ended){
    flipIfNeeded();
    renderAll();
    checkWin();
    maybeAutoPlay();
  }else if(!placed && !ended){
    renderAll();
  }
}

function tryPlaceToTableau(cards,destIdx){
  if(!cards.length) return false;
  if(!acceptOnTableau(cards, destIdx)) return false;
  takeFromSource(cards[0].id);
  cards.forEach(c=>P.t[destIdx].push(c));
  moves++; elMoves.textContent=String(moves);
  return true;
}
function tryPlaceToFoundation(card,fIdx){
  if(!canGoFoundation(card, fIdx)) return false;
  takeFromSource(card.id); P.f[fIdx].push(card);
  moves++; elMoves.textContent=String(moves);
  return true;
}
function takeFromSource(id){
  if(P.waste.length && P.waste[P.waste.length-1].id===id){ P.waste.pop(); return; }
  for(let i=0;i<7;i++){
    const pile=P.t[i]; const idx=pile.findIndex(c=>c.id===id);
    if(idx>=0){ pile.splice(idx); return; }
  }
}
function flipIfNeeded(){
  for(let i=0;i<7;i++){
    const pile=P.t[i];
    if(pile.length && !pile[pile.length-1].face) pile[pile.length-1].face=true;
  }
}

/* Win check */
function checkWin(){
  if(P.f.every(f=>f.length===13)){ winTs=Date.now(); endGame(true); }
}

/* ===== Rewards & Leaderboard (WIN ONLY) ===== */
const COINS_ON_WIN=1000;
const CRAFT_ON_WIN=1;
const LB_GAME_ID='targets';
function lbVariant(){ return getDrawPref()===3 ? 'd3' : 'd1'; }
function makeLeaderboardScore(elapsedMs,moves){
  const base=3600000 - Math.max(0,elapsedMs|0);
  const tie=Math.max(0,1000 - Math.min(1000,moves|0));
  return (base*1000 + tie)|0;
}
async function submitLeaderboard(score){
  const gameKey=`${LB_GAME_ID}::${lbVariant()}`;
  try{
    if(window.IZZA_LEADERBOARD && typeof IZZA_LEADERBOARD.submit==='function'){
      await IZZA_LEADERBOARD.submit({game:gameKey, score:score|0});
    }else{
      await fetch(_withAuth('/izza-game/api/leaderboard/submit'),{
        method:'POST', credentials:'include',
        headers:{'content-type':'application/json'},
        body:JSON.stringify({game:gameKey, score:score|0})
      }).catch(()=>{});
    }
    // local cache
    const u=(window.izzaUserKey&&izzaUserKey.get&&izzaUserKey.get())||'guest';
    const row={u, s:score|0, ts:Date.now()};
    const z=n=>String(n).padStart(2,'0'); const d=new Date();
    const stamps={day:`${d.getFullYear()}-${z(d.getMonth()+1)}-${z(d.getDate())}`, month:`${d.getFullYear()}-${z(d.getMonth()+1)}`, year:String(d.getFullYear())};
    function upsertHigh(key,r){
      try{
        const arr=JSON.parse(localStorage.getItem(key)||'[]'); let found=false;
        for(let i=0;i<arr.length;i++){ if(arr[i] && arr[i].u===r.u){ found=true; if((arr[i].s|0)<(r.s|0)) arr[i]=r; break; } }
        if(!found) arr.push(r); arr.sort((a,b)=>b.s-a.s);
        localStorage.setItem(key, JSON.stringify(arr.slice(0,20)));
      }catch(_){}
    }
    const baseKey=`izzaLb2::${gameKey}`;
    upsertHigh(`${baseKey}::alltime`, row);
    upsertHigh(`${baseKey}::day::${stamps.day}`, row);
    upsertHigh(`${baseKey}::month::${stamps.month}`, row);
    upsertHigh(`${baseKey}::year::${stamps.year}`, row);
  }catch(_){}
}

/* ===== End / overlay ===== */
const endEl=document.getElementById('end');
const resText=document.getElementById('resText');
const resTime=document.getElementById('resTime');
const resMoves=document.getElementById('resMoves');
const resCoins=document.getElementById('resCoins');
const resCraft=document.getElementById('resCraft');

function endGame(won){
  if(ended) return;
  ended=true;
  if(timerId) clearInterval(timerId);
  const elapsed=(won ? (winTs||Date.now()) : Date.now()) - (startTs||Date.now());
  const coinsStart=_wallet.readCoins();
  let coinsDelta=0, craftDelta=0;

  if(won){
    coinsDelta=COINS_ON_WIN; craftDelta=CRAFT_ON_WIN;
    _wallet.writeCoins(coinsStart + coinsDelta);
    _wallet.writeCraftAll(_wallet.readCraftAny() + craftDelta);
    _wallet.saveSoon();
    const score=makeLeaderboardScore(elapsed, moves);
    submitLeaderboard(score);
  }

  resText.textContent=won?'WIN':'Game Ended';
  resTime.textContent=fmtTime(elapsed);
  resMoves.textContent=String(moves);
  resCoins.textContent=String(coinsDelta);
  resCraft.textContent=String(craftDelta);
  paintWallet();

  endEl.classList.add('show');
}

document.getElementById('endBtn').addEventListener('click', (e)=>{ e.preventDefault(); endGame(false); }, {passive:false});
document.getElementById('againBtn').addEventListener('click', (e)=>{ e.preventDefault(); endEl.classList.remove('show'); layoutNew(); }, {passive:false});

/* Rules toggle */
const rulesEl=document.getElementById('rules');
document.getElementById('rulesBtn').addEventListener('click', ()=>rulesEl.classList.add('show'), {passive:true});
document.getElementById('rulesClose').addEventListener('click', ()=>rulesEl.classList.remove('show'), {passive:true});
rulesEl.addEventListener('click', (e)=>{ if(e.target===rulesEl) rulesEl.classList.remove('show'); }, {passive:true});

/* Back to Arcade (and other pages): sync + save first, preserve auth */
document.querySelectorAll('#backBtn,#backBtn2,#startBack,a').forEach(a=>{
  a.addEventListener('click', async (e)=>{
    const href=a.getAttribute('href')||'';
    if(href.startsWith('/')){
      e.preventDefault();
      try{
        await _wallet.syncFromPersist();
        await IZZA_PERSIST?.save?.();
      }catch(_){}
      location.href=_withAuth(href);
    }
  }, {passive:false});
});

/* ===== Start screen wiring ===== */
(function(){
  const startEl=document.getElementById('start');
  const startPlay=document.getElementById('startPlay');
  const startRules=document.getElementById('startRules');
  const radios=[...document.querySelectorAll('input[name="draw"]')];

  const pref=getDrawPref();
  const r=radios.find(x=>+x.value===pref); if(r) r.checked=true;

  startPlay?.addEventListener('click', ()=>{
    const chosen=+((radios.find(x=>x.checked)?.value)||pref);
    setDrawPref(chosen);
    startEl.classList.remove('show');
    startEl.setAttribute('aria-hidden','true');
    layoutNew();
  }, {passive:true});

  startRules?.addEventListener('click', ()=>{
    document.getElementById('rules').classList.add('show');
  }, {passive:true});
})();

/* ===== Boot ===== */
(async function(){
  try{
    // Capture balances on entry and paint HUD with the *current* balances
    await _wallet.syncFromPersist();
  }catch(_){}
  sizeBoard();
  paintWallet(); // ensures current balance shows before the first deal
  // Wait for Start to be pressed
})();
</script>
</body>
</html>
