<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Street Race — IZZA GAME</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <script>window.IZZA_PERSIST_BASE='https://izzagame.onrender.com';</script>
  <script src="/static/game/js/izza-persist.js"></script>
  <link rel="stylesheet" href="/static/themes.css">
  <style>
    :root { --bg:#0a0c12; --panel:#06080e; }
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:#e8eef7;font-family:Arial,Helvetica,sans-serif}
    .arena{position:relative;height:100vh;max-width:520px;margin:0 auto;
      border-left:1px solid rgba(255,255,255,.08);
      border-right:1px solid rgba(255,255,255,.08);
      background:var(--panel);overflow:hidden}
    .hud{position:absolute;top:10px;left:12px;right:12px;z-index:6;
      display:flex;justify-content:space-between;font-size:13px;letter-spacing:.3px}
    .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:8;
      background:linear-gradient(to bottom, rgba(0,0,0,.7), rgba(0,0,0,.55));}
    .card{background:rgba(10,12,18,.95);border:1px solid rgba(255,255,255,.16);border-radius:14px;
      padding:16px 18px;display:flex;flex-direction:column;gap:12px;width:min(92%,460px)}
    .row{display:flex;gap:10px;align-items:center;justify-content:space-between}
    .preview{height:164px;border:1px dashed rgba(255,255,255,.18);border-radius:12px;
      display:flex;align-items:center;justify-content:center;overflow:hidden}
    .startBtn{padding:12px 16px;border-radius:10px;border:1px solid rgba(255,255,255,.1);
      background:rgba(255,255,255,.08);font-weight:800;color:white;width:100%}
    .swatches{display:flex;gap:10px;flex-wrap:wrap}
    .swatch{width:26px;height:26px;border-radius:50%;border:2px solid rgba(255,255,255,.28);cursor:pointer}
    .swatch.active{box-shadow:0 0 0 3px rgba(255,255,255,.18) inset}
    canvas{display:block;width:100%;height:100%;background:transparent}

    /* Nitro meter */
    .nitroWrap{position:absolute;right:12px;bottom:16px;z-index:7;width:110px;height:38px;
      border-radius:999px;border:1px solid rgba(255,255,255,.12);background:#121a2b;overflow:hidden;
      display:flex;align-items:center;justify-content:center;font-weight:800;color:#e8eef7}
    .nitroFill{position:absolute;left:2px;top:2px;bottom:2px;border-radius:999px;
      background:linear-gradient(180deg,#53ffb2,#1ecb7b);width:100%;}
    .nitroLabel{position:relative;z-index:1;pointer-events:none}
  </style>
</head>
<body>
  <div class="arena" id="arena">
    <div class="hud">
      <div>SPEED: <span id="speed">0</span> km/h</div>
      <div>DIST: <span id="dist">0</span> m</div>
      <div>COINS: <span id="coinsRun">0</span></div>
    </div>

    <!-- Garage -->
    <div id="startOverlay" class="overlay">
      <div class="card">
        <h3 style="margin:0">Garage</h3>
        <div class="row" style="opacity:.9;font-size:12px">
          Coins: <b id="wCoins">—</b> &nbsp; | &nbsp; Crafting: <b id="wCraft">—</b>
        </div>
        <div class="preview">
          <canvas id="garagePreview" width="512" height="256"></canvas>
        </div>
        <div>
          <div style="font-size:12px;margin:6px 0 8px">Paint (tint)</div>
          <div class="swatches" id="swatches"></div>
        </div>
        <button id="startBtn" class="startBtn">START</button>
      </div>
    </div>

    <!-- Nitro meter -->
    <div class="nitroWrap" id="nitroWrap" title="Hold to boost">
      <div class="nitroFill" id="nitroFill" style="width:100%"></div>
      <div class="nitroLabel">NITRO</div>
    </div>

    <canvas id="scene"></canvas>
  </div>

<script>
(() => {
/* ============== Wallet ============== */
async function loadWallet(){
  let coins='—', craft='—';
  try{
    if (window.IZZA && typeof IZZA.get === 'function') {
      const w = await IZZA.get('wallet');
      if (w) { coins = w.coins ?? coins; craft = w.crafting ?? craft; }
    } else if (localStorage.getItem('izza_wallet')){
      const w = JSON.parse(localStorage.getItem('izza_wallet'));
      coins = w.coins ?? coins; craft = w.crafting ?? craft;
    }
  }catch(e){}
  document.getElementById('wCoins').textContent = coins;
  document.getElementById('wCraft').textContent = craft;
}
loadWallet();

/* ============== Setup ============== */
const arena  = document.getElementById('arena');
const canvas = document.getElementById('scene');
const ctx    = canvas.getContext('2d', { alpha:true });
ctx.imageSmoothingEnabled = true;
ctx.imageSmoothingQuality = 'high';

const HUD = {
  speed: document.getElementById('speed'),
  dist : document.getElementById('dist'),
  coins: document.getElementById('coinsRun')
};
const nitroWrap = document.getElementById('nitroWrap');
const nitroFill = document.getElementById('nitroFill');

/* ======= Tunables (motion-forward) ======= */
const OVERLAY_ALPHA = 0.10; // very light so the bg art stays visible

// Aurora + horizon glow (subtle)
let AURORA_ALPHA  = 0.16, AURORA_SPEED = 0.06, AURORA_WOBBLE = 18;
let GLOW_ALPHA    = 0.26;

// Motion boosters (much more visible now)
let STREAK_ALPHA  = 0.42;
let STREAK_SPEED  = 1.10;
let SMEAR_ALPHA   = 0.38;
let ASPHALT_ALPHA = 0.26;

// Spawns
const SPAWN_EVERY_MS = 900;
const COIN_CHANCE = 0.55, NITRO_CHANCE = 0.25, BOMB_CHANCE = 0.20;

/* ============== Sizing / Camera ============== */
let dpr=1, W=0, H=0;
let horizonY=0, roadBottomHalf=0, roadTopHalf=0;
let VANISH_Y = -800;
let TOP_FADE_PX   = 90;
let SIDE_FADE_PX  = 70;
let VPT_X=0, VPT_Y=0;

function resize(){
  W = arena.clientWidth;
  H = arena.clientHeight;
  dpr = Math.min(window.devicePixelRatio || 1, 2);
  canvas.width  = Math.floor(W * dpr);
  canvas.height = Math.floor(H * dpr);
  canvas.style.width  = W + 'px';
  canvas.style.height = H + 'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);

  horizonY       = H*0.26;
  roadBottomHalf = W*1.00;   // tiny widen to give more lateral feel
  roadTopHalf    = W*0.08;

  VANISH_Y = -Math.max(H * 0.8, 600);
  TOP_FADE_PX  = Math.max(60, Math.min(110, Math.round(H*0.10)));
  SIDE_FADE_PX = Math.max(90, Math.min( Math.round(W*0.24), 170 ));

  VPT_X = W*0.5;
  VPT_Y = H*0.62;

  buildNoise();
  updateCarPlacement();
}
window.addEventListener('resize', resize, {passive:true});

/* ============== Assets ============== */
const carImg = new Image();
carImg.src = '/static/game/sprites/tracks/coupe.png';
const bgImg = new Image();
bgImg.src = '/static/game/sprites/road_bg.jpg';

/* Tinted sprite for garage preview */
function makeTintedSprite(rgb){
  if (!carImg.complete || !carImg.width) return null;
  const off = document.createElement('canvas');
  off.width  = carImg.width;
  off.height = carImg.height;
  const o = off.getContext('2d');
  o.drawImage(carImg, 0, 0);
  o.globalCompositeOperation = 'multiply';
  o.fillStyle = `rgb(${rgb.r},${rgb.g},${rgb.b})`;
  o.fillRect(0,0,off.width,off.height);
  o.globalCompositeOperation = 'destination-in';
  o.drawImage(carImg, 0, 0);
  o.globalCompositeOperation = 'source-atop';
  o.fillStyle = 'rgba(255,255,255,0.08)';
  o.fillRect(0,0,off.width,off.height);
  o.globalCompositeOperation = 'source-over';
  return off;
}

/* ============== Garage Paint ============== */
const PAINTS = [
  {name:'Cherry',    r:255, g:70,  b:70 },
  {name:'Sunburst',  r:255, g:190, b:40 },
  {name:'Neo Blue',  r:90,  g:180, b:255},
  {name:'Lime',      r:120, g:230, b:90 },
  {name:'Violet',    r:170, g:120, b:255},
  {name:'Graphite',  r:185, g:195, b:205}
];
let paint = JSON.parse(localStorage.getItem('izza_paint')||'null') || PAINTS[0];
let tintedSprite = null;

const swatches = document.getElementById('swatches');
PAINTS.forEach(p=>{
  const d = document.createElement('div');
  d.className = 'swatch';
  d.style.background = `rgb(${p.r},${p.g},${p.b})`;
  if (p.name===paint.name) d.classList.add('active');
  d.title = p.name;
  d.onclick = ()=>{
    paint = p;
    localStorage.setItem('izza_paint', JSON.stringify(paint));
    [...swatches.children].forEach(x=>x.classList.remove('active'));
    d.classList.add('active');
    rebuildTintAndPreview();
  };
  swatches.appendChild(d);
});
const prev = document.getElementById('garagePreview');
const pctx = prev.getContext('2d');
function rebuildTintAndPreview(){
  tintedSprite = makeTintedSprite(paint);
  if (!tintedSprite) return;
  pctx.clearRect(0,0,prev.width,prev.height);
  const pad = 8;
  const availW = prev.width - pad*2;
  const scale  = Math.min(availW / carImg.width, (prev.height-pad*2) / carImg.height);
  const w = Math.round(carImg.width * scale);
  const h = Math.round(carImg.height * scale);
  const x = Math.round((prev.width - w)/2);
  const y = Math.round((prev.height - h)/2);
  const cx = x + w/2, cy = y + h*0.92, rx = w*0.42, ry = h*0.10;
  const g = pctx.createRadialGradient(cx,cy,1,cx,cy,Math.max(rx,ry));
  g.addColorStop(0, `rgba(${paint.r},${paint.g},${paint.b},.22)`);
  g.addColorStop(1, `rgba(${paint.r},${paint.g},${paint.b},0)`);
  pctx.fillStyle = g;
  pctx.beginPath(); pctx.ellipse(cx,cy,rx,ry,0,0,Math.PI*2); pctx.fill();
  pctx.drawImage(tintedSprite, x, y, w, h);
}
carImg.onload = rebuildTintAndPreview;

/* ============== Projection ============== */
const lerp = (a,b,t)=>a+(b-a)*t;
function project(z){
  const k = 0.0105;
  const t = 1 - Math.exp(-k*z);  // z=0 => at horizon, grows toward player
  const y   = lerp(VANISH_Y, H, t);
  const half= lerp(roadTopHalf, roadBottomHalf, t);
  return { y, half, t };
}

/* ======= Road params ======= */
const DEPTH_Z    = 24000;
const STEP_Z     = 48;
const RAIL_SCALE = 1.08;

function edgesAt(z){
  const p = project(z);
  const y = Math.max(p.y, VANISH_Y);
  const half = (y === VANISH_Y) ? 0.0001 : p.half;
  return { y, lx: W/2 - half*RAIL_SCALE - 8, rx: W/2 + half*RAIL_SCALE + 8, t:p.t };
}

/* ============== Background ============== */
function drawBackground(){
  if (bgImg.complete && bgImg.naturalWidth) {
    const iw = bgImg.naturalWidth, ih = bgImg.naturalHeight;
    const r  = Math.max(W/iw, H/ih);
    const nw = iw*r, nh = ih*r;
    const x  = (W - nw) / 2;
    const y  = (H - nh) / 2;
    ctx.drawImage(bgImg, x, y, nw, nh);
  } else {
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, '#0c1120'); g.addColorStop(1, '#090d14');
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
  }
}

/* ---------- Aurora + horizon glow ---------- */
function drawAurora(t){
  const topH = H*0.42;
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  ctx.globalAlpha = AURORA_ALPHA;
  for (let i=0;i<3;i++){
    const phase = t*AURORA_SPEED*(i+1);
    const sway  = Math.sin(phase)*AURORA_WOBBLE*(i?0.6:1);
    const gx = W*0.5 + sway;
    const gy0 = 0, gy1 = topH;
    const g = ctx.createLinearGradient(gx, gy0, gx, gy1);
    g.addColorStop(0.00, 'rgba(0,255,255,0.55)');
    g.addColorStop(0.35, 'rgba(0,180,220,0.25)');
    g.addColorStop(1.00, 'rgba(0,120,180,0.00)');
    ctx.fillStyle = g;
    const w = W*0.32*(i?0.7:1);
    ctx.beginPath();
    ctx.moveTo(gx-w, gy0);
    ctx.lineTo(gx+w, gy0);
    ctx.lineTo(gx+w*0.7, gy1);
    ctx.lineTo(gx-w*0.7, gy1);
    ctx.closePath();
    ctx.fill();
  }
  ctx.restore();
}
function drawVanishingGlow(t){
  const rBase = Math.min(W,H)*0.070;
  const pulse = 1 + 0.06*Math.sin(t*3.2);
  const r2 = rBase*4.8*pulse;
  const g = ctx.createRadialGradient(VPT_X, VPT_Y, 1, VPT_X, VPT_Y, r2);
  g.addColorStop(0,   'rgba(0,255,255,0.70)');
  g.addColorStop(0.4, 'rgba(0,200,255,0.30)');
  g.addColorStop(1,   'rgba(0,200,255,0.00)');
  ctx.save();
  ctx.globalCompositeOperation = 'screen';
  ctx.globalAlpha = GLOW_ALPHA;
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.arc(VPT_X, VPT_Y, r2, 0, Math.PI*2); ctx.fill();
  ctx.restore();
}

/* Asphalt noise layer (scrolling) */
let noiseCanvas=null, noiseCtx=null, noiseW=512, noiseH=512;
function buildNoise(){
  noiseCanvas = document.createElement('canvas');
  noiseCanvas.width = noiseW; noiseCanvas.height = noiseH;
  noiseCtx = noiseCanvas.getContext('2d');
  noiseCtx.clearRect(0,0,noiseW,noiseH);
  // grain + diagonal texture
  noiseCtx.fillStyle = 'rgba(255,255,255,0.02)';
  noiseCtx.fillRect(0,0,noiseW,noiseH);
  const g = noiseCtx.createLinearGradient(0,0,noiseW,noiseH);
  g.addColorStop(0,'rgba(255,255,255,0.10)');
  g.addColorStop(1,'rgba(255,255,255,0.00)');
  noiseCtx.strokeStyle = g;
  for(let i=0;i<140;i++){
    const y = Math.random()*noiseH;
    noiseCtx.globalAlpha = 0.08 + Math.random()*0.10;
    noiseCtx.lineWidth = 1 + Math.random()*2;
    noiseCtx.beginPath();
    noiseCtx.moveTo(0,y);
    noiseCtx.lineTo(noiseW, y - 30 - Math.random()*60);
    noiseCtx.stroke();
  }
}

/* ===== Motion streaks + side smears + asphalt scroll + near-car rush ===== */
function drawMotion(worldZ, speed){
  const k = Math.min(1, (speed/240)) * STREAK_SPEED;

  // radial streaks from vanishing point (sky / far city)
  const count = 36;
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  ctx.globalAlpha = STREAK_ALPHA;
  for (let i=0;i<count;i++){
    const ang = (-0.42 + i/(count-1)*0.84);
    const len = H*1.08;
    const wob = Math.sin((worldZ*0.028)+i)*9;
    const x2 = VPT_X + Math.tan(ang)*(len*0.80) + wob;
    const y2 = H + 30;
    const grad = ctx.createLinearGradient(VPT_X, VPT_Y, x2, y2);
    const base = (i%2===0)? 'rgba(0,255,255,' : 'rgba(255,0,200,';
    grad.addColorStop(0.00, base + (0.66*k) + ')');
    grad.addColorStop(0.25, base + (0.36*k) + ')');
    grad.addColorStop(1.00, base + '0)');
    ctx.strokeStyle = grad;
    ctx.lineWidth = 2 + 12*k;
    ctx.beginPath(); ctx.moveTo(VPT_X, VPT_Y); ctx.lineTo(x2, y2); ctx.stroke();
  }
  ctx.restore();

  // side smears (simulate building/trees blur)
  const smearW = W*0.30;
  const smearG_L = ctx.createLinearGradient(0,0,smearW,0);
  smearG_L.addColorStop(0,   `rgba(0,0,0,${0.08 + SMEAR_ALPHA*0.9*k})`);
  smearG_L.addColorStop(1.0, 'rgba(0,0,0,0)');
  const smearG_R = ctx.createLinearGradient(W,0,W-smearW,0);
  smearG_R.addColorStop(0,   `rgba(0,0,0,${0.08 + SMEAR_ALPHA*0.9*k})`);
  smearG_R.addColorStop(1.0, 'rgba(0,0,0,0)');
  ctx.fillStyle = smearG_L; ctx.fillRect(0,0,smearW,H);
  ctx.fillStyle = smearG_R; ctx.fillRect(W-smearW,0,smearW,H);

  // road polygon for clipping
  const L=[], R=[];
  for (let z=0; z<=DEPTH_Z; z+=STEP_Z){ const e=edgesAt(z); L.push([e.lx,e.y]); R.push([e.rx,e.y]); }
  ctx.save();
  ctx.beginPath(); ctx.moveTo(W/2, VANISH_Y);
  for(let i=R.length-1;i>=0;i--) ctx.lineTo(R[i][0], Math.min(R[i][1],H));
  for(let i=0;i<L.length;i++)    ctx.lineTo(L[i][0], Math.min(L[i][1],H));
  ctx.closePath(); ctx.clip();

  // perspective asphalt scroll (heaviest near the player)
  const scroll = (worldZ * (1.8 + k*1.6)) % noiseH;
  for(let y=-noiseH; y<H+noiseH; y+=noiseH){
    const near = Math.min(1, Math.max(0, (y+noiseH - VPT_Y) / (H - VPT_Y + 1)));
    ctx.globalAlpha = ASPHALT_ALPHA * (0.35 + 0.65*near); // stronger toward bottom
    ctx.drawImage(noiseCanvas, 0, y + scroll, W, noiseH);
  }

  // near-car “rush” — short streaks around the bottom center
  const cx = W*0.5, cy = H*0.92;
  const rush = 10 + Math.round(24*k);
  ctx.globalAlpha = 0.30 + 0.30*k;
  ctx.globalCompositeOperation = 'lighter';
  for(let i=0;i<rush;i++){
    const off = (i-rush/2)/(rush/2);
    const x0 = cx + off * W*0.42;
    const x1 = cx + off * W*0.52;
    const y0 = cy - 22 - Math.abs(off)*40;
    const y1 = cy + 48 + Math.abs(off)*60;
    const g = ctx.createLinearGradient(x0,y0,x1,y1);
    g.addColorStop(0,'rgba(0,255,255,0)');
    g.addColorStop(0.5,`rgba(0,255,255,${0.20+0.35*k})`);
    g.addColorStop(1,'rgba(255,0,200,0)');
    ctx.strokeStyle = g;
    ctx.lineWidth = 1 + 5*k*(1-Math.abs(off));
    ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x1,y1); ctx.stroke();
  }
  ctx.restore();
}

/* ============== Road overlay (no dashes / LEDs) ============== */
function drawRoad(){
  const L=[], R=[];
  for (let z=0; z<=DEPTH_Z; z+=STEP_Z){
    const e = edgesAt(z);
    if (e.y>H && L.length && R.length) break;
    L.push([e.lx, e.y]); R.push([e.rx, e.y]);
  }
  ctx.save();
  ctx.beginPath();
  ctx.moveTo(W/2, VANISH_Y);
  for (let i=R.length-1;i>=0;i--) ctx.lineTo(R[i][0], Math.min(R[i][1], H));
  for (let i=0;i<L.length;i++)    ctx.lineTo(L[i][0], Math.min(L[i][1], H));
  ctx.closePath();
  ctx.clip();

  const roadG = ctx.createLinearGradient(0, VANISH_Y, 0, H);
  roadG.addColorStop(0, 'rgba(15,20,29,1)');
  roadG.addColorStop(1, 'rgba(10,15,23,1)');
  ctx.globalAlpha = OVERLAY_ALPHA;
  ctx.fillStyle = roadG;
  ctx.fillRect(0, 0, W, H);
  ctx.globalAlpha = 1;

  // tiny horizon fade
  const topFade = ctx.createLinearGradient(0, 0, 0, TOP_FADE_PX);
  topFade.addColorStop(0, 'rgba(0,0,0,1)');
  topFade.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.globalCompositeOperation = 'destination-out';
  ctx.fillStyle = topFade;
  ctx.fillRect(0, 0, W, TOP_FADE_PX);
  ctx.globalCompositeOperation = 'source-over';
  ctx.restore();
}

/* ============== Pickups (coin, nitro, bomb) ============== */
class Pickup {
  constructor(type, spawnZ, laneT){
    this.type = type;          // 'coin' | 'nitro' | 'bomb'
    this.spawnZ = spawnZ;      // == worldZ at creation (horizon)
    this.laneT = laneT;        // 0..1 across road
    this.spin = Math.random()*Math.PI*2;
    this.alive = true;
  }
  // items start at horizon (zRel=0) and move toward player as worldZ increases
  zRel(worldZ){ return Math.max(0, worldZ - this.spawnZ); }

  draw(worldZ){
    const z = this.zRel(worldZ);
    if (z>DEPTH_Z) return;
    const e = edgesAt(z);
    const x = e.lx + (e.rx-e.lx)*this.laneT;
    const y = e.y;

    // slight easing makes them feel like they accelerate
    const ease = (p)=>p*p*(3-2*p);
    const s = 0.28 + ease(e.t) * 1.05;

    this.spin += 0.15 + (this.type==='coin'?0.22:0.12);

    if (this.type==='coin') drawCoin(x,y,s,this.spin);
    else if (this.type==='nitro') drawNitro(x,y,s*1.08,this.spin);
    else drawBomb(x,y,s*1.15,this.spin);

    if (y>H+40) this.alive=false;
  }

  hitTest(carRect, worldZ){
    const z = this.zRel(worldZ);
    const e = edgesAt(z);
    const x = e.lx + (e.rx-e.lx)*this.laneT;
    const y = e.y;
    const r = 18 + 42*e.t; // grows as it approaches
    const cx = x, cy = y;
    const nx = Math.max(carRect.x, Math.min(cx, carRect.x+carRect.w));
    const ny = Math.max(carRect.y, Math.min(cy, carRect.y+carRect.h));
    const dx = cx-nx, dy = cy-ny;
    return (dx*dx + dy*dy) < (r*r*0.85);
  }
}

/* Procedural sprites (same look) */
function drawCoin(x,y,s,ang){
  const w = 26*s, h = 26*s*Math.max(0.28, Math.abs(Math.cos(ang)));
  ctx.save();
  ctx.translate(x,y);
  ctx.globalCompositeOperation='lighter';
  ctx.fillStyle='rgba(255,214,70,0.95)'; ctx.beginPath(); ctx.ellipse(0,0,w,h,0,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='rgba(255,186,0,1)';     ctx.beginPath(); ctx.ellipse(0,0,w*0.82,h*0.82,0,0,Math.PI*2); ctx.fill();
  ctx.globalCompositeOperation='source-over';
  ctx.fillStyle='rgba(40,28,0,0.7)';
  ctx.font = `${Math.max(8,10*s)}px Arial Black`;
  ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('IZZA',0,0);
  ctx.restore();
}
function drawNitro(x,y,s,ang){
  const w = 16*s, h = 34*s;
  ctx.save(); ctx.translate(x,y); ctx.rotate(Math.sin(ang)*0.25);
  const g = ctx.createLinearGradient(0,-h/2,0,h/2);
  g.addColorStop(0,'#65ffd1'); g.addColorStop(1,'#17a56a');
  ctx.fillStyle=g; ctx.strokeStyle='rgba(0,0,0,0.35)'; ctx.lineWidth=2;
  if (!CanvasRenderingContext2D.prototype.roundRect){
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      r = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+r, y);
      this.arcTo(x+w, y, x+w, y+h, r);
      this.arcTo(x+w, y+h, x, y+h, r);
      this.arcTo(x, y+h, x, y, r);
      this.arcTo(x, y, x+w, y, r);
      return this;
    };
  }
  ctx.beginPath(); ctx.roundRect(-w/2,-h/2,w,h,6); ctx.fill(); ctx.stroke();
  ctx.fillStyle='rgba(0,0,0,0.25)'; ctx.fillRect(-w*0.45,-h*0.05,w*0.9,h*0.1);
  ctx.fillStyle='rgba(255,255,255,0.9)';
  ctx.font=`${Math.max(6,8*s)}px Arial Black`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('N2O',0,0);
  ctx.fillStyle='#0e2130'; ctx.fillRect(-w*0.25,-h*0.62,w*0.5,h*0.14);
  ctx.restore();
}
function drawBomb(x,y,s,ang){
  const r = 16*s;
  ctx.save(); ctx.translate(x,y); ctx.rotate(ang*0.7);
  ctx.fillStyle='rgba(30,30,35,1)'; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
  ctx.globalCompositeOperation='lighter';
  const flick = 0.6+0.4*Math.sin(ang*3);
  ctx.fillStyle=`rgba(255,120,20,${0.5+0.5*flick})`;
  ctx.beginPath(); ctx.arc(r*0.6,-r*0.6,4+2*flick,0,Math.PI*2); ctx.fill();
  ctx.restore();
}

/* ============== Car ============== */
let carW=0, carH=0, carX=0, carY=0;
function updateCarPlacement(){
  // smaller car for more play space
  carW = Math.min(W*0.78, 480);
  const ratio = (carImg.height||512) / (carImg.width||1024);
  carH = carW * ratio;
  carX = Math.round((W - carW)/2);
  carY = Math.round(H - carH*1.02);
}
function carRect(){ return {x:carX+carW*0.18, y:carY+carH*0.30, w:carW*0.64, h:carH*0.52}; }

function buildCarFXCanvas(nitroBoost, t){
  const fx = document.createElement('canvas');
  fx.width = Math.max(2, Math.floor(carW));
  fx.height = Math.max(2, Math.floor(carH));
  const c = fx.getContext('2d');

  const flick = 0.75 + 0.25*Math.sin(t*12);
  const lightY = carH*0.56;
  const leftX  = carW*0.23;
  const rightX = carW*0.73;

  c.globalCompositeOperation = 'lighter';
  c.shadowBlur = 24;
  c.shadowColor = `rgba(255,60,40,${0.85*flick})`;
  c.fillStyle   = `rgba(255,70,50,${0.55*flick})`;

  const lamp = (x) => {
    c.beginPath();
    c.moveTo(x-18, lightY);
    c.lineTo(x+18, lightY);
    c.lineTo(x+8,  lightY+10);
    c.lineTo(x-8,  lightY+10);
    c.closePath(); c.fill();
  };
  lamp(leftX); lamp(rightX);

  const flame = (nitroBoost? 1.0 : 0.35) * (0.7+0.3*Math.sin(t*20));
  c.shadowBlur  = 28;
  c.shadowColor = `rgba(${paint.r},${paint.g},${paint.b},1)`;
  c.fillStyle   = `rgba(${paint.r},${paint.g},${paint.b},${0.22+0.35*flame})`;

  const jet = (x) => {
    c.beginPath();
    c.moveTo(x, carH*0.86);
    c.quadraticCurveTo(x-12, carH*0.96, x, carH*1.08);
    c.quadraticCurveTo(x+12, carH*0.96, x, carH*0.86);
    c.closePath(); c.fill();
  };
  jet(carW*0.38); jet(carW*0.62);
  return fx;
}

let time = 0;
function drawCar(nitroBoost){
  const src = tintedSprite || carImg;
  ctx.drawImage(src, carX, carY, carW, carH);
  const fx = buildCarFXCanvas(nitroBoost, time);
  ctx.globalCompositeOperation = 'lighter';
  ctx.drawImage(fx, carX, carY);
  ctx.globalCompositeOperation = 'source-over';
}

/* ============== Input ============== */
const steer = { x:0, nitro:false };
canvas.addEventListener('pointerdown', e=>{
  const x = e.clientX - canvas.getBoundingClientRect().left;
  steer.x = (x < W/2) ? -1 : 1;
});
canvas.addEventListener('pointermove', e=>{
  if (e.buttons) {
    const x = e.clientX - canvas.getBoundingClientRect().left;
    steer.x = (x < W/2) ? -1 : 1;
  }
});
window.addEventListener('pointerup', ()=>{ steer.x=0; });
window.addEventListener('keydown', e=>{
  if(e.key==='ArrowLeft')  steer.x=-1;
  if(e.key==='ArrowRight') steer.x=1;
  if(e.key.toLowerCase()===' ') steer.nitro=true;
});
window.addEventListener('keyup', e=>{
  if(e.key==='ArrowLeft'||e.key==='Right') steer.x=0;
  if(e.key.toLowerCase()===' ') steer.nitro=false;
});

/* Nitro meter hold */
function bindNitroHold(el){
  const on=()=>{ steer.nitro=true; };
  const off=()=>{ steer.nitro=false; };
  el.addEventListener('pointerdown', e=>{ e.preventDefault(); on(); });
  window.addEventListener('pointerup', off);
  el.addEventListener('touchstart', e=>{ e.preventDefault(); on(); }, {passive:false});
  el.addEventListener('touchend', off);
}
bindNitroHold(nitroWrap);

/* ============== Loop, entities, game state ============== */
let worldZ = 0, last = performance.now();
const state = { running:false, speed:0, dist:0, coins:0, bombsHit:0 };
let nitro = 1.0; // 0..1 meter
let nitroActive = false;
let lastSpawn = 0;
const pickups = [];
const LANE_TS = [0.22, 0.50, 0.78];

function spawnOne(){
  const r = Math.random();
  const lane = LANE_TS[Math.floor(Math.random()*3)];
  const spawnZ = worldZ; // **spawn at horizon**
  if (r < COIN_CHANCE) pickups.push(new Pickup('coin', spawnZ, lane));
  else if (r < COIN_CHANCE + NITRO_CHANCE) pickups.push(new Pickup('nitro', spawnZ, lane));
  else pickups.push(new Pickup('bomb', spawnZ, lane));
}

function useNitro(dt){
  const can = nitro>0.02;
  nitroActive = steer.nitro && can;
  if (nitroActive){ nitro = Math.max(0, nitro - dt*0.25); }
  nitroFill.style.width = Math.round(nitro*100)+'%';
}

function gameOver(){
  state.running=false;
  const msg =
`CRASHED 💥
Distance: ${Math.round(state.dist)} m
Coins: ${state.coins}`;
  alert(msg);
  document.getElementById('startOverlay').style.display='';
}

function frame(now){
  if(!state.running) return;
  const dt = Math.min(0.033, (now - last)/1000); last = now;
  time += dt;

  // Nitro & speed
  useNitro(dt);
  const target = (nitroActive ? 260 : 190);
  state.speed += (target - state.speed) * 0.10;

  const mps = state.speed / 3.6;
  worldZ += mps * dt;
  state.dist += mps * dt;

  // Spawns
  if (now - lastSpawn > SPAWN_EVERY_MS*(0.85+Math.random()*0.3)) {
    lastSpawn = now; spawnOne();
  }

  // Draw
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawBackground();
  drawRoad();
  drawAurora(time);
  drawVanishingGlow(time);
  drawMotion(worldZ, state.speed);

  // Car steering — give enough lateral travel for L / M / R lanes
  const steerSpeed = Math.max(2.5, W * 0.0055); // scaled for device width
  carX += steer.x * steerSpeed;
  carX = Math.max(0, Math.min(W - carW, carX));
  const cRect = carRect();

  // Pickups
  for (const p of pickups) {
    if (!p.alive) continue;
    p.draw(worldZ);
    if (p.hitTest(cRect, worldZ)) {
      p.alive = false;
      if (p.type === 'coin') {
        state.coins += 100;
      } else if (p.type === 'nitro') {
        nitro = Math.min(1, nitro + 0.25);
      } else {
        state.bombsHit++;
        if (state.bombsHit >= 3) { gameOver(); return; }
      }
    }
  }
  // cleanup
  for (let i = pickups.length - 1; i >= 0; i--) if (!pickups[i].alive) pickups.splice(i, 1);

  drawCar(nitroActive);

  // HUD
  HUD.speed.textContent = Math.round(state.speed);
  HUD.dist.textContent  = Math.round(state.dist);
  HUD.coins.textContent = state.coins;

  requestAnimationFrame(frame);
}

document.getElementById('startBtn').addEventListener('click', () => {
  document.getElementById('startOverlay').style.display = 'none';
  resize();
  tintedSprite = makeTintedSprite(paint);
  state.running   = true;
  state.speed     = 90;
  state.dist      = 0;
  worldZ          = 0;
  last            = performance.now();
  state.coins     = 0;
  state.bombsHit  = 0;
  nitro           = 1.0;
  nitroFill.style.width = '100%';
  pickups.length  = 0;
  lastSpawn       = performance.now();
  requestAnimationFrame(frame);
});

/* init */
resize();
rebuildTintAndPreview();
})();
</script>
</body>
</html>
