<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Street Race — IZZA GAME</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <script>window.IZZA_PERSIST_BASE='https://izzagame.onrender.com';</script>
  <script src="/static/game/js/izza-persist.js"></script>
  <link rel="stylesheet" href="/static/themes.css">
  <style>
    :root { --bg:#0a0c12; --panel:#06080e; }
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:#e8eef7;font-family:Arial,Helvetica,sans-serif}
    .arena{position:relative;height:100vh;max-width:520px;margin:0 auto;
      border-left:1px solid rgba(255,255,255,.08);
      border-right:1px solid rgba(255,255,255,.08);
      background:var(--panel);overflow:hidden}
    .hud{position:absolute;top:10px;left:12px;right:12px;z-index:6;
      display:flex;justify-content:space-between;font-size:13px;letter-spacing:.3px}
    .nitroBtn{position:absolute;right:12px;bottom:16px;z-index:7;border-radius:999px;
      border:1px solid rgba(255,255,255,.1);background:#182033;padding:12px 18px;
      font-weight:800;color:white}
    .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:8;
      background:linear-gradient(to bottom, rgba(0,0,0,.7), rgba(0,0,0,.55));}
    .card{background:rgba(10,12,18,.95);border:1px solid rgba(255,255,255,.16);border-radius:14px;
      padding:16px 18px;display:flex;flex-direction:column;gap:12px;width:min(92%,460px)}
    .row{display:flex;gap:10px;align-items:center;justify-content:space-between}
    .preview{height:164px;border:1px dashed rgba(255,255,255,.18);border-radius:12px;
      display:flex;align-items:center;justify-content:center;overflow:hidden}
    .startBtn{padding:12px 16px;border-radius:10px;border:1px solid rgba(255,255,255,.1);
      background:rgba(255,255,255,.08);font-weight:800;color:white;width:100%}
    .swatches{display:flex;gap:10px;flex-wrap:wrap}
    .swatch{width:26px;height:26px;border-radius:50%;border:2px solid rgba(255,255,255,.28);cursor:pointer}
    .swatch.active{box-shadow:0 0 0 3px rgba(255,255,255,.18) inset}
    canvas{display:block;width:100%;height:100%;background:transparent}
  </style>
</head>
<body>
  <div class="arena" id="arena">
    <div class="hud">
      <div>SPEED: <span id="speed">0</span> km/h</div>
      <div>DIST: <span id="dist">0</span> m</div>
      <div>COINS: <span id="coinsRun">0</span></div>
    </div>

    <!-- Garage -->
    <div id="startOverlay" class="overlay">
      <div class="card">
        <h3 style="margin:0">Garage</h3>
        <div class="row" style="opacity:.9;font-size:12px">
          Coins: <b id="wCoins">—</b> &nbsp; | &nbsp; Crafting: <b id="wCraft">—</b>
        </div>
        <div class="preview">
          <canvas id="garagePreview" width="512" height="256"></canvas>
        </div>
        <div>
          <div style="font-size:12px;margin:6px 0 8px">Paint (tint)</div>
          <div class="swatches" id="swatches"></div>
        </div>
        <button id="startBtn" class="startBtn">START</button>
      </div>
    </div>

    <button class="nitroBtn" id="nitroBtn">NITRO</button>
    <canvas id="scene"></canvas>
  </div>

<script>
(() => {
/* ============== Wallet ============== */
async function loadWallet(){
  let coins='—', craft='—';
  try{
    if (window.IZZA && typeof IZZA.get === 'function') {
      const w = await IZZA.get('wallet');
      if (w) { coins = w.coins ?? coins; craft = w.crafting ?? craft; }
    } else if (localStorage.getItem('izza_wallet')){
      const w = JSON.parse(localStorage.getItem('izza_wallet'));
      coins = w.coins ?? coins; craft = w.crafting ?? craft;
    }
  }catch(e){}
  document.getElementById('wCoins').textContent = coins;
  document.getElementById('wCraft').textContent = craft;
}
loadWallet();

/* ============== Setup ============== */
const arena  = document.getElementById('arena');
const canvas = document.getElementById('scene');
const ctx    = canvas.getContext('2d', { alpha:true });
ctx.imageSmoothingEnabled = true;
ctx.imageSmoothingQuality = 'high';

const HUD = {
  speed: document.getElementById('speed'),
  dist : document.getElementById('dist'),
  coins: document.getElementById('coinsRun')
};

/* ============== Sizing / Camera ============== */
let dpr=1, W=0, H=0;
let horizonY=0, roadBottomHalf=0, roadTopHalf=0;

// Tip of the road stays above the canvas
let VANISH_Y = -800;

// Fade sizes (horizon + side)
let TOP_FADE_PX   = 90;
let SIDE_FADE_PX  = 70;

function resize(){
  W = arena.clientWidth;
  H = arena.clientHeight;
  dpr = Math.min(window.devicePixelRatio || 1, 2);
  canvas.width  = Math.floor(W * dpr);
  canvas.height = Math.floor(H * dpr);
  canvas.style.width  = W + 'px';
  canvas.style.height = H + 'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);

  // Stronger perspective (⬇️ narrower road)
  horizonY       = H*0.26;
  roadBottomHalf = W*0.95;  // ⟵ angle knob (bigger = wider)
  roadTopHalf    = W*0.08;  // ⟵ angle knob (smaller = sharper)

  // keep the tip comfortably above the HUD
  VANISH_Y = -Math.max(H * 0.8, 600);

  // Stronger side fade by default
  TOP_FADE_PX  = Math.max(60, Math.min(110, Math.round(H*0.10)));
  SIDE_FADE_PX = Math.max(70, Math.min( Math.round(W*0.20), 140 )); // ⟵ wider

  updateCarPlacement();
}
window.addEventListener('resize', resize, {passive:true});

/* ============== Assets & Tint (offscreen) ============== */
const carImg = new Image();
carImg.src = '/static/game/sprites/tracks/coupe.png';

function makeTintedSprite(rgb){
  if (!carImg.complete || !carImg.width) return null;
  const off = document.createElement('canvas');
  off.width  = carImg.width;
  off.height = carImg.height;
  const o = off.getContext('2d');
  o.imageSmoothingEnabled = true;

  o.drawImage(carImg, 0, 0);
  o.globalCompositeOperation = 'multiply';
  o.fillStyle = `rgb(${rgb.r},${rgb.g},${rgb.b})`;
  o.fillRect(0,0,off.width,off.height);
  o.globalCompositeOperation = 'destination-in';
  o.drawImage(carImg, 0, 0);
  o.globalCompositeOperation = 'source-atop';
  o.fillStyle = 'rgba(255,255,255,0.08)';
  o.fillRect(0,0,off.width,off.height);
  o.globalCompositeOperation = 'source-over';
  return off;
}

/* ============== Garage Paint ============== */
const PAINTS = [
  {name:'Cherry',    r:255, g:70,  b:70 },
  {name:'Sunburst',  r:255, g:190, b:40 },
  {name:'Neo Blue',  r:90,  g:180, b:255},
  {name:'Lime',      r:120, g:230, b:90 },
  {name:'Violet',    r:170, g:120, b:255},
  {name:'Graphite',  r:185, g:195, b:205}
];
let paint = JSON.parse(localStorage.getItem('izza_paint')||'null') || PAINTS[0];
let tintedSprite = null;

const swatches = document.getElementById('swatches');
PAINTS.forEach(p=>{
  const d = document.createElement('div');
  d.className = 'swatch';
  d.style.background = `rgb(${p.r},${p.g},${p.b})`;
  if (p.name===paint.name) d.classList.add('active');
  d.title = p.name;
  d.onclick = ()=>{
    paint = p;
    localStorage.setItem('izza_paint', JSON.stringify(paint));
    [...swatches.children].forEach(x=>x.classList.remove('active'));
    d.classList.add('active');
    rebuildTintAndPreview();
  };
  swatches.appendChild(d);
});

const prev = document.getElementById('garagePreview');
const pctx = prev.getContext('2d');

function rebuildTintAndPreview(){
  tintedSprite = makeTintedSprite(paint);
  if (!tintedSprite) return;

  pctx.clearRect(0,0,prev.width,prev.height);
  const pad = 8;
  const availW = prev.width - pad*2;
  const scale  = Math.min(availW / carImg.width, (prev.height-pad*2) / carImg.height);
  const w = Math.round(carImg.width * scale);
  const h = Math.round(carImg.height * scale);
  const x = Math.round((prev.width - w)/2);
  const y = Math.round((prev.height - h)/2);

  const cx = x + w/2, cy = y + h*0.92, rx = w*0.42, ry = h*0.10;
  const g = pctx.createRadialGradient(cx,cy,1,cx,cy,Math.max(rx,ry));
  g.addColorStop(0, `rgba(${paint.r},${paint.g},${paint.b},.22)`);
  g.addColorStop(1, `rgba(${paint.r},${paint.g},${paint.b},0)`);
  pctx.fillStyle = g;
  pctx.beginPath(); pctx.ellipse(cx,cy,rx,ry,0,0,Math.PI*2); pctx.fill();

  pctx.drawImage(tintedSprite, x, y, w, h);
}
carImg.onload = rebuildTintAndPreview;

/* ============== Projection ============== */
const lerp = (a,b,t)=>a+(b-a)*t;
function project(z){
  const k = 0.0105;
  const t = 1 - Math.exp(-k*z);
  const y   = lerp(VANISH_Y, H, t);
  const half= lerp(roadTopHalf, roadBottomHalf, t);
  return { y, half, t };
}

/* ======= Road params ======= */
const DEPTH_Z    = 18000;
const STEP_Z     = 60;
const DASH_STEP  = 26;
const DASH_LEN_Z = 18;
const LED_STEP   = 16;
const RAIL_SCALE = 1.08;  // ⟵ slight flare

function edgesAt(z){
  const p = project(z);
  const y = Math.max(p.y, VANISH_Y);
  const half = (y === VANISH_Y) ? 0.0001 : p.half;
  return { y, lx: W/2 - half*RAIL_SCALE - 8, rx: W/2 + half*RAIL_SCALE + 8 };
}

/* helper: find X on an edge polyline at a given Y (for the side wedges) */
function xAtY(edge, y){
  for (let i=0;i<edge.length-1;i++){
    const y0=edge[i][1], y1=edge[i+1][1];
    if (y>=y0 && y<=y1){
      const t=(y - y0)/(y1 - y0 || 1e-6);
      return edge[i][0] + (edge[i+1][0]-edge[i][0])*t;
    }
  }
  return edge[edge.length-1][0];
}

/* ============== Sky ============== */
function drawSky(){
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0, '#0c1120');
  g.addColorStop(0.35, '#0f1523');
  g.addColorStop(1, '#090d14');
  ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
}

/* ============== Road + dashes + LEDs + tiny horizon & side wedges ============== */
function drawRoad(worldZ){
  // Build edge samples (near → far)
  const L=[], R=[];
  for (let z=0; z<=DEPTH_Z; z+=STEP_Z){
    const e = edgesAt(z);
    if (e.y>H && L.length && R.length) break;
    L.push([e.lx, e.y]); R.push([e.rx, e.y]);
  }

  // Asphalt polygon
  const roadG = ctx.createLinearGradient(0, VANISH_Y, 0, H);
  roadG.addColorStop(0, '#0f141d');
  roadG.addColorStop(1, '#0a0f17');
  ctx.fillStyle = roadG;

  ctx.beginPath();
  ctx.moveTo(W/2, VANISH_Y);
  for (let i=R.length-1;i>=0;i--) ctx.lineTo(R[i][0], Math.min(R[i][1], H));
  for (let i=0;i<L.length;i++)    ctx.lineTo(L[i][0], Math.min(L[i][1], H));
  ctx.closePath();
  ctx.fill();

  /* ------- Angled side background wedges (stronger fade, longer reach) ------- */
  const y0 = 0;
  const y1 = Math.min(H*0.82, H*0.88); // ⟵ fades extend lower
  const xL0 = xAtY(L, y0);
  const xL1 = xAtY(L, y1);
  const xR0 = xAtY(R, y0);
  const xR1 = xAtY(R, y1);

  // left wedge
  let gradL = ctx.createLinearGradient(0, y0, 0, y1);
  gradL.addColorStop(0.00, 'rgba(0,0,0,0.85)'); // stronger at top
  gradL.addColorStop(0.60, 'rgba(0,0,0,0.35)');
  gradL.addColorStop(1.00, 'rgba(0,0,0,0.00)');
  ctx.fillStyle = gradL;
  ctx.beginPath();
  ctx.moveTo(0, y0);
  ctx.lineTo(xL0 - SIDE_FADE_PX, y0);  // widen wedge
  ctx.lineTo(xL1 - SIDE_FADE_PX*0.35, y1);
  ctx.lineTo(0, y1);
  ctx.closePath();
  ctx.fill();

  // right wedge
  let gradR = ctx.createLinearGradient(0, y0, 0, y1);
  gradR.addColorStop(0.00, 'rgba(0,0,0,0.85)');
  gradR.addColorStop(0.60, 'rgba(0,0,0,0.35)');
  gradR.addColorStop(1.00, 'rgba(0,0,0,0.00)');
  ctx.fillStyle = gradR;
  ctx.beginPath();
  ctx.moveTo(xR0 + SIDE_FADE_PX, y0);
  ctx.lineTo(W, y0);
  ctx.lineTo(W, y1);
  ctx.lineTo(xR1 + SIDE_FADE_PX*0.35, y1);
  ctx.closePath();
  ctx.fill();

  // Lane dashes
  ctx.strokeStyle = 'rgba(255,255,255,0.10)';
  ctx.lineWidth = 6; ctx.lineCap = 'round';
  const LANE_T = [0.22, 0.50, 0.78];
  for (const t of LANE_T){
    for (let z=(worldZ % DASH_STEP)*-1; z<DEPTH_Z; z+=DASH_STEP){
      const a = edgesAt(Math.max(0,z));
      const b = edgesAt(Math.max(0,z + DASH_LEN_Z));
      if (a.y>H && b.y>H) break;
      const x0 = a.lx + (a.rx - a.lx)*t;
      const x1 = b.lx + (b.rx - b.lx)*t;
      ctx.beginPath(); ctx.moveTo(x0, a.y); ctx.lineTo(x1, b.y); ctx.stroke();
    }
  }

  // LED rails
  ctx.fillStyle = 'rgba(255,90,50,0.92)';
  for (let z=(worldZ % LED_STEP)*-1; z<DEPTH_Z; z+=LED_STEP){
    const e = edgesAt(Math.max(0,z));
    if (e.y>H) break;
    const r = Math.max(1, 3 * (1 - (e.y - VANISH_Y) / (H - VANISH_Y)));
    ctx.beginPath(); ctx.arc(e.lx, e.y, r, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(e.rx, e.y, r, 0, Math.PI*2); ctx.fill();
  }

  /* -------- Tiny horizon fade at the very top, only on the road -------- */
  ctx.save();
  ctx.beginPath();
  ctx.moveTo(W/2, VANISH_Y);
  for (let i=R.length-1;i>=0;i--) ctx.lineTo(R[i][0], Math.min(R[i][1], H));
  for (let i=0;i<L.length;i++)    ctx.lineTo(L[i][0], Math.min(L[i][1], H));
  ctx.closePath();
  ctx.clip();

  const topFade = ctx.createLinearGradient(0, 0, 0, TOP_FADE_PX);
  topFade.addColorStop(0, 'rgba(0,0,0,1)');
  topFade.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.globalCompositeOperation = 'destination-out';
  ctx.fillStyle = topFade;
  ctx.fillRect(0, 0, W, TOP_FADE_PX);

  ctx.restore();
  ctx.globalCompositeOperation = 'source-over';
}

/* ============== Car ============== */
let carW=0, carH=0, carX=0, carY=0;
function updateCarPlacement(){
  carW = Math.min(W*0.92, 540);
  const ratio = (carImg.height||512) / (carImg.width||1024);
  carH = carW * ratio;
  carX = Math.round((W - carW)/2);
  carY = Math.round(H - carH*1.02);
}

function buildCarFXCanvas(nitroBoost, t){
  const fx = document.createElement('canvas');
  fx.width = Math.max(2, Math.floor(carW));
  fx.height = Math.max(2, Math.floor(carH));
  const c = fx.getContext('2d');
  c.imageSmoothingEnabled = true;

  const flick = 0.75 + 0.25*Math.sin(t*12);
  const lightY = carH*0.56;
  const leftX  = carW*0.23;
  const rightX = carW*0.73;

  c.globalCompositeOperation = 'lighter';
  c.shadowBlur = 24;
  c.shadowColor = `rgba(255,60,40,${0.85*flick})`;
  c.fillStyle   = `rgba(255,70,50,${0.55*flick})`;

  const lamp = (x) => {
    c.beginPath();
    c.moveTo(x-18, lightY);
    c.lineTo(x+18, lightY);
    c.lineTo(x+8,  lightY+10);
    c.lineTo(x-8,  lightY+10);
    c.closePath(); c.fill();
  };
  lamp(leftX); lamp(rightX);

  const flame = (nitroBoost? 1.0 : 0.35) * (0.7+0.3*Math.sin(t*20));
  c.shadowBlur  = 28;
  c.shadowColor = `rgba(${paint.r},${paint.g},${paint.b},1)`;
  c.fillStyle   = `rgba(${paint.r},${paint.g},${paint.b},${0.22+0.35*flame})`;

  const jet = (x) => {
    c.beginPath();
    c.moveTo(x, carH*0.86);
    c.quadraticCurveTo(x-12, carH*0.96, x, carH*1.08);
    c.quadraticCurveTo(x+12, carH*0.96, x, carH*0.86);
    c.closePath(); c.fill();
  };
  jet(carW*0.38);
  jet(carW*0.62);

  return fx;
}

let time = 0;
function drawCar(nitroBoost){
  const src = tintedSprite || carImg;
  ctx.globalCompositeOperation = 'source-over';
  ctx.drawImage(src, carX, carY, carW, carH);
  const fx = buildCarFXCanvas(nitroBoost, time);
  ctx.globalCompositeOperation = 'lighter';
  ctx.drawImage(fx, carX, carY);
  ctx.globalCompositeOperation = 'source-over';
}

/* ============== Input ============== */
const steer = { x:0 };
canvas.addEventListener('pointerdown', e=>{
  const x = e.clientX - canvas.getBoundingClientRect().left;
  steer.x = (x < W/2) ? -1 : 1;
});
canvas.addEventListener('pointermove', e=>{
  if (e.buttons) {
    const x = e.clientX - canvas.getBoundingClientRect().left;
    steer.x = (x < W/2) ? -1 : 1;
  }
});
window.addEventListener('pointerup', ()=>{ steer.x=0; });
window.addEventListener('keydown', e=>{
  if(e.key==='ArrowLeft')  steer.x=-1;
  if(e.key==='ArrowRight') steer.x=1;
});
window.addEventListener('keyup', e=>{
  if(e.key==='ArrowLeft'||e.key==='Right') steer.x=0;
});

/* ============== Loop ============== */
let worldZ = 0, nitroLeft = 0, last = performance.now();
const state = { running:false, speed:0, dist:0 };

function frame(now){
  if(!state.running) return;
  const dt = Math.min(0.033, (now - last)/1000); last = now;
  time += dt;

  const target = 180 + (nitroLeft>0 ? 140 : 0);
  state.speed += (target - state.speed) * 0.08;
  if (nitroLeft>0) nitroLeft -= dt;

  const mps = state.speed / 3.6;
  worldZ += mps * dt;
  state.dist += mps * dt;

  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawSky();
  drawRoad(worldZ);
  carX += steer.x * 0.9; carX = Math.max(0, Math.min(W-carW, carX));
  drawCar(nitroLeft>0);

  HUD.speed.textContent = Math.round(state.speed);
  HUD.dist.textContent  = Math.round(state.dist);
  HUD.coins.textContent = 0;

  requestAnimationFrame(frame);
}

document.getElementById('nitroBtn').addEventListener('click', ()=>{ nitroLeft = 2.0; });

document.getElementById('startBtn').addEventListener('click',()=>{
  document.getElementById('startOverlay').style.display='none';
  resize();
  tintedSprite = makeTintedSprite(paint);
  state.running = true;
  state.speed = 90; state.dist = 0; worldZ = 0; last = performance.now();
  requestAnimationFrame(frame);
});

/* init */
resize();
rebuildTintAndPreview();
})();
</script>
</body>
</html>
