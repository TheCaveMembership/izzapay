<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Street Race â€” IZZA GAME</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <script>window.IZZA_PERSIST_BASE='https://izzagame.onrender.com';</script>
  <script src="/static/game/js/izza-persist.js"></script>
  <link rel="stylesheet" href="/static/themes.css">
  <style>
    :root { --bg:#0a0c12; --panel:#06080e; }
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:#e8eef7;font-family:Arial,Helvetica,sans-serif}
    .arena{position:relative;height:100vh;max-width:520px;margin:0 auto;
      border-left:1px solid rgba(255,255,255,.08);
      border-right:1px solid rgba(255,255,255,.08);
      background:var(--panel);overflow:hidden}
    .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:8;
      background:linear-gradient(to bottom, rgba(0,0,0,.55), rgba(0,0,0,.35));}
    .card{background:rgba(0,0,0,.6);border:1px solid rgba(255,255,255,.18);border-radius:14px;
      padding:16px 18px;display:flex;flex-direction:column;gap:10px;width:min(92%,440px)}
    .preview{height:160px;border:1px dashed rgba(255,255,255,.18);border-radius:12px;
      display:flex;align-items:center;justify-content:center;overflow:hidden}
    .startBtn{padding:12px 16px;border-radius:10px;border:1px solid rgba(255,255,255,.1);
      background:rgba(255,255,255,.08);font-weight:800;color:white}
    .hud{position:absolute;top:8px;left:8px;right:8px;z-index:6;display:flex;justify-content:space-between;font-size:12px}
    .nitroBtn{position:absolute;right:10px;bottom:14px;z-index:7;border-radius:999px;
      border:1px solid rgba(255,255,255,.1);background:#222;padding:10px 14px;font-weight:800;color:white}
    canvas{display:block;width:100%;height:100%}
  </style>
</head>
<body>
  <div class="arena" id="arena">
    <!-- HUD -->
    <div class="hud">
      <div>SPEED: <span id="speed">0</span> km/h</div>
      <div>DIST: <span id="dist">0</span> m</div>
      <div>COINS: <span id="coinsRun">0</span></div>
    </div>

    <!-- Start Overlay -->
    <div id="startOverlay" class="overlay">
      <div class="card">
        <h3>Street Race</h3>
        <div class="preview">
          <img id="garageCar" src="/static/game/sprites/tracks/coupe.png" alt="Car" style="height:100%"/>
        </div>
        <button id="startBtn" class="startBtn">START</button>
      </div>
    </div>

    <button class="nitroBtn" id="nitroBtn">NITRO</button>
    <canvas id="scene"></canvas>
  </div>

<script>
(function(){
  const arena  = document.getElementById('arena');
  const canvas = document.getElementById('scene');
  const ctx    = canvas.getContext('2d', { alpha:true });
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = 'high';

  const HUD = {
    speed: document.getElementById('speed'),
    dist : document.getElementById('dist'),
    coins: document.getElementById('coinsRun')
  };

  // --- DPR / sizing ---
  let dpr=1, W=0, H=0;
  let horizonY=0, roadBottomHalf=0, roadTopHalf=0;
  function resize(){
    W = arena.clientWidth;
    H = arena.clientHeight;
    dpr = Math.min(window.devicePixelRatio || 1, 2);
    canvas.width  = Math.floor(W * dpr);
    canvas.height = Math.floor(H * dpr);
    canvas.style.width  = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);

    horizonY = H*0.22;   // sky/ground split
    roadBottomHalf = W*0.42;
    roadTopHalf    = W*0.10;

    // place player in the RIGHT LANE (right-hand traffic)
    laneOffsetBottom = roadBottomHalf*0.25; // 25% from center to right
  }
  window.addEventListener('resize', resize, {passive:true});

  // --- Assets ---
  const carImg = new Image();
  carImg.src = '/static/game/sprites/tracks/coupe.png';
  let carRatio = 0.5;
  carImg.onload = ()=>{ carRatio = carImg.height / carImg.width; };

  // --- Input (tap left/right; arrow keys) ---
  const steer = { x:0 };
  function onPointer(e){
    const r = canvas.getBoundingClientRect();
    const x = (e.touches ? e.touches[0].clientX : e.clientX) - r.left;
    steer.x = (x < r.width/2) ? -1 : 1;
  }
  function stopPointer(){ steer.x = 0; }
  canvas.addEventListener('pointerdown', onPointer);
  canvas.addEventListener('pointermove', onPointer);
  window.addEventListener('pointerup', stopPointer);
  window.addEventListener('keydown', e=>{
    if(e.key==='ArrowLeft') steer.x=-1;
    if(e.key==='ArrowRight') steer.x=1;
  });
  window.addEventListener('keyup', e=>{
    if(e.key==='ArrowLeft'||e.key==='ArrowRight') steer.x=0;
  });

  // --- Colors (Tokyo/Chinatown neon) ---
  const neon = ['#08f7fe','#f5a9b8','#ff2079','#ffee00','#7cff00','#ff6b00'];
  const nightTop = '#0d1220', nightMid='#0b101a', nightBot='#090d14';

  // --- Projection ---
  const lerp = (a,b,t)=>a+(b-a)*t;
  function project(z){ // depth-> screen
    const k = 0.012;
    const t = 1 - Math.exp(-k*z);
    const y = lerp(horizonY, H, t);
    const half = lerp(roadTopHalf, roadBottomHalf, t);
    return { y, half, t };
  }

  // --- World state ---
  let worldZ = 0;                     // meters
  const dashLenM = 9, gapLenM = 9;
  const sidePostSpacingM = 18;

  // roadside props (spawned ahead, stream past)
  const props = [];
  const PROP_SPAWN_EVERY_M = 28; // average spacing per side
  let lastSpawnZ = 0;

  function spawnProp(side){ // side: -1 left, +1 right (relative to player)
    const kindPool = ['sign','shop','lantern','tree','lamp'];
    const kind = kindPool[Math.random()*kindPool.length|0];
    const z = worldZ + 140 + Math.random()*80; // ahead of camera
    const hue = neon[Math.random()*neon.length|0];
    const width = 16 + Math.random()*26;  // base sprite size (abstract)
    const height = 32 + Math.random()*60;
    props.push({ kind, side, z, hue, width, height, wobble: Math.random()*Math.PI*2 });
  }

  function updateProps(){
    // spawn new as we move forward
    if (worldZ - lastSpawnZ > PROP_SPAWN_EVERY_M){
      lastSpawnZ = worldZ;
      // sprinkle both sides with some randomness
      if (Math.random()<0.9) spawnProp(-1);
      if (Math.random()<0.9) spawnProp( 1);
    }
    // cull old
    for (let i=props.length-1;i>=0;i--){
      if (props[i].z < worldZ-10) props.splice(i,1);
    }
  }

  function drawBackground(){
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, nightTop);
    g.addColorStop(0.35, nightMid);
    g.addColorStop(1, nightBot);
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // far skyline (parallax: slower than road)
    ctx.fillStyle = '#0a1020';
    const skylineH = H*0.18;
    const baseY = horizonY - skylineH*0.4;
    const seed = Math.floor(worldZ/30); // move slowly with distance
    for (let i=-2;i<14;i++){
      const x = (i*60 + seed*22) % (W+120) - 60;
      const bw = 40 + (i*37 % 40);
      const bh = skylineH*0.6 + ((i*53) % (skylineH*0.4));
      ctx.fillRect(x, baseY + (skylineH - bh), bw, bh);
      // neon window dots
      ctx.fillStyle = 'rgba(255,255,255,0.06)';
      for (let d=0; d<10; d++){
        ctx.fillRect(x+6+(d*3% (bw-12)), baseY+ (skylineH-bh)+6+((d*7)% (bh-12)), 2, 2);
      }
      ctx.fillStyle = '#0a1020';
    }
  }

  function drawRoad(){
    // road polygon
    ctx.beginPath();
    ctx.moveTo(W/2 - roadTopHalf, horizonY);
    ctx.lineTo(W/2 + roadTopHalf, horizonY);
    ctx.lineTo(W/2 + roadBottomHalf, H);
    ctx.lineTo(W/2 - roadBottomHalf, H);
    ctx.closePath();

    // asphalt
    const g = ctx.createLinearGradient(0,horizonY,0,H);
    g.addColorStop(0, '#1a1f2a');
    g.addColorStop(1, '#0e131b');
    ctx.fillStyle = g;
    ctx.fill();

    // side lines
    ctx.strokeStyle = 'rgba(235,240,255,0.9)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(W/2 - roadTopHalf, horizonY);
    ctx.lineTo(W/2 - roadBottomHalf, H);
    ctx.moveTo(W/2 + roadTopHalf, horizonY);
    ctx.lineTo(W/2 + roadBottomHalf, H);
    ctx.stroke();

    // center dashed line (between lanes)
    ctx.strokeStyle = '#ffd463';
    ctx.lineWidth = 4;
    ctx.lineCap = 'round';
    const cycle = dashLenM + gapLenM;
    let z = Math.floor((worldZ % cycle)) * -1;
    for (; z < 1000; z += 4){
      const z0=z, z1=z+dashLenM;
      const p0 = project(Math.max(0,z0));
      const p1 = project(Math.max(0,z1));
      if (p0.y > H && p1.y > H) break;
      if (p1.y < horizonY) { z += gapLenM; continue; }
      ctx.beginPath();
      ctx.moveTo(W/2, p0.y);
      ctx.lineTo(W/2, p1.y);
      ctx.stroke();
      z += gapLenM;
    }
  }

  function drawSidePosts(){
    // tiny reflectors along edges
    ctx.fillStyle = 'rgba(120,200,255,.75)';
    const cycle = sidePostSpacingM;
    let z = Math.floor((worldZ % cycle)) * -1;
    for (; z < 1000; z += cycle){
      const p = project(Math.max(0,z));
      if (p.y > H) break;
      if (p.y < horizonY) continue;
      const r = Math.max(1.2, 3.6 * (1 - (p.y - horizonY)/(H - horizonY)));
      ctx.beginPath(); ctx.arc(W/2 - p.half - 6, p.y, r, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(W/2 + p.half + 6, p.y, r, 0, Math.PI*2); ctx.fill();
    }
  }

  function drawProps(){
    // mid/near urban props: shops, neon signs, lanterns, trees, lamps
    for (const o of props){
      // how far ahead from camera?
      const zAhead = o.z - worldZ;
      if (zAhead < 0 || zAhead > 1000) continue;
      const p = project(zAhead);
      if (p.y < horizonY || p.y > H) continue;

      const sideX = (o.side<0 ? -1 : 1);
      const roadEdgeX = W/2 + sideX * (p.half + 4);
      const t = p.t; // 0..1
      // scale up as it gets closer
      const scale = 0.30 + t*0.85;
      const w = o.width*scale, h = o.height*scale;
      const x = roadEdgeX + sideX*(8 + (1-t)*30) - (sideX<0?w:0);
      const y = p.y - h;

      // draw by kind
      if (o.kind==='shop'){
        // building block with glowing sign
        const bW = w*1.8, bH = h*1.6;
        ctx.fillStyle = '#0f1422';
        ctx.fillRect(x-(sideX<0?bW-w:0), y-h*0.3, bW, bH);
        // windows
        ctx.fillStyle = 'rgba(255,255,255,0.08)';
        for (let i=0;i<8;i++){
          ctx.fillRect(x-(sideX<0?bW-w:0)+6+(i*8% (bW-20)), y-h*0.3+8+((i*12)% (bH-20)), 3, 5);
        }
        // vertical neon sign
        const sx = x + (sideX<0?-w*0.6:bW*0.1);
        const sy = y - h*0.05;
        ctx.fillStyle = o.hue;
        ctx.fillRect(sx, sy, 10, h*0.9);
        ctx.fillStyle = o.hue+'33';
        ctx.fillRect(sx-4, sy, 4, h*0.9);
      } else if (o.kind==='sign'){
        // hanging rectangle sign with glow
        ctx.fillStyle = o.hue;
        ctx.fillRect(x, y, w, h*0.55);
        ctx.fillStyle = o.hue+'33';
        ctx.fillRect(x-4, y+2, w+8, h*0.55+4);
      } else if (o.kind==='lantern'){
        ctx.beginPath();
        ctx.ellipse(x+w*0.5, y+h*0.5, w*0.55, h*0.4, 0, 0, Math.PI*2);
        ctx.fillStyle = '#ff3b2f';
        ctx.fill();
        ctx.fillStyle = '#ff3b2f44';
        ctx.beginPath();
        ctx.ellipse(x+w*0.5, y+h*0.5, w*0.75, h*0.55, 0, 0, Math.PI*2);
        ctx.fill();
      } else if (o.kind==='tree'){
        // stylized street tree
        ctx.fillStyle = '#0c1a12';
        ctx.fillRect(x+w*0.45, y+h*0.6, w*0.1, h*0.5);
        ctx.beginPath();
        ctx.arc(x+w*0.5, y+h*0.5, Math.max(6,w*0.8), 0, Math.PI*2);
        ctx.fillStyle = '#1f5d3a';
        ctx.fill();
      } else if (o.kind==='lamp'){
        // street lamp with light cone
        ctx.fillStyle = '#aab0c0';
        ctx.fillRect(x+w*0.48, y+h*0.05, w*0.06, h*0.95);
        ctx.fillStyle = '#ffffaa';
        ctx.beginPath();
        ctx.moveTo(x+w*0.51, y+h*0.15);
        ctx.lineTo(x+w*0.51 - sideX*20*(1-t), y+h*0.45);
        ctx.lineTo(x+w*0.51 + sideX*20*(1-t), y+h*0.45);
        ctx.closePath();
        ctx.globalAlpha = 0.18; ctx.fill(); ctx.globalAlpha = 1;
      }
    }
  }

  function fogVignette(){
    // fog near horizon + bottom vignette
    const fog = ctx.createLinearGradient(0, horizonY-40, 0, horizonY+140);
    fog.addColorStop(0, 'rgba(180,200,220,0.12)');
    fog.addColorStop(1, 'rgba(180,200,220,0.00)');
    ctx.fillStyle = fog;
    ctx.fillRect(0, horizonY-40, W, 180);

    const vig = ctx.createLinearGradient(0, H*0.6, 0, H);
    vig.addColorStop(0, 'rgba(0,0,0,0.0)');
    vig.addColorStop(1, 'rgba(0,0,0,0.38)');
    ctx.fillStyle = vig;
    ctx.fillRect(0, H*0.6, W, H*0.4);
  }

  let laneOffsetBottom = 0; // computed in resize()
  function drawCar(){
    const sway = steer.x * 20;
    const carW = Math.min(W*0.58, 330);
    const carH = carW * carRatio;

    // road center at bottom:
    const roadCenterX = W/2;
    // place car in RIGHT lane, keep small wiggle from steer:
    const x = Math.round(roadCenterX + laneOffsetBottom + sway - carW/2);
    const y = Math.round(H*0.78 - carH*0.92);
    ctx.drawImage(carImg, x, y, Math.round(carW), Math.round(carH));
  }

  // --- State & loop ---
  const state = { running:false, speed:0, dist:0 }; // km/h
  let nitroLeft = 0;

  function drawFrame(dt){
    // world advance (km/h -> m/s)
    const mps = state.speed / 3.6;
    worldZ += mps * dt;
    state.dist += mps * dt;

    updateProps();

    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawBackground();
    drawRoad();
    drawSidePosts();
    drawProps();            // <- urban detail (Tokyo/Chinatown vibe)
    fogVignette();
    drawCar();

    HUD.speed.textContent = Math.round(state.speed);
    HUD.dist.textContent  = Math.round(state.dist);
    HUD.coins.textContent = 0;
  }

  let last = performance.now();
  function loop(now){
    if(!state.running) return;
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;

    const target = 180 + (nitroLeft>0 ? 120 : 0);
    state.speed += (target - state.speed) * 0.08;
    if (nitroLeft > 0) nitroLeft -= dt;

    drawFrame(dt);
    requestAnimationFrame(loop);
  }

  document.getElementById('nitroBtn').addEventListener('click', ()=>{ nitroLeft = 2.0; });

  document.getElementById('startBtn').addEventListener('click',()=>{
    document.getElementById('startOverlay').style.display='none';
    resize();
    state.running = true;
    state.speed = 60;
    state.dist = 0;
    worldZ = 0;
    last = performance.now();
    loop(last);
  });

  resize();
})();
</script>
</body>
</html>
