<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Street Race â€” IZZA GAME</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <script>window.IZZA_PERSIST_BASE='https://izzagame.onrender.com';</script>
  <script src="/static/game/js/izza-persist.js"></script>
  <link rel="stylesheet" href="/static/themes.css">
  <style>
    :root { --bg:#0a0c12; --panel:#06080e; }
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:#e8eef7;font-family:Arial,Helvetica,sans-serif}
    .arena{position:relative;height:100vh;max-width:520px;margin:0 auto;
      border-left:1px solid rgba(255,255,255,.08);
      border-right:1px solid rgba(255,255,255,.08);
      background:var(--panel);overflow:hidden}
    .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:8;
      background:linear-gradient(to bottom, rgba(0,0,0,.55), rgba(0,0,0,.35));}
    .card{background:rgba(0,0,0,.6);border:1px solid rgba(255,255,255,.18);border-radius:14px;
      padding:16px 18px;display:flex;flex-direction:column;gap:10px;width:min(92%,440px)}
    .preview{height:160px;border:1px dashed rgba(255,255,255,.18);border-radius:12px;
      display:flex;align-items:center;justify-content:center;overflow:hidden}
    .startBtn{padding:12px 16px;border-radius:10px;border:1px solid rgba(255,255,255,.1);
      background:rgba(255,255,255,.08);font-weight:800;color:white}
    .hud{position:absolute;top:8px;left:8px;right:8px;z-index:6;display:flex;justify-content:space-between;font-size:12px}
    .nitroBtn{position:absolute;right:10px;bottom:14px;z-index:7;border-radius:999px;
      border:1px solid rgba(255,255,255,.1);background:#222;padding:10px 14px;font-weight:800;color:white}
    canvas{display:block;width:100%;height:100%}
  </style>
</head>
<body>
  <div class="arena" id="arena">
    <!-- HUD -->
    <div class="hud">
      <div>SPEED: <span id="speed">0</span> km/h</div>
      <div>DIST: <span id="dist">0</span> m</div>
      <div>COINS: <span id="coinsRun">0</span></div>
    </div>

    <!-- Garage Overlay -->
    <div id="startOverlay" class="overlay">
      <div class="card">
        <h3>Street Race</h3>
        <div class="preview">
          <img id="garageCar" src="/static/game/sprites/tracks/coupe.png" alt="Car preview" style="height:100%"/>
        </div>
        <button id="startBtn" class="startBtn">START</button>
      </div>
    </div>

    <button class="nitroBtn" id="nitroBtn">NITRO</button>
    <canvas id="scene"></canvas>
  </div>

<script>
(function(){
  const arena  = document.getElementById('arena');
  const canvas = document.getElementById('scene');
  const ctx    = canvas.getContext('2d', { alpha:true });
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = 'high';

  const HUD = {
    speed: document.getElementById('speed'),
    dist : document.getElementById('dist'),
    coins: document.getElementById('coinsRun')
  };

  // --- DPR sizing ---
  let dpr=1, W=0, H=0;
  function resize(){
    W = arena.clientWidth;
    H = arena.clientHeight;
    dpr = Math.min(window.devicePixelRatio || 1, 2);
    canvas.width  = Math.floor(W * dpr);
    canvas.height = Math.floor(H * dpr);
    canvas.style.width  = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
    // recompute perspective params that depend on size
    horizonY = H*0.22;
    roadBottomHalf = W*0.44;
    roadTopHalf = W*0.10;
  }
  window.addEventListener('resize', resize, {passive:true});

  // --- Assets ---
  const carImg = new Image();
  carImg.src = '/static/game/sprites/tracks/coupe.png';
  let carRatio = 0.5;
  carImg.onload = ()=>{ carRatio = carImg.height / carImg.width; };

  // --- Input (tap left/right half; arrow keys) ---
  const steer = { x:0 };
  function onPointer(e){
    const r = canvas.getBoundingClientRect();
    const x = (e.touches ? e.touches[0].clientX : e.clientX) - r.left;
    steer.x = (x < r.width/2) ? -1 : 1;
  }
  function stopPointer(){ steer.x = 0; }
  canvas.addEventListener('pointerdown', onPointer);
  canvas.addEventListener('pointermove', onPointer);
  window.addEventListener('pointerup', stopPointer);
  window.addEventListener('keydown', e=>{
    if(e.key==='ArrowLeft') steer.x=-1;
    if(e.key==='ArrowRight') steer.x=1;
  });
  window.addEventListener('keyup', e=>{
    if(e.key==='ArrowLeft'||e.key==='ArrowRight') steer.x=0;
  });

  // --- Procedural road params ---
  // These are in screen space; we just recompute on resize.
  let horizonY        = 0;   // y position of horizon
  let roadBottomHalf  = 0;   // half width of road at the bottom of the screen
  let roadTopHalf     = 0;   // half width of road at the horizon
  const centerLineColor = '#ffd463';
  const sideLineColor   = 'rgba(230,235,245,0.9)';
  const shoulderColor   = '#0d121b';
  const asphaltTop      = '#151b24';
  const asphaltBot      = '#0e131b';

  // Scrolling world distance (meters) and conversion to visual dash speed
  let worldZ = 0;                // meters advanced since start
  const dashLenM = 9;            // length of a center dash segment (m)
  const gapLenM  = 9;            // gap between dashes (m)
  const sidePostSpacingM = 18;   // side reflectors spacing

  // helper: linear interpolate
  const lerp = (a,b,t)=>a+(b-a)*t;

  // Given a depth z (meters from camera), get the screen y and half road width
  function project(z){
    // simple perspective: y grows nonlinearly with depth; tweak k for feel
    const k = 0.012; // perspective strength
    const t = 1 - Math.exp(-k*z); // 0..1 mapping of depth to screen
    const y = lerp(horizonY, H, t);
    const half = lerp(roadTopHalf, roadBottomHalf, t);
    return { y, half };
  }

  function drawBackgroundGradient(){
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, '#0e1320');
    g.addColorStop(0.22, '#0e1623');
    g.addColorStop(0.5, '#0b1018');
    g.addColorStop(1, '#090d14');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);
  }

  function drawRoad(){
    // road polygon
    ctx.beginPath();
    ctx.moveTo(W/2 - roadTopHalf, horizonY);
    ctx.lineTo(W/2 + roadTopHalf, horizonY);
    ctx.lineTo(W/2 + roadBottomHalf, H);
    ctx.lineTo(W/2 - roadBottomHalf, H);
    ctx.closePath();

    // asphalt with vertical gradient
    const g = ctx.createLinearGradient(0,horizonY,0,H);
    g.addColorStop(0, asphaltTop);
    g.addColorStop(1, asphaltBot);
    ctx.fillStyle = g;
    ctx.fill();

    // subtle shoulder outside the white side lines
    ctx.save();
    ctx.globalCompositeOperation = 'destination-over';
    ctx.fillStyle = shoulderColor;
    ctx.fillRect(0,horizonY,W,H-horizonY);
    ctx.restore();

    // side lines (white)
    ctx.lineWidth = 2;
    ctx.strokeStyle = sideLineColor;
    ctx.beginPath();
    ctx.moveTo(W/2 - roadTopHalf, horizonY);
    ctx.lineTo(W/2 - roadBottomHalf, H);
    ctx.moveTo(W/2 + roadTopHalf, horizonY);
    ctx.lineTo(W/2 + roadBottomHalf, H);
    ctx.stroke();
  }

  function drawCenterDashes(){
    // We draw many segments along depth, clipping at screen edges
    ctx.strokeStyle = centerLineColor;
    ctx.lineWidth = 4;
    ctx.lineCap = 'round';

    // start depth so dashes wrap nicely with worldZ
    const cycle = dashLenM + gapLenM;
    let z = Math.floor((worldZ % cycle)) * -1; // start a bit before camera

    // step in meters
    for (; z < 1000; z += 4){ // large enough depth
      const z0 = z;
      const z1 = z + dashLenM;
      const p0 = project(Math.max(0, z0));
      const p1 = project(Math.max(0, z1));

      // keep inside screen
      if (p0.y > H && p1.y > H) break;
      if (p1.y < horizonY) continue;

      ctx.beginPath();
      ctx.moveTo(W/2, p0.y);
      ctx.lineTo(W/2, p1.y);
      ctx.stroke();
      z += gapLenM; // skip the gap
    }
  }

  function drawSidePosts(){
    // Little blue reflectors along each side for motion cues
    ctx.fillStyle = 'rgba(120,200,255,.75)';
    const cycle = sidePostSpacingM;
    let z = Math.floor((worldZ % cycle)) * -1;

    for (; z < 1000; z += cycle){
      const p = project(Math.max(0, z));
      if (p.y > H) break;
      if (p.y < horizonY) continue;
      const r = Math.max(1.2, 3.6 * (1 - (p.y - horizonY)/(H - horizonY))); // size tapers
      ctx.beginPath();
      ctx.arc(W/2 - p.half - 6, p.y, r, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(W/2 + p.half + 6, p.y, r, 0, Math.PI*2);
      ctx.fill();
    }
  }

  function drawFogVignette(){
    // soft fog near horizon and dark vignette bottom
    const fog = ctx.createLinearGradient(0, horizonY-40, 0, horizonY+120);
    fog.addColorStop(0, 'rgba(180,200,220,0.12)');
    fog.addColorStop(1, 'rgba(180,200,220,0.00)');
    ctx.fillStyle = fog;
    ctx.fillRect(0, horizonY-40, W, 160);

    const vig = ctx.createLinearGradient(0, H*0.6, 0, H);
    vig.addColorStop(0, 'rgba(0,0,0,0.0)');
    vig.addColorStop(1, 'rgba(0,0,0,0.35)');
    ctx.fillStyle = vig;
    ctx.fillRect(0, H*0.6, W, H*0.4);
  }

  function drawCar(){
    const sway = steer.x * 22;
    const carW = Math.min(W*0.62, 340);
    const carH = carW * carRatio;
    const x = Math.round((W - carW)/2 + sway);
    const y = Math.round(H*0.78 - carH*0.92);
    ctx.drawImage(carImg, x, y, Math.round(carW), Math.round(carH));
  }

  // --- State & loop ---
  const state = { running:false, speed:0, dist:0 }; // speed in km/h

  function drawFrame(dt){
    // world advance (convert km/h -> m/s)
    const mps = state.speed / 3.6;
    worldZ += mps * dt;
    state.dist += mps * dt;

    // paint scene
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawBackgroundGradient();
    drawRoad();
    drawCenterDashes();
    drawSidePosts();
    drawFogVignette();
    drawCar();

    HUD.speed.textContent = Math.round(state.speed);
    HUD.dist.textContent  = Math.round(state.dist);
    HUD.coins.textContent = 0;
  }

  let last = performance.now();
  function loop(now){
    if(!state.running) return;
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;

    // ease to cruise speed (press nitro to bump temporarily)
    const target = 180 + (nitroLeft>0 ? 120 : 0);
    state.speed += (target - state.speed) * 0.08;

    if (nitroLeft > 0) nitroLeft -= dt;

    drawFrame(dt);
    requestAnimationFrame(loop);
  }

  // Nitro (optional glow only for now)
  let nitroLeft = 0;
  document.getElementById('nitroBtn').addEventListener('click', ()=>{ nitroLeft = 2.0; });

  // Start
  document.getElementById('startBtn').addEventListener('click',()=>{
    document.getElementById('startOverlay').style.display='none';
    resize();
    state.running = true;
    state.speed = 60;
    state.dist = 0;
    worldZ = 0;
    last = performance.now();
    loop(last);
  });

  resize();
})();
</script>
</body>
</html>
