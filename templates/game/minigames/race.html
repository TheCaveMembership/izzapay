<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Street Race ‚Äî IZZA GAME</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <script>window.IZZA_PERSIST_BASE='https://izzagame.onrender.com';</script>
  <script src="/static/game/js/izza-persist.js"></script>
  <link rel="stylesheet" href="/static/themes.css">
  <style>
    :root { --bg:#0a0c12; --panel:#06080e; }
    html,body{height:100%}
    body{
      margin:0;background:var(--bg);color:#e8eef7;font-family:Arial,Helvetica,sans-serif;
      -webkit-user-select:none; user-select:none; -webkit-touch-callout:none;
    }
    .arena{position:relative;height:100vh;max-width:520px;margin:0 auto;
      border-left:1px solid rgba(255,255,255,.08);
      border-right:1px solid rgba(255,255,255,.08);
      background:var(--panel);overflow:hidden}
    .hud{position:absolute;top:10px;left:12px;right:12px;z-index:9;
      display:flex;justify-content:space-between;font-size:13px;letter-spacing:.3px}
    .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:8;
      background:linear-gradient(to bottom, rgba(0,0,0,.7), rgba(0,0,0,.55));}
    .card{background:rgba(10,12,18,.95);border:1px solid rgba(255,255,255,.16);border-radius:14px;
      padding:16px 18px;display:flex;flex-direction:column;gap:12px;width:min(92%,460px)}
    .row{display:flex;gap:10px;align-items:center;justify-content:space-between}
    .preview{height:164px;border:1px dashed rgba(255,255,255,.18);border-radius:12px;
      display:flex;align-items:center;justify-content:center;overflow:hidden}
    .startBtn{padding:12px 16px;border-radius:10px;border:1px solid rgba(255,255,255,.1);
      background:rgba(255,255,255,.08);font-weight:800;color:white;width:100%}
    .swatches{display:flex;gap:10px;flex-wrap:wrap}
    .swatch{width:26px;height:26px;border-radius:50%;border:2px solid rgba(255,255,255,.28);cursor:pointer}
    .swatch.active{box-shadow:0 0 0 3px rgba(255,255,255,.18) inset}
    canvas{display:block;width:100%;height:100%;background:transparent;touch-action:none;
      -webkit-user-select:none; user-select:none; -webkit-touch-callout:none;}

    /* Nitro meter */
    .nitroWrap{position:absolute;right:12px;bottom:16px;z-index:7;width:120px;height:40px;
      border-radius:999px;border:1px solid rgba(255,255,255,.12);background:#121a2b;overflow:hidden;
      display:flex;align-items:center;justify-content:center;font-weight:800;color:#e8eef7}
    .nitroFill{position:absolute;left:2px;top:2px;bottom:2px;border-radius:999px;
      background:linear-gradient(180deg,#53ffb2,#1ecb7b);width:100%;}
    .nitroLabel{position:relative;z-index:1;pointer-events:none}

    /* Sound toggle */
    .soundBtn{position:absolute;right:12px;top:44px;z-index:9;display:flex;align-items:center;gap:8px;
      background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.12);color:#e8eef7;
      border-radius:999px;padding:8px 12px;font-size:12px;cursor:pointer;user-select:none}
    .dot{width:10px;height:10px;border-radius:50%;background:#40ff8a;box-shadow:0 0 6px #40ff8a;}
    .soundBtn.muted .dot{background:#ff4b4b;box-shadow:0 0 6px #ff4b4b;}
  </style>
</head>
<body>
  <div class="arena" id="arena">
    <div class="hud">
      <div>SPEED: <span id="speed">0</span> km/h</div>
      <div>DIST: <span id="dist">0</span> m</div>
      <div>COINS: <span id="coinsRun">0</span></div>
    </div>

    <!-- Sound toggle -->
    <div id="soundBtn" class="soundBtn"><span class="dot"></span><span id="soundLabel">SOUND ON</span></div>

    <!-- Garage -->
    <div id="startOverlay" class="overlay">
      <div class="card">
        <h3 style="margin:0">Garage</h3>
        <div class="row" style="opacity:.9;font-size:12px">
          Coins: <b id="wCoins">‚Äî</b> &nbsp; | &nbsp; Crafting: <b id="wCraft">‚Äî</b>
        </div>
        <div class="preview">
          <canvas id="garagePreview" width="512" height="256"></canvas>
        </div>
        <div>
          <div style="font-size:12px;margin:6px 0 8px">Paint (tint)</div>
          <div class="swatches" id="swatches"></div>
        </div>
        <button id="startBtn" class="startBtn">START</button>
      </div>
    </div>

    <!-- Nitro meter -->
    <div class="nitroWrap" id="nitroWrap" title="Hold to boost">
      <div class="nitroFill" id="nitroFill" style="width:100%"></div>
      <div class="nitroLabel">NITRO</div>
    </div>

    <!-- Background music -->
    <audio id="bgm" src="/static/game/audio/RACEBGM.wav" loop preload="auto"></audio>

    <canvas id="scene"></canvas>
  </div>

<script>
(() => {
/* ====== hard-block selection/callouts while playing ====== */
['contextmenu','selectstart','gesturestart'].forEach(ev=>{
  window.addEventListener(ev, e=>e.preventDefault(), {passive:false});
});

/* ============== Wallet ============== */
async function loadWallet(){
  let coins='‚Äî', craft='‚Äî';
  try{
    if (window.IZZA && typeof IZZA.get === 'function') {
      const w = await IZZA.get('wallet');
      if (w) { coins = w.coins ?? coins; craft = w.crafting ?? craft; }
    } else if (localStorage.getItem('izza_wallet')){
      const w = JSON.parse(localStorage.getItem('izza_wallet'));
      coins = w.coins ?? coins; craft = w.crafting ?? craft;
    }
  }catch(e){}
  document.getElementById('wCoins').textContent = coins;
  document.getElementById('wCraft').textContent = craft;
}
loadWallet();

/* ============== Setup ============== */
const arena  = document.getElementById('arena');
const canvas = document.getElementById('scene');
const ctx    = canvas.getContext('2d', { alpha:true });
ctx.imageSmoothingEnabled = true;
ctx.imageSmoothingQuality = 'high';

const HUD = {
  speed: document.getElementById('speed'),
  dist : document.getElementById('dist'),
  coins: document.getElementById('coinsRun')
};
const nitroWrap = document.getElementById('nitroWrap');
const nitroFill = document.getElementById('nitroFill');
const bgm = document.getElementById('bgm');
const soundBtn = document.getElementById('soundBtn');
const soundLabel = document.getElementById('soundLabel');

/* ======= Tunables ======= */
const OVERLAY_ALPHA = 0.10;

// Aurora + horizon glow
let AURORA_ALPHA  = 0.16, AURORA_SPEED = 0.06, AURORA_WOBBLE = 18;
let GLOW_ALPHA    = 0.26;

// Motion boosters (existing)
let STREAK_ALPHA  = 0.55;
let STREAK_SPEED  = 1.45;
let SMEAR_ALPHA   = 0.62;
let ASPHALT_ALPHA = 0.36;

// Hyperloop multipliers
const HYPER = { streaks:1.8, smear:1.6, asphalt:1.7, auroraW:1.6, zoom:1.07 };

/* ============== Sizing / Camera ============== */
let dpr=1, W=0, H=0;
let VANISH_Y = -800;
let TOP_FADE_PX=90;
/* Car-anchored vanishing-point X stays intact */
let VPT_X=0, VPT_Y=0;
let roadBottomHalf=0, roadTopHalf=0;

function resize(){
  W = arena.clientWidth;
  H = arena.clientHeight;
  dpr = Math.min(window.devicePixelRatio || 1, 2);
  canvas.width  = Math.floor(W * dpr);
  canvas.height = Math.floor(H * dpr);
  canvas.style.width  = W + 'px';
  canvas.style.height = H + 'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);

  roadBottomHalf = W*1.02;
  roadTopHalf    = W*0.10;

  VANISH_Y = -Math.max(H * 0.8, 600);
  TOP_FADE_PX  = Math.max(60, Math.min(110, Math.round(H*0.10)));

  VPT_Y = H*0.62;

  buildNoise();
  updateCarPlacement();
}
window.addEventListener('resize', resize, {passive:true});

/* ============== Assets ============== */
const carImg = new Image();
carImg.src = '/static/game/sprites/tracks/coupe.png';
const bgImg = new Image();
bgImg.src = '/static/game/sprites/road_bg.jpg';

/* Tinted sprite for garage preview */
function makeTintedSprite(rgb){
  if (!carImg.complete || !carImg.width) return null;
  const off = document.createElement('canvas');
  off.width  = carImg.width;
  off.height = carImg.height;
  const o = off.getContext('2d');
  o.drawImage(carImg, 0, 0);
  o.globalCompositeOperation = 'multiply';
  o.fillStyle = `rgb(${rgb.r},${rgb.g},${rgb.b})`;
  o.fillRect(0,0,off.width,off.height);
  o.globalCompositeOperation = 'destination-in';
  o.drawImage(carImg, 0, 0);
  o.globalCompositeOperation = 'source-atop';
  o.fillStyle = 'rgba(255,255,255,0.08)';
  o.fillRect(0,0,off.width,off.height);
  o.globalCompositeOperation = 'source-over';
  return off;
}

/* ============== Garage Paint ============== */
const PAINTS = [
  {name:'Cherry',    r:255, g:70,  b:70 },
  {name:'Sunburst',  r:255, g:190, b:40 },
  {name:'Neo Blue',  r:90,  g:180, b:255},
  {name:'Lime',      r:120, g:230, b:90 },
  {name:'Violet',    r:170, g:120, b:255},
  {name:'Graphite',  r:185, g:195, b:205}
];
let paint = JSON.parse(localStorage.getItem('izza_paint')||'null') || PAINTS[0];
let tintedSprite = null;

const swatches = document.getElementById('swatches');
PAINTS.forEach(p=>{
  const d = document.createElement('div');
  d.className = 'swatch';
  d.style.background = `rgb(${p.r},${p.g},${p.b})`;
  if (p.name===paint.name) d.classList.add('active');
  d.title = p.name;
  d.onclick = ()=>{
    paint = p;
    localStorage.setItem('izza_paint', JSON.stringify(paint));
    [...swatches.children].forEach(x=>x.classList.remove('active'));
    d.classList.add('active');
    rebuildTintAndPreview();
  };
  swatches.appendChild(d);
});
const prev = document.getElementById('garagePreview');
const pctx = prev.getContext('2d');
function rebuildTintAndPreview(){
  tintedSprite = makeTintedSprite(paint);
  if (!tintedSprite) return;
  pctx.clearRect(0,0,prev.width,prev.height);
  const pad = 8;
  const availW = prev.width - pad*2;
  const scale  = Math.min(availW / carImg.width, (prev.height-pad*2) / carImg.height);
  const w = Math.round(carImg.width * scale);
  const h = Math.round(carImg.height * scale);
  const x = Math.round((prev.width - w)/2);
  const y = Math.round((prev.height - h)/2);
  const cx = x + w/2, cy = y + h*0.92, rx = w*0.42, ry = h*0.10;
  const g = pctx.createRadialGradient(cx,cy,1,cx,cy,Math.max(rx,ry));
  g.addColorStop(0, `rgba(${paint.r},${paint.g},${paint.b},.22)`);
  g.addColorStop(1, `rgba(${paint.r},${paint.g},${paint.b},0)`);
  pctx.fillStyle = g;
  pctx.beginPath(); pctx.ellipse(cx,cy,rx,ry,0,0,Math.PI*2); pctx.fill();
  pctx.drawImage(tintedSprite, x, y, w, h);
}
carImg.onload = rebuildTintAndPreview;

/* ============== Projection helpers ============== */
const lerp = (a,b,t)=>a+(b-a)*t;
function project(z){
  const k = 0.0105;
  const t = 1 - Math.exp(-k*z);
  const y   = lerp(VANISH_Y, H, t);
  const half= lerp(roadTopHalf, roadBottomHalf, t);
  return { y, half, t };
}

/* ======= Road params ======= */
const DEPTH_Z=24000, STEP_Z=48, RAIL_SCALE=1.08;
function edgesAt(z){
  const p = project(z);
  const y = Math.max(p.y, VANISH_Y);
  const half = (y === VANISH_Y) ? 0.0001 : p.half;
  return { y, lx: W/2 - half*RAIL_SCALE - 8, rx: W/2 + half*RAIL_SCALE + 8, t:p.t };
}

/* ============== Background (parallax) ============== */
let bgParallaxX = 0, bgTarget = 0;
function drawBackground(zoom=1){
  const carCenter = (carX + carW/2) / W;
  bgTarget = (carCenter - 0.5) * 28;
  bgParallaxX += (bgTarget - bgParallaxX) * 0.08;

  if (bgImg.complete && bgImg.naturalWidth) {
    const iw = bgImg.naturalWidth, ih = bgImg.naturalHeight;
    const r  = Math.max(W/iw, H/ih) * zoom;
    const nw = iw*r, nh = ih*r;
    const x  = (W - nw) / 2 + bgParallaxX;
    const y  = (H - nh) / 2;
    ctx.drawImage(bgImg, x, y, nw, nh);
  } else {
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, '#0c1120'); g.addColorStop(1, '#090d14');
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
  }
}

/* ---------- Aurora + horizon glow ---------- */
function drawAurora(t, hyperFactor=1){
  const topH = H*0.42;
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  ctx.globalAlpha = AURORA_ALPHA;
  const wob = AURORA_WOBBLE * (hyperFactor>1 ? HYPER.auroraW : 1);
  for (let i=0;i<3;i++){
    const phase = t*AURORA_SPEED*(i+1)*hyperFactor;
    const sway  = Math.sin(phase)*wob*(i?0.6:1);
    const gx = VPT_X + sway; /* follow car center */
    const gy0 = 0, gy1 = topH;
    const g = ctx.createLinearGradient(gx, gy0, gx, gy1);
    g.addColorStop(0.00, 'rgba(0,255,255,0.55)');
    g.addColorStop(0.35, 'rgba(0,180,220,0.25)');
    g.addColorStop(1.00, 'rgba(0,120,180,0.00)');
    ctx.fillStyle = g;
    const w = W*0.32*(i?0.7:1);
    ctx.beginPath();
    ctx.moveTo(gx-w, gy0);
    ctx.lineTo(gx+w, gy0);
    ctx.lineTo(gx+w*0.7, gy1);
    ctx.lineTo(gx-w*0.7, gy1);
    ctx.closePath();
    ctx.fill();
  }
  ctx.restore();
}
function drawVanishingGlow(t, heat){
  const rBase = Math.min(W,H)*0.070;
  const pulse = 1 + 0.06*Math.sin(t*3.2);
  const r2 = rBase*(4.8 + heat*1.0)*pulse;
  const g = ctx.createRadialGradient(VPT_X, VPT_Y, 1, VPT_X, VPT_Y, r2);
  g.addColorStop(0,   `rgba(0,255,255,${0.70+0.25*heat})`);
  g.addColorStop(0.4, `rgba(0,200,255,${0.30+0.20*heat})`);
  g.addColorStop(1,   'rgba(0,200,255,0.00)');
  ctx.save();
  ctx.globalCompositeOperation = 'screen';
  ctx.globalAlpha = GLOW_ALPHA;
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.arc(VPT_X, VPT_Y, r2, 0, Math.PI*2); ctx.fill();
  ctx.restore();
}

/* Asphalt noise layer (scrolling) */
let noiseCanvas=null, noiseCtx=null, noiseW=512, noiseH=512;
function buildNoise(){
  noiseCanvas = document.createElement('canvas');
  noiseCanvas.width = noiseW; noiseCanvas.height = noiseH;
  noiseCtx = noiseCanvas.getContext('2d');

  // subtle diagonal grains for asphalt scroll
  noiseCtx.clearRect(0,0,noiseW,noiseH);
  noiseCtx.fillStyle = 'rgba(255,255,255,0.02)';
  noiseCtx.fillRect(0,0,noiseW,noiseH);
  const g = noiseCtx.createLinearGradient(0,0,noiseW,noiseH);
  g.addColorStop(0,'rgba(255,255,255,0.10)');
  g.addColorStop(1,'rgba(255,255,255,0.00)');
  noiseCtx.strokeStyle = g;
  for(let i=0;i<160;i++){
    const y = Math.random()*noiseH;
    noiseCtx.globalAlpha = 0.08 + Math.random()*0.10;
    noiseCtx.lineWidth = 1 + Math.random()*2;
    noiseCtx.beginPath();
    noiseCtx.moveTo(0,y);
    noiseCtx.lineTo(noiseW, y - 30 - Math.random()*60);
    noiseCtx.stroke();
  }
}

/* ======== NEW: Single-lane SPEED GRID (independent of car lighting) ======== */
function drawSpeedGrid(worldZ, speed, hyper=false){
  // Strength & color
  const baseAlpha = hyper ? 0.75 : 0.55;
  const edgeColor = `rgba(170,210,255,${baseAlpha})`;
  const centerColor = `rgba(200,255,255,${baseAlpha*0.55})`;

  // ----- Edges path (two converging dashed lines) -----
  ctx.save();
  ctx.lineWidth = 1.4;
  ctx.setLineDash([6,10]);                        // short dashes
  const dashShift = -(worldZ * (0.045 + speed/6000)); // scroll rate by speed

  // Left edge path
  ctx.strokeStyle = edgeColor;
  ctx.lineDashOffset = dashShift;
  ctx.beginPath();
  let started=false;
  for (let z=0; z<=DEPTH_Z; z+=STEP_Z){
    const e = edgesAt(z);
    if (!started){ ctx.moveTo(e.lx, Math.min(e.y,H)); started=true; }
    else ctx.lineTo(e.lx, Math.min(e.y,H));
    if (e.y>H) break;
  }
  ctx.stroke();

  // Right edge path
  ctx.beginPath();
  started=false;
  for (let z=0; z<=DEPTH_Z; z+=STEP_Z){
    const e = edgesAt(z);
    if (!started){ ctx.moveTo(e.rx, Math.min(e.y,H)); started=true; }
    else ctx.lineTo(e.rx, Math.min(e.y,H));
    if (e.y>H) break;
  }
  ctx.stroke();

  // Center guide
  ctx.strokeStyle = centerColor;
  ctx.lineWidth = 1.1;
  ctx.setLineDash([5,12]);
  ctx.lineDashOffset = dashShift*1.1;
  ctx.beginPath();
  for (let z=0; z<=DEPTH_Z; z+=STEP_Z){
    const e = edgesAt(z);
    const cx = (e.lx+e.rx)/2;
    if (z===0) ctx.moveTo(cx, Math.min(e.y,H));
    else ctx.lineTo(cx, Math.min(e.y,H));
    if (e.y>H) break;
  }
  ctx.stroke();

  // ----- Perspective rungs (thin arcs widening toward camera) -----
  const rungStep = 260;                 // distance between rungs
  const rungOffset = worldZ % rungStep; // makes them flow
  ctx.setLineDash([]);                  // solid
  for (let z=rungStep - rungOffset; z<=DEPTH_Z; z+=rungStep){
    const e = edgesAt(z);
    if (e.y < VPT_Y + H*0.02) continue; // keep below horizon for clarity
    const wL = e.lx, wR = e.rx;
    const alpha = Math.min(1, e.t*1.4) * (hyper ? 0.28 : 0.20);
    ctx.strokeStyle = `rgba(160,200,255,${alpha})`;
    ctx.lineWidth = 0.9 + e.t*1.2;
    // gentle arc toward the vanishing point
    ctx.beginPath();
    ctx.moveTo(wL + (wR-wL)*0.18, e.y);
    ctx.quadraticCurveTo(VPT_X, e.y - 10 - 90*(1-e.t), wR - (wR-wL)*0.18, e.y);
    ctx.stroke();
    if (e.y>H) break;
  }
  ctx.restore();
}

/* ===== Motion streaks + side smears + asphalt scroll + tire beams ===== */
function drawMotion(worldZ, speed, hyper=false, heat=0){
  const hyperK = hyper ? HYPER : {streaks:1, smear:1, asphalt:1};
  const k = Math.min(1, (speed/240)) * STREAK_SPEED;

  // radial streaks from car center (EXISTING ‚Äî untouched)
  const count = Math.round((hyper?58:42) * hyperK.streaks * (1+0.5*heat));
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  ctx.globalAlpha = STREAK_ALPHA*(hyper?1.08:1);
  for (let i=0;i<count;i++){
    const ang = (-0.52 + i/(count-1)*1.04);
    const len = H*(hyper?1.38:1.18);
    const wob = Math.sin((worldZ*0.033)+i)*10*(hyper?1.6:1);
    const x2 = VPT_X + Math.tan(ang)*(len*0.82) + wob;
    const y2 = H + 36;
    const grad = ctx.createLinearGradient(VPT_X, VPT_Y, x2, y2);
    const base = (i%2===0)? 'rgba(0,255,255,' : 'rgba(255,0,200,';
    grad.addColorStop(0.00, base + (0.75*k) + ')');
    grad.addColorStop(0.20, base + (0.45*k) + ')');
    grad.addColorStop(1.00, base + '0)');
    ctx.strokeStyle = grad;
    ctx.lineWidth = 2 + 14*k*(hyper?1.55:1.1);
    ctx.beginPath(); ctx.moveTo(VPT_X, VPT_Y); ctx.lineTo(x2, y2); ctx.stroke();
  }
  ctx.restore();

  // side smears
  const smearW = W*(hyper?0.46:0.38);
  const smearAlpha = (0.16 + SMEAR_ALPHA*0.9*k) * hyperK.smear * (1+0.25*heat);
  const smearG_L = ctx.createLinearGradient(0,0,smearW,0);
  smearG_L.addColorStop(0,   `rgba(0,0,0,${smearAlpha})`);
  smearG_L.addColorStop(1.0, 'rgba(0,0,0,0)');
  const smearG_R = ctx.createLinearGradient(W,0,W-smearW,0);
  smearG_R.addColorStop(0,   `rgba(0,0,0,${smearAlpha})`);
  smearG_R.addColorStop(1.0, 'rgba(0,0,0,0)');
  ctx.fillStyle = smearG_L; ctx.fillRect(0,0,smearW,H);
  ctx.fillStyle = smearG_R; ctx.fillRect(W-smearW,0,smearW,H);

  // road polygon clip
  const L=[], R=[];
  for (let z=0; z<=DEPTH_Z; z+=STEP_Z){ const e=edgesAt(z); L.push([e.lx,e.y]); R.push([e.rx,e.y]); }
  ctx.save();
  ctx.beginPath(); ctx.moveTo(W/2, VANISH_Y);
  for(let i=R.length-1;i>=0;i--) ctx.lineTo(R[i][0], Math.min(R[i][1],H));
  for(let i=0;i<L.length;i++)    ctx.lineTo(L[i][0], Math.min(L[i][1],H));
  ctx.closePath(); 
  ctx.clip();

  // perspective asphalt scroll
  const kspd = (2.0 + k*1.7) * hyperK.asphalt;
  const scroll = (worldZ * kspd) % noiseH;
  for(let y=-noiseH; y<H+noiseH; y+=noiseH){
    const near = Math.min(1, Math.max(0, (y+noiseH - VPT_Y) / (H - VPT_Y + 1)));
    ctx.globalAlpha = ASPHALT_ALPHA * (0.35 + 0.65*near) * (hyper?1.25:1);
    ctx.drawImage(noiseCanvas, 0, y + scroll, W, noiseH);
  }

  // tire glow beams (EXISTING ‚Äî untouched)
  const tireL = carX + carW*0.27;
  const tireR = carX + carW*0.73;
  const baseY = H*0.86;
  const laneHeight = H*(hyper?0.30:0.24);
  ctx.globalAlpha = 0.26 + 0.28*k*(hyper?1.2:1);
  ctx.globalCompositeOperation = 'lighter';
  const lane = (x)=>{
    const gg = ctx.createLinearGradient(x, baseY, x, baseY+laneHeight);
    gg.addColorStop(0,'rgba(0,255,255,0.00)');
    gg.addColorStop(0.25,`rgba(0,255,255,${0.30+0.32*k})`);
    gg.addColorStop(1,'rgba(0,255,255,0.00)');
    ctx.fillStyle = gg;
    ctx.beginPath();
    ctx.ellipse(x, baseY+laneHeight*0.55, W*0.070, laneHeight*0.58, 0, 0, Math.PI*2);
    ctx.fill();
  };
  lane(tireL); lane(tireR);
  ctx.restore();

  // hyperloop vignette
  ctx.save();
  const inner = Math.min(W,H)*0.10;
  const outer = Math.max(W,H)*(hyper?0.78:0.66)*(1-0.10*heat);
  const vg = ctx.createRadialGradient(VPT_X, VPT_Y, inner, VPT_X, VPT_Y, outer);
  vg.addColorStop(0,'rgba(0,0,0,0)');
  vg.addColorStop(1,`rgba(0,0,0,${hyper? (0.40+0.12*heat) : 0.20})`);
  ctx.fillStyle = vg;
  ctx.fillRect(0,0,W,H);
  ctx.restore();
}

/* ======= Headlights (attached to car) ======= */
function drawHeadlights(){
  const leftRoot  = { x: carX + carW*0.32, y: carY + carH*0.74 };
  const rightRoot = { x: carX + carW*0.68, y: carY + carH*0.74 };
  const aim = { x: VPT_X, y: VPT_Y - 12 }; // aim moves with car center

  const drawBeam = (root, spread)=> {
    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    const gx = ctx.createLinearGradient(root.x, root.y, aim.x, aim.y);
    gx.addColorStop(0, 'rgba(120,220,255,0.55)');
    gx.addColorStop(0.25,'rgba(80,200,255,0.28)');
    gx.addColorStop(1, 'rgba(80,200,255,0.00)');
    ctx.fillStyle = gx;
    ctx.beginPath();
    ctx.moveTo(root.x - spread, root.y);
    ctx.lineTo(root.x + spread, root.y);
    ctx.lineTo(aim.x + spread*0.35, aim.y);
    ctx.lineTo(aim.x - spread*0.35, aim.y);
    ctx.closePath(); ctx.fill();

    const gy = ctx.createLinearGradient(root.x, root.y, aim.x, aim.y);
    gy.addColorStop(0, 'rgba(180,255,255,0.90)');
    gy.addColorStop(0.2,'rgba(120,240,255,0.50)');
    gy.addColorStop(1, 'rgba(120,240,255,0.00)');
    ctx.fillStyle = gy;
    ctx.beginPath();
    ctx.moveTo(root.x - spread*0.45, root.y);
    ctx.lineTo(root.x + spread*0.45, root.y);
    ctx.lineTo(aim.x + spread*0.22, aim.y);
    ctx.lineTo(aim.x - spread*0.22, aim.y);
    ctx.closePath(); ctx.fill();
    ctx.restore();
  };

  const baseSpread = Math.max(10, carW*0.06);
  drawBeam(leftRoot,  baseSpread);
  drawBeam(rightRoot, baseSpread);
}

/* ======= Road overlay shading ======= */
function drawRoad(){
  const L=[], R=[];
  for (let z=0; z<=DEPTH_Z; z+=STEP_Z){
    const e = edgesAt(z);
    if (e.y>H && L.length && R.length) break;
    L.push([e.lx, e.y]); R.push([e.rx, e.y]);
  }
  ctx.save();
  ctx.beginPath();
  ctx.moveTo(W/2, VANISH_Y);
  for (let i=R.length-1;i>=0;i--) ctx.lineTo(R[i][0], Math.min(R[i][1], H));
  for (let i=0;i<L.length;i++)    ctx.lineTo(L[i][0], Math.min(L[i][1], H));
  ctx.closePath();
  ctx.clip();

  const roadG = ctx.createLinearGradient(0, VANISH_Y, 0, H);
  roadG.addColorStop(0, 'rgba(15,20,29,1)');
  roadG.addColorStop(1, 'rgba(10,15,23,1)');
  ctx.globalAlpha = OVERLAY_ALPHA;
  ctx.fillStyle = roadG;
  ctx.fillRect(0, 0, W, H);
  ctx.globalAlpha = 1;

  const topFade = ctx.createLinearGradient(0, 0, 0, TOP_FADE_PX);
  topFade.addColorStop(0, 'rgba(0,0,0,1)');
  topFade.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.globalCompositeOperation = 'destination-out';
  ctx.fillStyle = topFade;
  ctx.fillRect(0, 0, W, TOP_FADE_PX);
  ctx.globalCompositeOperation = 'source-over';
  ctx.restore();
}

/* =================== PARTICLES =================== */
const particles = [];
class Particle{
  constructor(x,y, vx,vy, life, size, color, glow=0, grav=0){
    this.x=x; this.y=y; this.vx=vx; this.vy=vy;
    this.life=life; this.age=0; this.size=size; this.color=color;
    this.glow=glow; this.grav=grav;
  }
  step(dt){
    this.age+=dt; if(this.age>=this.life) return false;
    this.vy += this.grav*dt;
    this.x += this.vx*dt; this.y += this.vy*dt;
    return true;
  }
  draw(ctx){
    const t = 1 - (this.age/this.life);
    ctx.save();
    if (this.glow>0){
      ctx.globalCompositeOperation='lighter';
      ctx.shadowBlur = this.glow;
      ctx.shadowColor = this.color;
    }
    ctx.globalAlpha = t;
    ctx.fillStyle = this.color;
    ctx.beginPath(); ctx.ellipse(this.x, this.y, this.size, this.size*0.8, 0, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }
}
function burstCoins(x,y, count=16){
  for(let i=0;i<count;i++){
    const a = Math.random()*Math.PI*2;
    const s = 180 + Math.random()*220;
    particles.push(new Particle(
      x + (Math.random()*12-6),
      y + (Math.random()*8-4),
      Math.cos(a)*s,
      Math.sin(a)*s - 60,
      0.5+Math.random()*0.35,
      3+Math.random()*2,
      'rgba(255,220,80,1)', 10, 600
    ));
  }
}
function burstNitro(x,y, count=12){
  for(let i=0;i<count;i++){
    const a = Math.random()*Math.PI*2;
    const s = 140 + Math.random()*180;
    particles.push(new Particle(
      x, y,
      Math.cos(a)*s, Math.sin(a)*s - 40,
      0.45+Math.random()*0.35,
      3+Math.random()*2,
      'rgba(80,255,200,1)', 12, 500
    ));
  }
}
function explodeBomb(x,y){
  for(let i=0;i<24;i++){
    const a = (i/24)*Math.PI*2;
    const s = 160 + Math.random()*220;
    particles.push(new Particle(
      x, y,
      Math.cos(a)*s, Math.sin(a)*s,
      0.55+Math.random()*0.35,
      4+Math.random()*3,
      'rgba(255,120,40,1)', 14, 420
    ));
  }
  for(let i=0;i<18;i++){
    const a = Math.random()*Math.PI*2;
    const s = 40 + Math.random()*90;
    particles.push(new Particle(
      x, y,
      Math.cos(a)*s, Math.sin(a)*s - 30,
      0.9+Math.random()*0.6,
      6+Math.random()*4,
      'rgba(60,60,70,0.9)', 0, 120
    ));
  }
}

/* =================== AUDIO =================== */
let AC=null, master=null, sfxGain=null, musicGain=null;
let muted = JSON.parse(localStorage.getItem('izza_muted')||'false');

function ensureAudio(){
  if (AC) return;
  AC = new (window.AudioContext||window.webkitAudioContext)();
  master = AC.createGain(); master.gain.value = muted?0:1; master.connect(AC.destination);
  sfxGain = AC.createGain(); sfxGain.gain.value = 0.9; sfxGain.connect(master);
  musicGain = AC.createGain(); musicGain.gain.value = 0.6; musicGain.connect(master);
  const src = AC.createMediaElementSource(bgm);
  src.connect(musicGain);
}

function clickStartAudio(){
  ensureAudio();
  if (AC.state === 'suspended') AC.resume();
  if (!bgmStarted){
    try{ bgm.currentTime = 0; bgm.play(); }catch(e){}
    bgmStarted = true;
  }
}
let bgmStarted=false;

/* short SFX */
function playCoin(){
  ensureAudio();
  const o = AC.createOscillator();
  const g = AC.createGain();
  o.type='triangle';
  o.frequency.setValueAtTime(620, AC.currentTime);
  o.frequency.exponentialRampToValueAtTime(1240, AC.currentTime+0.08);
  g.gain.setValueAtTime(0.0001, AC.currentTime);
  g.gain.exponentialRampToValueAtTime(0.7, AC.currentTime+0.01);
  g.gain.exponentialRampToValueAtTime(0.001, AC.currentTime+0.15);
  o.connect(g); g.connect(sfxGain); o.start(); o.stop(AC.currentTime+0.16);
}
function playNitroPickup(){
  ensureAudio();
  const n = AC.createBuffer(1, AC.sampleRate*0.18, AC.sampleRate);
  const d = n.getChannelData(0);
  for(let i=0;i<d.length;i++){ d[i] = (Math.random()*2-1) * Math.pow(1-i/d.length, 2); }
  const s = AC.createBufferSource(); s.buffer = n;
  const f = AC.createBiquadFilter(); f.type='highpass'; f.frequency.value = 500;
  const g = AC.createGain(); g.gain.value = 0.8;
  s.connect(f); f.connect(g); g.connect(sfxGain);
  s.start(); s.stop(AC.currentTime+0.18);
}
function playBomb(){
  ensureAudio();
  const n = AC.createBuffer(1, AC.sampleRate*0.5, AC.sampleRate);
  const d = n.getChannelData(0);
  for(let i=0;i<d.length;i++){ d[i] = (Math.random()*2-1) * Math.pow(1-i/d.length, 0.6); }
  const s = AC.createBufferSource(); s.buffer = n; s.playbackRate.value = 0.9;
  const f = AC.createBiquadFilter(); f.type='lowpass'; f.frequency.value = 220;
  const g = AC.createGain(); g.gain.setValueAtTime(1.0, AC.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001, AC.currentTime+0.5);
  s.connect(f); f.connect(g); g.connect(sfxGain);
  s.start(); s.stop(AC.currentTime+0.52);
}

/* Continuous Nitro whoosh while holding */
let nitroLoop = null;
function setNitroWhoosh(on){
  ensureAudio();
  if (on){
    if (nitroLoop) return;
    const noiseBuf = AC.createBuffer(1, AC.sampleRate*2, AC.sampleRate);
    const ch = noiseBuf.getChannelData(0);
    for(let i=0;i<ch.length;i++){ ch[i] = Math.random()*2-1; }
    const src = AC.createBufferSource(); src.buffer = noiseBuf; src.loop = true;
    const bp = AC.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value = 900; bp.Q.value = 0.9;
    const g = AC.createGain(); g.gain.value = 0.0001;
    src.connect(bp); bp.connect(g); g.connect(sfxGain);
    const now = AC.currentTime;
    g.gain.exponentialRampToValueAtTime(0.6, now+0.08);
    src.start();
    nitroLoop = {src, g};
  } else {
    if (!nitroLoop) return;
    const now = AC.currentTime;
    nitroLoop.g.gain.exponentialRampToValueAtTime(0.0001, now+0.12);
    try{ nitroLoop.src.stop(now+0.14); }catch(e){}
    nitroLoop = null;
  }
}

/* Sound toggle */
function applyMuteUI(){
  soundBtn.classList.toggle('muted', muted);
  soundLabel.textContent = muted? 'SOUND OFF' : 'SOUND ON';
  if (master) master.gain.value = muted?0:1;
  localStorage.setItem('izza_muted', JSON.stringify(muted));
}
soundBtn.addEventListener('click', ()=>{
  muted = !muted; applyMuteUI();
  if (!muted) clickStartAudio();
});
applyMuteUI();

/* =================== PICKUPS =================== */
class Pickup {
  constructor(type, spawnZ, laneT){
    this.type = type;
    this.spawnZ = spawnZ;
    this.laneT = laneT;
    this.spin = Math.random()*Math.PI*2;
    this.alive = true;
  }
  zRel(worldZ){ return Math.max(0, worldZ - this.spawnZ); }

  draw(worldZ){
    const z = this.zRel(worldZ);
    if (z>DEPTH_Z) { this.alive=false; return; }
    const e = edgesAt(z);

    // Clamp below horizon for readability
    const startClamp = VPT_Y + H*0.02;
    let y = Math.max(e.y, startClamp);
    const x = e.lx + (e.rx-e.lx)*this.laneT;

    const ease = (p)=>p*p*(3-2*p);
    const s = 0.030 + ease(e.t) * 0.90;

    const carMid = carX + carW*0.5;
    const aligned = Math.abs(x - carMid) < W*0.12;
    if (aligned && e.t>0.75){
      const t2 = (e.t-0.75)/0.25;
      y += (H*0.92 - y) * t2 * 0.85;
    }

    this.spin += 0.15 + (this.type==='coin'?0.22:0.12);

    if (this.type==='coin')      drawCoin(x,y,s,this.spin);
    else if (this.type==='nitro')drawNitro(x,y,s*1.06,this.spin);
    else                         drawBomb(x,y,s*1.12,this.spin);

    // HARD DESPAWN once clearly past car view, even if not collided
    if (y > H*0.97 || e.t > 0.995) this.alive = false;
  }

  hitTest(carRect, worldZ){
    const z = this.zRel(worldZ);
    const e = edgesAt(z);
    const x = e.lx + (e.rx-e.lx)*this.laneT;
    const startClamp = VPT_Y + H*0.02;
    const y = Math.max(e.y, startClamp);
    const r = 12 + 40*e.t;
    const cx=x, cy=y;
    const nx = Math.max(carRect.x, Math.min(cx, carRect.x+carRect.w));
    const ny = Math.max(carRect.y, Math.min(cy, carRect.y+carRect.h));
    const dx = cx-nx, dy = cy-ny;

    /* STRICT center requirement for middle-lane objects */
    const isMiddleLane = Math.abs(this.laneT - 0.50) < 1e-3;
    if (isMiddleLane){
      const carCenter = carX + carW*0.5;
      const centerEps = Math.max(8, W*0.02);
      if (Math.abs(carCenter - W*0.5) > centerEps) return false;
    }

    return (dx*dx + dy*dy) < (r*r*0.85);
  }
}

/* Procedural sprites for pickups (unchanged visuals) */
function drawCoin(x,y,s,ang){
  const w = 26*s, h = 26*s*Math.max(0.28, Math.abs(Math.cos(ang)));
  ctx.save();
  ctx.translate(x,y);
  ctx.globalCompositeOperation='lighter';
  ctx.fillStyle='rgba(255,214,70,0.95)'; ctx.beginPath(); ctx.ellipse(0,0,w,h,0,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='rgba(255,186,0,1)';     ctx.beginPath(); ctx.ellipse(0,0,w*0.82,h*0.82,0,0,Math.PI*2); ctx.fill();
  ctx.globalCompositeOperation='source-over';
  ctx.fillStyle='rgba(40,28,0,0.7)';
  ctx.font = `${Math.max(8,10*s)}px Arial Black`;
  ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('IZZA',0,0);
  ctx.restore();
}
function drawNitro(x,y,s,ang){
  const w = 16*s, h = 34*s;
  ctx.save(); ctx.translate(x,y); ctx.rotate(Math.sin(ang)*0.25);
  const g = ctx.createLinearGradient(0,-h/2,0,h/2);
  g.addColorStop(0,'#65ffd1'); g.addColorStop(1,'#17a56a');
  ctx.fillStyle=g; ctx.strokeStyle='rgba(0,0,0,0.35)'; ctx.lineWidth=2;
  if (!CanvasRenderingContext2D.prototype.roundRect){
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      r = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+r, y);
      this.arcTo(x+w, y, x+w, y+h, r);
      this.arcTo(x+w, y+h, x, y+h, r);
      this.arcTo(x, y+h, x, y, r);
      this.arcTo(x, y, x+w, y, r);
      return this;
    };
  }
  ctx.beginPath(); ctx.roundRect(-w/2,-h/2,w,h,6); ctx.fill(); ctx.stroke();
  ctx.fillStyle='rgba(0,0,0,0.25)'; ctx.fillRect(-w*0.45,-h*0.05,w*0.9,h*0.1);
  ctx.fillStyle='rgba(255,255,255,0.9)';
  ctx.font=`${Math.max(6,8*s)}px Arial Black`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('N2O',0,0);
  ctx.fillStyle='#0e2130'; ctx.fillRect(-w*0.25,-h*0.62,w*0.5,h*0.14);
  ctx.restore();
}
function drawBomb(x,y,s,ang){
  const r = 16*s;
  ctx.save(); ctx.translate(x,y); ctx.rotate(ang*0.7);
  ctx.fillStyle='rgba(30,30,35,1)'; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
  ctx.globalCompositeOperation='lighter';
  const flick = 0.6+0.4*Math.sin(ang*3);
  ctx.fillStyle=`rgba(255,120,20,${0.5+0.5*flick})`;
  ctx.beginPath(); ctx.arc(r*0.6,-r*0.6,4+2*flick,0,Math.PI*2); ctx.fill();
  ctx.restore();
}

/* ============== CAR + FX ============== */
let carW=0, carH=0, carX=0, carY=0;
function updateCarPlacement(){
  carW = Math.min(W*0.78, 480);
  const ratio = (carImg.height||512) / (carImg.width||1024);
  carH = carW * ratio;
  carX = Math.round((W - carW)/2);
  carY = Math.round(H - carH*1.02);
  VPT_X = carX + carW*0.5; // anchor all light/motion to car center
}
function carRect(){ return {x:carX+carW*0.18, y:carY+carH*0.30, w:carW*0.64, h:carH*0.52}; }

function buildCarFXCanvas(nitroBoost, t){
  const fx = document.createElement('canvas');
  fx.width = Math.max(2, Math.floor(carW));
  fx.height = Math.max(2, Math.floor(carH));
  const c = fx.getContext('2d');

  const flick = 0.75 + 0.25*Math.sin(t*12);
  const lightY = carH*0.50;
  const leftX  = carW*0.29;
  const rightX = carW*0.71;

  c.globalCompositeOperation = 'lighter';
  c.shadowBlur = 22;
  c.shadowColor = `rgba(255,60,40,${0.85*flick})`;
  c.fillStyle   = `rgba(255,70,50,${0.55*flick})`;
  const lamp = (x) => {
    c.beginPath();
    c.moveTo(x-18, lightY);
    c.lineTo(x+18, lightY);
    c.lineTo(x+8,  lightY+10);
    c.lineTo(x-8,  lightY+10);
    c.closePath(); c.fill();
  };
  lamp(leftX); lamp(rightX);

  const flame = (nitroBoost? 1.0 : 0.35) * (0.7+0.3*Math.sin(t*20));
  c.shadowBlur  = 28;
  c.shadowColor = `rgba(${paint.r},${paint.g},${paint.b},1)`;
  c.fillStyle   = `rgba(${paint.r},${paint.g},${paint.b},${0.22+0.35*flame})`;
  const jet = (x) => {
    c.beginPath();
    c.moveTo(x, carH*0.82);
    c.quadraticCurveTo(x-12, carH*0.92, x, carH*1.02);
    c.quadraticCurveTo(x+12, carH*0.92, x, carH*0.82);
    c.closePath(); c.fill();
  };
  jet(carW*0.33);
  jet(carW*0.67);

  return fx;
}

/* ============== INPUT ============== */
let time = 0;
const steer = { x:0, nitro:false };
canvas.addEventListener('pointerdown', e=>{
  const x = e.clientX - canvas.getBoundingClientRect().left;
  steer.x = (x < W/2) ? -1 : 1;
  clickStartAudio();
});
canvas.addEventListener('pointermove', e=>{
  if (e.buttons) {
    const x = e.clientX - canvas.getBoundingClientRect().left;
    steer.x = (x < W/2) ? -1 : 1;
  }
});
window.addEventListener('pointerup', ()=>{ steer.x=0; });
window.addEventListener('keydown', e=>{
  if(e.key==='ArrowLeft')  steer.x=-1;
  if(e.key==='ArrowRight') steer.x=1;
  if(e.key.toLowerCase()===' ') steer.nitro=true;
  clickStartAudio();
});
window.addEventListener('keyup', e=>{
  if(e.key==='ArrowLeft' || e.key==='ArrowRight') steer.x = 0;
  if(e.key.toLowerCase()===' ') steer.nitro=false;
});

/* Nitro meter hold */
function bindNitroHold(el){
  const on=()=>{ steer.nitro=true; clickStartAudio(); };
  const off=()=>{ steer.nitro=false; };
  el.addEventListener('pointerdown', e=>{ e.preventDefault(); on(); });
  window.addEventListener('pointerup', off);
  el.addEventListener('touchstart', e=>{ e.preventDefault(); on(); }, {passive:false});
  el.addEventListener('touchend', off);
}
bindNitroHold(nitroWrap);

/* ============== GAME STATE ============== */
let worldZ = 0, last = performance.now();
const state = { running:false, speed:0, dist:0, coins:0, bombsHit:0 };
let nitro = 1.0; // 0..1 meter
let heat = 0;    // nitro ‚Äúglow heat‚Äù 0..1
let nitroActive = false;
let lastSpawn = 0;
const pickups = [];

/* Lanes */
const LANE_TS = [0.26, 0.50, 0.74];

/* No stacking per-lane */
const MIN_LANE_SEP_Z = 820;
const laneLastSpawnZ = [ -1e9, -1e9, -1e9 ];

/* Spawn controller */
function spawnOne(){
  const available = [];
  for (let i=0;i<LANE_TS.length;i++){
    if (worldZ - laneLastSpawnZ[i] >= MIN_LANE_SEP_Z) available.push(i);
  }
  if (available.length===0) return;

  const li = available[Math.floor(Math.random()*available.length)];
  const laneT = LANE_TS[li];
  laneLastSpawnZ[li] = worldZ;

  const r = Math.random();
  const spawnZ = worldZ;
  if (r < 0.58)       pickups.push(new Pickup('coin',  spawnZ, laneT));
  else if (r < 0.84)  pickups.push(new Pickup('nitro', spawnZ, laneT));
  else                pickups.push(new Pickup('bomb',  spawnZ, laneT));
}

function useNitro(dt){
  const can = nitro>0.02;
  const wasActive = nitroActive;
  nitroActive = steer.nitro && can;
  if (nitroActive){ nitro = Math.max(0, nitro - dt*0.25); heat = Math.min(1, heat + dt*2.4); }
  else            { heat = Math.max(0, heat - dt*1.6); }
  if (nitroActive !== wasActive) setNitroWhoosh(nitroActive);
  nitroFill.style.width = Math.round(nitro*100)+'%';
}

function gameOver(){
  state.running=false;
  try{ bgm.pause(); }catch(e){}
  setNitroWhoosh(false);
  alert(`CRASHED üí•\nDistance: ${Math.round(state.dist)} m\nCoins: ${state.coins}`);
  document.getElementById('startOverlay').style.display='';
}

function drawCar(nitroBoost){
  const src = tintedSprite || carImg;
  ctx.drawImage(src, carX, carY, carW, carH);
  const fx = buildCarFXCanvas(nitroBoost, time);
  ctx.globalCompositeOperation = 'lighter';
  ctx.drawImage(fx, carX, carY);
  ctx.globalCompositeOperation = 'source-over';
}

/* ============== MAIN LOOP ============== */
function frame(now){
  if(!state.running) return;
  const dt = Math.min(0.033, (now - last)/1000); last = now;
  time += dt;

  // Nitro & speed
  useNitro(dt);
  const target = (nitroActive ? 260 : 190);
  state.speed += (target - state.speed) * 0.10;

  const hyper = nitroActive;
  const mps = state.speed / 3.6 * (hyper?1.10:1);
  worldZ += mps * dt;
  state.dist += mps * dt;

  // Spawns
  if (now - lastSpawn > 650*(0.80+Math.random()*0.35)) {
    lastSpawn = now; spawnOne();
  }

  // steering + anchor visuals to car center
  const steerSpeed = Math.max(2.5, W * 0.0066) * (hyper?1.06:1);
  carX += steer.x * steerSpeed;
  const off = carW*0.12;
  carX = Math.max(-off, Math.min(W - carW + off, carX));
  VPT_X = carX + carW*0.5;

  // Draw
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawBackground(hyper?HYPER.zoom:1);
  drawRoad();

  // NEW: speed grid (independent layer), before aurora/motion/headlights and under car
  drawSpeedGrid(worldZ, state.speed, hyper);

  drawAurora(time, hyper?1.25:1);
  drawVanishingGlow(time, heat);
  drawMotion(worldZ, state.speed, hyper, heat);

  // Headlights on top
  drawHeadlights();

  // Colliders
  const cRect = carRect();

  // Pickups + collisions + FX
  for (const p of pickups) {
    if (!p.alive) continue;
    p.draw(worldZ);
    if (!p.alive) continue; // might have despawned during draw

    if (p.hitTest(cRect, worldZ)) {
      p.alive = false;

      // screen-space coordinates at collision moment
      const ez = p.zRel(worldZ);
      const e  = edgesAt(ez);
      const x  = e.lx + (e.rx-e.lx)*p.laneT;
      const y  = Math.max(e.y, VPT_Y + H*0.02);

      if (p.type === 'coin') {
        state.coins += 100;
        burstCoins(x,y);
        playCoin();
      } else if (p.type === 'nitro') {
        nitro = Math.min(1, nitro + 0.25);
        burstNitro(x,y);
        playNitroPickup();
      } else {
        state.bombsHit++;
        explodeBomb(x,y);
        playBomb();
        if (state.bombsHit >= 3) { gameOver(); return; }
      }
    }
  }
  for (let i = pickups.length - 1; i >= 0; i--) if (!pickups[i].alive) pickups.splice(i, 1);

  // Particles
  for (let i=particles.length-1; i>=0; i--){
    if (!particles[i].step(dt)) { particles.splice(i,1); continue; }
    particles[i].draw(ctx);
  }

  drawCar(nitroActive);

  // HUD
  HUD.speed.textContent = Math.round(state.speed);
  HUD.dist.textContent  = Math.round(state.dist);
  HUD.coins.textContent = state.coins;

  requestAnimationFrame(frame);
}

/* ======= START ======= */
document.getElementById('startBtn').addEventListener('click', () => {
  document.getElementById('startOverlay').style.display = 'none';
  resize();
  tintedSprite = makeTintedSprite(paint);
  state.running   = true;
  state.speed     = 90;
  state.dist      = 0;
  worldZ          = 0;
  last            = performance.now();
  state.coins     = 0;
  state.bombsHit  = 0;
  nitro           = 1.0;
  heat            = 0.0;
  nitroFill.style.width = '100%';
  pickups.length  = 0;
  particles.length= 0;
  laneLastSpawnZ[0]=laneLastSpawnZ[1]=laneLastSpawnZ[2]=-1e9;
  lastSpawn       = performance.now();

  if (!muted){ clickStartAudio(); }

  requestAnimationFrame(frame);
});

/* init */
resize();
rebuildTintAndPreview();
})();
</script>
</body>
</html>
