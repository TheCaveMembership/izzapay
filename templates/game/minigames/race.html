<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Street Race — IZZA GAME</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <script>window.IZZA_PERSIST_BASE='https://izzagame.onrender.com';</script>
  <script src="/static/game/js/izza-persist.js"></script>
  <link rel="stylesheet" href="/static/themes.css">
  <style>
    :root { --bg:#0a0c12; --panel:#06080e; }
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:#e8eef7;font-family:Arial,Helvetica,sans-serif}
    .arena{position:relative;height:100vh;max-width:520px;margin:0 auto;
      border-left:1px solid rgba(255,255,255,.08);
      border-right:1px solid rgba(255,255,255,.08);
      background:var(--panel);overflow:hidden}
    .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:8;
      background:linear-gradient(to bottom, rgba(0,0,0,.55), rgba(0,0,0,.35));}
    .card{background:rgba(0,0,0,.6);border:1px solid rgba(255,255,255,.18);border-radius:14px;
      padding:16px 18px;display:flex;flex-direction:column;gap:10px;width:min(92%,440px)}
    .preview{height:160px;border:1px dashed rgba(255,255,255,.18);border-radius:12px;
      display:flex;align-items:center;justify-content:center;overflow:hidden}
    .startBtn{padding:12px 16px;border-radius:10px;border:1px solid rgba(255,255,255,.1);
      background:rgba(255,255,255,.08);font-weight:800;color:white}
    .hud{position:absolute;top:8px;left:8px;right:8px;z-index:6;display:flex;justify-content:space-between;font-size:12px}
    .nitroBtn{position:absolute;right:10px;bottom:14px;z-index:7;border-radius:999px;
      border:1px solid rgba(255,255,255,.1);background:#222;padding:10px 14px;font-weight:800;color:white}
    canvas{display:block;width:100%;height:100%}
  </style>
</head>
<body>
  <div class="arena" id="arena">
    <!-- HUD -->
    <div class="hud">
      <div>SPEED: <span id="speed">0</span> km/h</div>
      <div>DIST: <span id="dist">0</span> m</div>
      <div>COINS: <span id="coinsRun">0</span></div>
    </div>

    <!-- Garage -->
    <div id="startOverlay" class="overlay">
      <div class="card">
        <h3>Street Race</h3>
        <div class="preview">
          <img src="/static/game/sprites/tracks/coupe.png" alt="Car" style="height:100%"/>
        </div>
        <button id="startBtn" class="startBtn">START</button>
      </div>
    </div>

    <button class="nitroBtn" id="nitroBtn">NITRO</button>
    <canvas id="scene"></canvas>
  </div>

<script>
(function(){
  const arena  = document.getElementById('arena');
  const canvas = document.getElementById('scene');
  const ctx    = canvas.getContext('2d', { alpha:true });
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = 'high';

  const HUD = {
    speed: document.getElementById('speed'),
    dist : document.getElementById('dist'),
    coins: document.getElementById('coinsRun')
  };

  // --- DPR sizing ---
  let dpr=1, W=0, H=0;
  function resize(){
    W = arena.clientWidth;
    H = arena.clientHeight;
    dpr = Math.min(window.devicePixelRatio || 1, 2);
    canvas.width  = Math.floor(W * dpr);
    canvas.height = Math.floor(H * dpr);
    canvas.style.width  = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);

    // perspective params depend on size
    horizonY = H*0.22;
    roadBottomHalf = W*0.44;   // road half-width at bottom
    roadTopHalf    = W*0.10;   // at horizon

    // parallax layers
    skylineY = Math.max(40, horizonY - 6);
  }
  window.addEventListener('resize', resize, {passive:true});

  // --- Assets (car only) ---
  const carImg = new Image();
  carImg.src = '/static/game/sprites/tracks/coupe.png';
  let carRatio = 0.5;
  carImg.onload = ()=>{ carRatio = carImg.height / carImg.width; };

  // --- Input (tap left/right half; arrow keys) ---
  const steer = { x:0 };
  function onPointer(e){
    const r = canvas.getBoundingClientRect();
    const x = (e.touches ? e.touches[0].clientX : e.clientX) - r.left;
    steer.x = (x < r.width/2) ? -1 : 1;
  }
  function stopPointer(){ steer.x = 0; }
  canvas.addEventListener('pointerdown', onPointer);
  canvas.addEventListener('pointermove', onPointer);
  window.addEventListener('pointerup', stopPointer);
  window.addEventListener('keydown', e=>{
    if(e.key==='ArrowLeft') steer.x=-1;
    if(e.key==='ArrowRight') steer.x=1;
  });
  window.addEventListener('keyup', e=>{
    if(e.key==='ArrowLeft'||e.key==='ArrowRight') steer.x=0;
  });

  // --- Road & world params ---
  let horizonY=0, roadBottomHalf=0, roadTopHalf=0, skylineY=0;
  const sideLineColor   = 'rgba(240,245,255,0.95)';
  const shoulderColor   = '#0d121b';
  const asphaltTop      = '#141a23';
  const asphaltBot      = '#0c1119';

  let nitroLeft = 0;
  let worldZ = 0;                 // meters forward
  const mpsFromKmh = (k)=>k/3.6;

  // projection depth -> screen
  const lerp = (a,b,t)=>a+(b-a)*t;
  function project(z){
    const k = 0.012;                 // perspective strength
    const t = 1 - Math.exp(-k*z);    // 0..1
    const y = lerp(horizonY, H, t);
    const half = lerp(roadTopHalf, roadBottomHalf, t);
    return { y, half, t };
  }

  // --- Environment zones (looping): Chinatown → small town → big city ---
  // change the roadside mix every N meters
  const ZONE_LEN = 800; // meters each slice
  function zoneAt(dist){
    const i = Math.floor(dist / ZONE_LEN) % 3;
    return ['chinatown','suburb','city'][i];
  }

  // --- Procedural objects (spawned near road edges) ---
  const leftObjs = [], rightObjs = [];
  function spawnObj(side, zAhead, zone){
    // type mix by zone
    let types;
    if(zone==='chinatown'){
      types = ['shop','neon','tree','shop','neon','tree'];
    }else if(zone==='suburb'){
      types = ['tree','tree','house','tree','house','sign'];
    }else{
      types = ['tower','tower','neon','tower','sign'];
    }
    const type = types[(Math.random()*types.length)|0];
    const base = {
      type,
      z: worldZ + zAhead,
      // world lateral offset from road edge (+ outwards)
      off: (side==='L' ? -1 : 1) * (2 + Math.random()*2),
      // world size hint
      w:  type==='tree'? 2.4 : type==='house'? 4.0 : type==='shop'? 5.0 :
          type==='tower'? 7.0 : 2.2,
      color: `hsl(${200+Math.random()*20}, 25%, ${type==='neon'?60:35}%)`,
      glow : type==='neon' || type==='sign'
    };
    (side==='L'?leftObjs:rightObjs).push(base);
  }

  function sweepAndSpawn(dt, speedMps){
    const maxDepth = 1200;   // meters we render forward
    // purge that passed camera
    function purge(arr){
      while(arr.length && arr[0].z < worldZ - 10) arr.shift();
    }
    purge(leftObjs); purge(rightObjs);

    // spacing (denser in city/chinatown)
    const z = worldZ;
    const zoneNow = zoneAt(z);
    const gap = (zoneNow==='suburb'? 28 : 18);

    // ensure next spawn at least every gap meters per side
    if (!leftObjs.length || leftObjs[leftObjs.length-1].z - z > gap){
      spawnObj('L', 55 + Math.random()*25, zoneNow);
    }
    if (!rightObjs.length || rightObjs[rightObjs.length-1].z - z > gap){
      spawnObj('R', 55 + Math.random()*25, zoneNow);
    }
  }

  // --- Drawing helpers for “3D-ish” objects ---
  function drawTree(p, side){
    // bulb foliage with tiny trunk; size from depth
    const size = lerp(26, 6, p.t); // pixels radius-ish
    const x = (W/2) + (side==='L'? -1:1) * (p.half + 10 + size*0.2);
    // trunk
    ctx.fillStyle = '#2b2b2b';
    ctx.fillRect(x-2, p.y-2, 4, size*0.9);
    // foliage
    const g = ctx.createRadialGradient(x, p.y-size*0.6, size*0.2, x, p.y-size*0.2, size*1.05);
    g.addColorStop(0, 'rgba(40,110,70,0.95)');
    g.addColorStop(1, 'rgba(18,40,30,0.95)');
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.ellipse(x, p.y-size*0.6, size*0.9, size*0.7, 0, 0, Math.PI*2);
    ctx.fill();
  }

  function drawShop(p, side, neon=false){
    // low block with awning; looks good in “chinatown”
    const depthScale = lerp(1.2, 0.35, p.t);
    const w = 80*depthScale, h = 60*depthScale;
    const x = (W/2) + (side==='L'? -1:1) * (p.half + 12 + w*0.15);
    const y = p.y - h;
    // body
    const grad = ctx.createLinearGradient(0,y,0,y+h);
    grad.addColorStop(0, '#1a2230'); grad.addColorStop(1, '#0f141d');
    ctx.fillStyle = grad;
    ctx.fillRect(x - (side==='L'?w:0), y, w, h);
    // windows
    ctx.fillStyle = 'rgba(130,200,255,0.28)';
    for(let i=0;i<3;i++){ ctx.fillRect(x - (side==='L'?w:0)+6+i*(w/3), y+8, w/3-10, h*0.38); }
    // awning
    ctx.fillStyle = '#0a0e16';
    ctx.fillRect(x - (side==='L'?w:0), y+h*0.55, w, 6);
    if (neon){
      ctx.save();
      ctx.shadowColor = '#19f5ff';
      ctx.shadowBlur = 18*depthScale;
      ctx.fillStyle = '#38f0ff';
      const sx = x - (side==='L'?w:0) + w*0.12, sy = y+h*0.25;
      ctx.fillRect(sx, sy, w*0.22, 10);
      ctx.restore();
    }
  }

  function drawHouse(p, side){
    const depthScale = lerp(1.2, 0.35, p.t);
    const w = 72*depthScale, h = 54*depthScale;
    const x = (W/2) + (side==='L'? -1:1) * (p.half + 14 + w*0.15);
    const y = p.y - h;
    ctx.fillStyle = '#18202a'; ctx.fillRect(x - (side==='L'?w:0), y, w, h);
    ctx.fillStyle = 'rgba(255,230,160,0.18)'; ctx.fillRect(x - (side==='L'?w:0)+10, y+12, w*0.4, h*0.35);
  }

  function drawTower(p, side){
    const depthScale = lerp(1.4, 0.45, p.t);
    const w = 54*depthScale, h = 200*depthScale;
    const x = (W/2) + (side==='L'? -1:1) * (p.half + 24 + w*0.25);
    const y = p.y - h;
    // body
    const g = ctx.createLinearGradient(x, y, x, y+h);
    g.addColorStop(0, '#132033'); g.addColorStop(1, '#0b1422');
    ctx.fillStyle = g;
    ctx.fillRect(x - (side==='L'?w:0), y, w, h);
    // windows grid
    ctx.fillStyle = 'rgba(140,200,255,0.16)';
    const gw = Math.max(6, 10*depthScale);
    for(let yy=y+6; yy<y+h-6; yy+=gw+4){
      for(let xx=(x - (side==='L'?w:0))+6; xx<x - (side==='L'?w:0)+w-6; xx+=gw+6){
        ctx.fillRect(xx, yy, gw, gw*0.55);
      }
    }
  }

  function drawSign(p, side){
    const depthScale = lerp(1.3, 0.45, p.t);
    const w = 26*depthScale, h = 60*depthScale;
    const x = (W/2) + (side==='L'? -1:1) * (p.half + 8);
    const y = p.y - h;
    // pole
    ctx.fillStyle = '#2c2f39';
    ctx.fillRect(x + (side==='L'?-2:2), y, 3, h);
    // panel with glow
    ctx.save();
    ctx.shadowColor = (side==='L')? '#ff6bd8' : '#18f0ff';
    ctx.shadowBlur = 16*depthScale;
    ctx.fillStyle = (side==='L')? '#ff6bd8' : '#38f0ff';
    ctx.fillRect(x - (side==='L'?w:0), y+8, w, h*0.55);
    ctx.restore();
  }

  function drawRoad(){
    // asphalt
    ctx.beginPath();
    ctx.moveTo(W/2 - roadTopHalf, horizonY);
    ctx.lineTo(W/2 + roadTopHalf, horizonY);
    ctx.lineTo(W/2 + roadBottomHalf, H);
    ctx.lineTo(W/2 - roadBottomHalf, H);
    ctx.closePath();
    const g = ctx.createLinearGradient(0,horizonY,0,H);
    g.addColorStop(0, asphaltTop);
    g.addColorStop(1, asphaltBot);
    ctx.fillStyle = g;
    ctx.fill();

    // shoulders outside
    ctx.save();
    ctx.globalCompositeOperation = 'destination-over';
    ctx.fillStyle = shoulderColor;
    ctx.fillRect(0,horizonY,W,H-horizonY);
    ctx.restore();

    // side lane lines (white) – no center line per your ask
    ctx.lineWidth = 2;
    ctx.strokeStyle = sideLineColor;
    ctx.beginPath();
    ctx.moveTo(W/2 - roadTopHalf, horizonY);
    ctx.lineTo(W/2 - roadBottomHalf, H);
    ctx.moveTo(W/2 + roadTopHalf, horizonY);
    ctx.lineTo(W/2 + roadBottomHalf, H);
    ctx.stroke();

    // guard-rails hint + red LEDs
    ctx.strokeStyle = 'rgba(120,130,150,0.55)';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(W/2 - roadTopHalf*1.1, horizonY);
    ctx.lineTo(W/2 - roadBottomHalf*1.1, H);
    ctx.moveTo(W/2 + roadTopHalf*1.1, horizonY);
    ctx.lineTo(W/2 + roadBottomHalf*1.1, H);
    ctx.stroke();

    // tiny LEDs along rails to sell motion
    ctx.fillStyle = 'rgba(255,90,50,0.85)';
    const spacingM = 16;
    let z = Math.floor((worldZ % spacingM)) * -1;
    for (; z < 900; z += spacingM){
      const p = project(Math.max(0,z));
      if (p.y>H) break; if (p.y<horizonY) continue;
      const r = Math.max(1, 3 * (1 - (p.y - horizonY)/(H-horizonY)));
      ctx.beginPath(); ctx.arc(W/2 - p.half*1.1 - 8, p.y, r, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(W/2 + p.half*1.1 + 8, p.y, r, 0, Math.PI*2); ctx.fill();
    }
  }

  function drawSkyAndFog(){
    // sky
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, '#0e1320');
    g.addColorStop(0.25, '#0f1522');
    g.addColorStop(1, '#090d14');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // parallax skyline silhouettes (two layers)
    function skyline(y, scale, alpha){
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = '#0b1322';
      const step = 42*scale;
      let x= -20;
      while(x < W+40){
        const w = (step + Math.random()*step)*0.8;
        const h = 40*scale + Math.random()*120*scale;
        ctx.fillRect(x, y-h, w, h);
        x += w + 10*scale;
      }
      ctx.restore();
    }
    skyline(skylineY+6, 0.8, 0.35);
    skyline(skylineY+10, 1.1, 0.20);

    // horizon glow
    const fog = ctx.createLinearGradient(0, horizonY-40, 0, horizonY+120);
    fog.addColorStop(0, 'rgba(120,160,220,0.10)');
    fog.addColorStop(1, 'rgba(120,160,220,0.00)');
    ctx.fillStyle = fog;
    ctx.fillRect(0, horizonY-40, W, 160);

    // bottom vignette
    const vig = ctx.createLinearGradient(0, H*0.60, 0, H);
    vig.addColorStop(0, 'rgba(0,0,0,0)');
    vig.addColorStop(1, 'rgba(0,0,0,0.38)');
    ctx.fillStyle = vig;
    ctx.fillRect(0, H*0.60, W, H*0.40);
  }

  function drawObjects(){
    function drawList(arr, side){
      for (let i=0;i<arr.length;i++){
        const o = arr[i];
        const p = project(Math.max(0, o.z - worldZ));
        if (p.y>H) continue; if (p.y<horizonY-6) continue;

        // Choose renderer
        if (o.type==='tree') drawTree(p, side);
        else if (o.type==='shop') drawShop(p, side, false);
        else if (o.type==='house') drawHouse(p, side);
        else if (o.type==='tower') drawTower(p, side);
        else if (o.type==='neon') drawShop(p, side, true);
        else if (o.type==='sign') drawSign(p, side);
      }
    }
    drawList(leftObjs,'L');
    drawList(rightObjs,'R');
  }

  function drawCar(){
    // centered car; remove center line already handled
    const sway = steer.x * 18;
    const carW = Math.min(W*0.62, 340);
    const carH = carW * carRatio;
    const x = Math.round((W - carW)/2 + sway);
    const y = Math.round(H*0.78 - carH*0.92);
    ctx.drawImage(carImg, x, y, Math.round(carW), Math.round(carH));
  }

  // --- State & loop ---
  const state = { running:false, speed:0, dist:0 }; // speed km/h

  function frame(now){
    if (!state.running) return;
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;

    const target = 180 + (nitroLeft>0 ? 120 : 0);
    state.speed += (target - state.speed) * 0.08;
    const mps = mpsFromKmh(state.speed);
    worldZ += mps * dt;
    state.dist += mps * dt;

    // update roadside content
    sweepAndSpawn(dt, mps);

    // draw
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawSkyAndFog();
    drawRoad();
    drawObjects();
    drawCar();

    // HUD
    HUD.speed.textContent = Math.round(state.speed);
    HUD.dist.textContent  = Math.round(state.dist);
    HUD.coins.textContent = 0;

    if (nitroLeft>0) nitroLeft -= dt;
    requestAnimationFrame(frame);
  }

  // Nitro
  document.getElementById('nitroBtn').addEventListener('click', ()=>{ nitroLeft = 2.0; });

  // Start
  let last = performance.now();
  document.getElementById('startBtn').addEventListener('click',()=>{
    document.getElementById('startOverlay').style.display='none';
    resize();
    state.running = true;
    state.speed = 60;
    state.dist = 0;
    worldZ = 0;
    leftObjs.length = rightObjs.length = 0;
    last = performance.now();
    requestAnimationFrame(frame);
  });

  resize();
})();
</script>
</body>
</html>
