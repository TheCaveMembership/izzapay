<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Street Race — IZZA GAME</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  <!-- Persist base (same as Arena/Basketball) -->
  <script>window.IZZA_PERSIST_BASE='https://izzagame.onrender.com';</script>

  <!-- Seed username before izza-persist.js (same pattern as Basketball) -->
  <script>
    (function(){
      try{
        const params = new URLSearchParams(location.search);
        let u = (params.get('u') || '').toString().trim();
        if (!u) u = (localStorage.getItem('izzaUserU') || '').toString().trim();
        if (!u) {
          const raw = localStorage.getItem('piAuthUser');
          if (raw) { try { u = (JSON.parse(raw)||{}).username || ''; } catch(_){} }
        }
        if (u) {
          u = u.replace(/^@+/, '').toLowerCase();
          window.__IZZA_PROFILE__ = Object.assign({}, window.__IZZA_PROFILE__, { username: u });
          window.izzaUserKey = { get: () => u };
          try { localStorage.setItem('izzaUserU', u); } catch(_){}
          try {
            if (!localStorage.getItem('piAuthUser')) {
              localStorage.setItem('piAuthUser', JSON.stringify({ username: u }));
            }
          } catch(_){}
        }
      }catch(_){}
    })();
  </script>

  <script src="/static/game/js/izza-persist.js"></script>
  <link rel="stylesheet" href="/static/themes.css">

  <style>
    :root {
      --bg:#0a0c12;
      --panel:#06080e;
      --hud:rgba(0,0,0,.55);
      --hudLine:rgba(255,255,255,.18);
      --arcade:#ffed8a;
      --ok:#6bffa5;
      --bad:#ff4b4b;
      --muted:#9fb6d1;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;background:var(--bg);color:#e8eef7;font-family:Arial,Helvetica,sans-serif;
      -webkit-user-select:none; user-select:none; -webkit-touch-callout:none;
    }
    .arena{
      position:relative;height:100vh;max-width:520px;margin:0 auto;
      border-left:1px solid rgba(255,255,255,.08);
      border-right:1px solid rgba(255,255,255,.08);
      background:var(--panel);overflow:hidden
    }

    /* ======= HUD ======= */
    .hud{
      position:absolute;top:8px;left:8px;right:8px;z-index:9;
      display:flex;justify-content:space-between;align-items:center;
      gap:6px;font-size:13px;letter-spacing:.3px
    }
    .hud .left,.hud .right{display:flex;align-items:center;gap:6px;flex-wrap:nowrap}
    .pill{
      background:var(--hud);border:1px solid var(--hudLine);backdrop-filter:blur(6px);
      padding:4px 7px;border-radius:999px;font-size:10px;font-weight:900;letter-spacing:.25px;
      display:flex;gap:6px;align-items:center;white-space:nowrap
    }
    .pill .label{opacity:.9;color:var(--muted);font-weight:700}
    .pill .val{font-size:13px;color:var(--arcade);text-shadow:0 2px 12px rgba(0,0,0,.4)}
    .hudGroup{display:flex;gap:6px;align-items:center}

    /* Speedometer (SVG) */
    .speedo{width:112px;height:42px;display:inline-block}
    .speedoWrap{
      display:flex;align-items:center;gap:6px;
      background:var(--hud);border:1px solid var(--hudLine);border-radius:999px;padding:2px 6px
    }
    .speedoWrap.shake{animation:spdshake .12s linear infinite}
    @keyframes spdshake {
      0%{ transform:translateY(0) }
      50%{ transform:translateY(-1px) }
      100%{ transform:translateY(0) }
    }

    /* mini HUD (car + 3 bomb SVGs) */
    .strikeHud{display:flex;align-items:center;gap:8px}
    .bombTray{display:flex;gap:4px;align-items:center}
    .bombSvg{width:16px;height:16px;filter:drop-shadow(0 0 2px rgba(0,0,0,.5))}
    .bombSvg .shell{fill:#3b3f4a;stroke:rgba(255,255,255,.18);stroke-width:1}
    .bombSvg .fuse{fill:#ffb56b}
    .bombSvg.hit .shell{fill:#ff3b3b;stroke:rgba(0,0,0,.25)}
    .bombSvg.hit .fuse{fill:#ffed8a}

    /* overlays */
    .overlay{
      position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:8;
      background:linear-gradient(to bottom, rgba(0,0,0,.7), rgba(0,0,0,.55));
    }
    .card{
      position:relative;
      background:rgba(10,12,18,.95);
      border:1px solid rgba(255,255,255,.16);border-radius:14px;
      padding:16px 18px;display:flex;flex-direction:column;gap:12px;width:min(92%,480px);
      overflow:hidden
    }
    .card.hasBG::before{
      content:"";position:absolute;inset:0;background-size:cover;background-position:center;
      opacity:.22;filter:brightness(1.05);pointer-events:none
    }
    .card .hRow{display:flex;align-items:center;justify-content:space-between;gap:8px}
    .row{display:flex;gap:10px;align-items:center;justify-content:space-between}
    .preview{
      height:184px;border:1px dashed rgba(255,255,255,.18);border-radius:12px;
      display:flex;align-items:center;justify-content:center;overflow:hidden;position:relative
    }
    .startBtn,.cityBtn{
      padding:12px 16px;border-radius:10px;border:1px solid rgba(255,255,255,.1);
      background:rgba(255,255,255,.08);font-weight:800;color:white;width:100%;cursor:pointer;
      text-align:center
    }
    .startBtn:hover,.cityBtn:hover{filter:brightness(1.08)}
    .swatches{display:flex;gap:10px;flex-wrap:wrap}
    .swatch{width:26px;height:26px;border-radius:50%;border:2px solid rgba(255,255,255,.28);cursor:pointer}
    .swatch.active{box-shadow:0 0 0 3px rgba(255,255,255,.18) inset}
    .trackRow{display:flex;gap:8px;flex-wrap:wrap}
    .trackBtn{
      padding:6px 10px;border-radius:10px;border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.06);cursor:pointer;font-size:12px;font-weight:800
    }
    .trackBtn.active{outline:2px solid rgba(255,255,255,.25)}
    .garageHint{
      position:absolute;right:8px;bottom:8px;background:rgba(0,0,0,.45);
      border:1px solid rgba(255,255,255,.15);padding:4px 6px;border-radius:8px;font-size:10px
    }

    canvas{display:block;width:100%;height:100%;background:transparent;touch-action:none;
      -webkit-user-select:none; user-select:none; -webkit-touch-callout:none;}

    /* Nitro meter */
    .nitroWrap{
      position:absolute;right:12px;bottom:16px;z-index:7;width:120px;height:40px;
      border-radius:999px;border:1px solid rgba(255,255,255,.12);background:#121a2b;overflow:hidden;
      display:flex;align-items:center;justify-content:center;font-weight:800;color:#e8eef7
    }
    .nitroFill{position:absolute;left:2px;top:2px;bottom:2px;border-radius:999px;
      background:linear-gradient(180deg,#53ffb2,#1ecb7b);width:100%;}
    .nitroLabel{position:relative;z-index:1;pointer-events:none}

    /* Sound toggle */
    .soundBtn{position:absolute;right:12px;top:44px;z-index:9;display:flex;align-items:center;gap:8px;
      background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.12);color:#e8eef7;
      border-radius:999px;padding:8px 12px;font-size:12px;cursor:pointer;user-select:none}
    .dot{width:10px;height:10px;border-radius:50%;background:#40ff8a;box-shadow:0 0 6px #40ff8a;}
    .soundBtn.muted .dot{background:#ff4b4b;box-shadow:0 0 6px #ff4b4b;}

    /* END GAME POPUP */
    .endOverlay{
      position:absolute;inset:0;display:none;align-items:center;justify-content:center;z-index:12;
      background:linear-gradient(180deg, rgba(0,0,0,.45), rgba(0,0,0,.65));
    }
    .endCard{
      background:rgba(10,12,18,.96);border:1px solid rgba(255,255,255,.16);border-radius:14px;
      padding:16px 18px;display:flex;flex-direction:column;gap:12px;width:min(92%,480px)
    }
    .endStats{display:flex;gap:8px;flex-wrap:wrap}
    .endStats .pill .val{color:#fff}
    .endTitle{margin:0 0 2px 0;font-size:18px}
    .btnRow{display:flex;gap:8px;flex-wrap:wrap}
    .cityBtn{background:#1e2a44}

  </style>
</head>
<body>
  <div class="arena" id="arena">
    <!-- HUD -->
    <div class="hud">
      <div class="left hudGroup">
        <!-- Speedometer SVG pill -->
        <div class="speedoWrap" id="speedoWrap" title="Speed">
          <svg class="speedo" viewBox="0 0 140 52" aria-label="Speedometer">
            <defs>
              <linearGradient id="spdGrad" x1="0" y1="0" x2="0" y2="1">
                <stop offset="0%" stop-color="#9fe3ff"/><stop offset="100%" stop-color="#58a6ff"/>
              </linearGradient>
            </defs>
            <!-- arc -->
            <path d="M10,42 A60,60 0 0 1 130,42" fill="none" stroke="url(#spdGrad)" stroke-width="8" opacity=".4"/>
            <!-- ticks -->
            <g stroke="#cfe6ff" stroke-width="2" opacity=".55">
              <path d="M20 42 L24 36"/>
              <path d="M40 42 L43 34"/>
              <path d="M60 42 L62 32"/>
              <path d="M80 42 L81 32"/>
              <path d="M100 42 L99 34"/>
              <path d="M120 42 L116 36"/>
            </g>
            <!-- needle -->
            <g id="needle" transform="translate(70,42) rotate(-90)">
              <path d="M0 0 L3 -2 L46 0 L3 2 Z" fill="#ffed8a"/>
              <circle cx="0" cy="0" r="4" fill="#ffe06b" stroke="#342" stroke-width="1"/>
            </g>
            <!-- speed text -->
            <text id="speedTxt" x="70" y="18" font-size="12" text-anchor="middle" fill="#ffffff" style="font-weight:900;letter-spacing:.5px">0 km/h</text>
          </svg>
        </div>

        <!-- Distance -->
        <div class="pill" title="Distance">
          <span class="label">DIST</span>
          <span id="dist" class="val">0</span><span class="label">m</span>
        </div>

        <!-- Coins -->
        <div class="pill" title="Coins (synced)">
          <span class="label">COINS</span>
          <span id="coinsRun" class="val">0</span>
        </div>
      </div>

      <!-- Mini HUD: car + bomb strikes -->
      <div class="right">
        <div class="strikeHud">
          <canvas id="miniCar" width="60" height="24" style="filter:drop-shadow(0 0 2px rgba(0,0,0,.5))" aria-label="Car"></canvas>
          <div class="bombTray" aria-label="Strikes">
            <svg class="bombSvg" id="b1" viewBox="0 0 24 24">
              <circle class="shell" cx="12" cy="14" r="7"></circle>
              <circle class="fuse" cx="17" cy="7" r="3"></circle>
            </svg>
            <svg class="bombSvg" id="b2" viewBox="0 0 24 24">
              <circle class="shell" cx="12" cy="14" r="7"></circle>
              <circle class="fuse" cx="17" cy="7" r="3"></circle>
            </svg>
            <svg class="bombSvg" id="b3" viewBox="0 0 24 24">
              <circle class="shell" cx="12" cy="14" r="7"></circle>
              <circle class="fuse" cx="17" cy="7" r="3"></circle>
            </svg>
          </div>
        </div>
      </div>
    </div>

    <!-- Sound toggle -->
    <div id="soundBtn" class="soundBtn"><span class="dot"></span><span id="soundLabel">SOUND ON</span></div>

    <!-- Garage -->
    <div id="startOverlay" class="overlay">
      <div class="card hasBG" id="garageCard">
        <h3 style="margin:0">Garage</h3>
        <div class="hRow" style="opacity:.9;font-size:12px">
          <div>Player: <b id="wUser">—</b></div>
          <div>Coins: <b id="wCoins">—</b> &nbsp; | &nbsp; Crafting: <b id="wCraft">—</b></div>
        </div>

        <div class="preview" id="garagePreviewWrap">
          <canvas id="garagePreview" width="512" height="256" aria-label="Car Preview"></canvas>
          <div class="garageHint" id="garageHint">Tap START to race</div>
        </div>

        <!-- Track select -->
        <div>
          <div class="row" style="gap:8px;align-items:center">
            <div style="font-size:12px;margin:6px 0 2px">Track</div>
            <div class="trackRow">
              <button type="button" class="trackBtn active" data-track="night" id="trackNightBtn">Night</button>
              <button type="button" class="trackBtn" data-track="day" id="trackDayBtn">Day</button>
            </div>
          </div>
        </div>

        <!-- Paint tints -->
        <div>
          <div style="font-size:12px;margin:6px 0 8px">Paint (tint)</div>
          <div class="swatches" id="swatches"></div>
        </div>

        <button id="startBtn" class="startBtn">START</button>
      </div>
    </div>

    <!-- Nitro meter -->
    <div class="nitroWrap" id="nitroWrap" title="Hold to boost">
      <div class="nitroFill" id="nitroFill" style="width:100%"></div>
      <div class="nitroLabel">NITRO</div>
    </div>

    <!-- End of run popup -->
    <div id="endOverlay" class="endOverlay" aria-live="polite">
      <div class="endCard">
        <h3 class="endTitle">RACE OVER</h3>
        <div class="endStats">
          <span class="pill">Distance: <span class="val" id="finalDist">0</span> m</span>
          <span class="pill">Coins Earned: <span class="val" id="finalCoins">0</span></span>
          <span class="pill">Craft Credits: <span class="val" id="finalCraft">0</span></span>
        </div>
        <div class="btnRow">
          <button class="startBtn" id="againBtn">Play Again</button>
          <a class="cityBtn" id="cityBtn" href="/izza-game/play">GO TO IZZA CITY</a>
        </div>
      </div>
    </div>

    <!-- Background music -->
    <audio id="bgm" src="/static/game/audio/RACEBGM.wav" loop preload="auto"></audio>

    <canvas id="scene"></canvas>
  </div>

<script>
(() => {
/* ====== block selection/callouts while playing ====== */
['contextmenu','selectstart','gesturestart'].forEach(ev=>{
  window.addEventListener(ev, e=>e.preventDefault(), {passive:false});
});

/* ====== T & U params (auth passthrough like Basketball) ====== */
const T_KEY='izzaTokenT', U_KEY='izzaUserU';
const urlParams = new URLSearchParams(location.search);
let T = urlParams.get('t') || '';
let U = (urlParams.get('u') || '').toString().trim();
try{
  if (T) localStorage.setItem(T_KEY, T);
  else {
    const s = localStorage.getItem(T_KEY)||'';
    if (s){ const url=new URL(location.href); url.searchParams.set('t',s); history.replaceState(null,'',url.toString()); T=s; }
  }
}catch(_){}
function publishUsername(u){
  if (!u) return '';
  u = u.replace(/^@+/, '').toLowerCase();
  try{ localStorage.setItem(U_KEY, u); }catch(_){}
  window.__IZZA_PROFILE__ = Object.assign({}, window.__IZZA_PROFILE__, { username: u });
  window.izzaUserKey = { get: () => u };
  try{ if (!localStorage.getItem('piAuthUser')) localStorage.setItem('piAuthUser', JSON.stringify({ username: u })); }catch(_){}
  return u;
}
try{
  if (U) publishUsername(U);
  else {
    const su = (localStorage.getItem(U_KEY)||'').toString().trim();
    if (su){
      const url=new URL(location.href); url.searchParams.set('u',su);
      history.replaceState(null,'',url.toString()); U = publishUsername(su);
    }
  }
}catch(_){}
function withAuth(href){
  const url = new URL(href, location.origin);
  if (T) url.searchParams.set('t', T);
  if (U) url.searchParams.set('u', U);
  return url.pathname + (url.search ? url.search : '');
}
document.getElementById('cityBtn').href = withAuth('/izza-game/play');

/* ====== Wallet helper funcs (same behavior as Basketball) ====== */
function bearerHeaders(base = {}) {
  const headers = Object.assign({ 'content-type':'application/json' }, base || {});
  try{ const bearer = localStorage.getItem('izzaBearer') || ''; if (bearer) headers['authorization'] = 'Bearer ' + bearer; }catch(_){}
  return headers;
}
function parseWalletResponse(j){
  if (!j || typeof j !== 'object') return { coins:0, crafting:0 };
  if ('coins' in j || 'crafting' in j || 'credits' in j){
    return { coins: Number(j.coins)||0, crafting: Number(j.crafting ?? j.credits)||0 };
  }
  if (j.wallet)   return parseWalletResponse(j.wallet);
  if (j.balance)  return parseWalletResponse(j.balance);
  return { coins:0, crafting:0 };
}
const CRAFT_KEYS=['izzaCrafting','craftingCredits','izzaCraftCredits'];
function readCraftAny(){ for(const k of CRAFT_KEYS){ const v=parseInt(localStorage.getItem(k)||'0',10); if(Number.isFinite(v)&&v>0) return v|0; } return (parseInt(localStorage.getItem(CRAFT_KEYS[0])||'0',10)||0)|0; }
function writeCraftAll(v){ const n=Math.max(0,v|0); for(const k of CRAFT_KEYS) localStorage.setItem(k,String(n)); try{window.dispatchEvent(new Event('izza-crafting-changed'));}catch(_){ } }
function readCoinsLS(){ return (parseInt(localStorage.getItem('izzaCoins')||'0',10)|0); }
function writeCoinsLS(v){ localStorage.setItem('izzaCoins', String((v|0))); }
function publishWalletToHUD(wallet){
  const wCoins = document.getElementById('wCoins');
  const wCraft = document.getElementById('wCraft');
  if (wCoins) wCoins.textContent = (wallet && Number.isFinite(wallet.coins)) ? wallet.coins : '—';
  if (wCraft) wCraft.textContent = (wallet && Number.isFinite(wallet.crafting)) ? wallet.crafting : '—';
}
function publishUser(){
  const wUser = document.getElementById('wUser');
  if (wUser) wUser.textContent = (window.__IZZA_PROFILE__ && window.__IZZA_PROFILE__.username) ? '@' + window.__IZZA_PROFILE__.username : '—';
}

/* Wallet handoff (same pattern as Basketball) */
function consumeWalletHandoff(maxAgeMs = 120000){
  try{
    const raw = sessionStorage.getItem('izzaWalletHandoff');
    if(!raw) return null;
    const s = JSON.parse(raw);
    if(!s || !s.ts || (Date.now() - s.ts) > maxAgeMs) return null;

    if (s.user){
      const u = s.user.toString().trim().replace(/^@+/, '').toLowerCase();
      window.__IZZA_PROFILE__ = Object.assign({}, window.__IZZA_PROFILE__, { username: u });
      window.izzaUserKey = { get: () => u };
      try{ localStorage.setItem('izzaUserU', u); localStorage.setItem('piAuthUser', JSON.stringify({ username:u })); }catch(_){}
      U = u;
    }
    localStorage.setItem('izzaCoins', String(s.coins|0));
    localStorage.setItem('izzaCrafting', String(s.craft|0));
    return { coins:s.coins|0, craft:s.craft|0 };
  }catch(_){ return null; }
}

/* Hidden City iframe priming (same behavior as Basketball) */
function primeViaCityIframe({maxWaitMs=8000, pollMs=120} = {}){
  return new Promise((resolve)=>{
    let f=null, done=false, hard=null, poll=null;
    const finish=(why)=>{ if(done) return; done=true;
      try{ clearTimeout(hard); clearInterval(poll); f && f.remove(); }catch(_){}
      resolve(why||'ok');
    };
    const src = withAuth('/izza-game/play?prime=1&silent=1');
    f=document.createElement('iframe'); f.src=src;
    Object.assign(f.style,{position:'fixed',width:'0',height:'0',opacity:'0',pointerEvents:'none',border:'0'});
    document.body.appendChild(f);
    f.addEventListener('load', ()=>{
      try{
        const w=f.contentWindow; let tick=0;
        poll=setInterval(async ()=>{
          try{
            if (w?.IZZA_PERSIST?.load && tick<1){ tick++; await w.IZZA_PERSIST.load(); finish('iframe-load'); }
          }catch(_){}
        }, pollMs);
      }catch(_){}
    }, {once:true});
    hard=setTimeout(()=>finish('timeout'), maxWaitMs);
  });
}

/* Snapshot hydration */
function waitForPersistReady({timeout=3000, interval=40} = {}){
  return new Promise((res)=> {
    const t0 = performance.now();
    const check = () => {
      if (window.IZZA_PERSIST && typeof IZZA_PERSIST.load === 'function') return res(true);
      if (performance.now() - t0 > timeout) return res(false);
      setTimeout(check, interval);
    };
    if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', check, {once:true});
    else check();
  });
}
async function hydrateFromSnapshot(){
  try{
    await waitForPersistReady();
    if (window.IZZA_PERSIST && typeof IZZA_PERSIST.load === 'function'){
      await IZZA_PERSIST.load();  // server → LS
    }
  }catch(_){}
  try{ writeCraftAll(readCraftAny()); }catch(_){}
  return readCoinsLS();
}
async function ensureSession(){
  try{
    const r = await fetch(withAuth('/izza-game/api/character'), { credentials:'include', headers: bearerHeaders() });
    if (r.ok){
      const j = await r.json().catch(()=> ({}));
      const uname = (j.user && j.user.username) || j.username || j.handle || '';
      if (uname) { U = publishUsername(uname); try{ localStorage.setItem('izzaCharacter', JSON.stringify(j)); }catch(_){} }
    }
  }catch(_){}
}

/* ====== Basic UI Refs ====== */
const arena  = document.getElementById('arena');
const canvas = document.getElementById('scene');
const ctx    = canvas.getContext('2d', { alpha:true });
ctx.imageSmoothingEnabled = true;
ctx.imageSmoothingQuality = 'high';

const HUD = {
  dist : document.getElementById('dist'),
  coins: document.getElementById('coinsRun'),
  speedText: document.getElementById('speedTxt'),
  needle: document.getElementById('needle'),
  speedoWrap: document.getElementById('speedoWrap'),
};
const nitroWrap = document.getElementById('nitroWrap');
const nitroFill = document.getElementById('nitroFill');
const bgm = document.getElementById('bgm');
const soundBtn = document.getElementById('soundBtn');
const soundLabel = document.getElementById('soundLabel');

/* mini car canvas + strike SVGs */
const miniCar = document.getElementById('miniCar');
const miniCtx = miniCar.getContext('2d');
const strikeSvgs = [document.getElementById('b1'), document.getElementById('b2'), document.getElementById('b3')];

/* ======= Tunables ======= */
const OVERLAY_ALPHA = 0.10;

// Aurora + horizon glow
let AURORA_ALPHA  = 0.16, AURORA_SPEED = 0.06, AURORA_WOBBLE = 18;
let GLOW_ALPHA    = 0.26;

// Motion boosters (existing)
let STREAK_ALPHA  = 0.55;
let STREAK_SPEED  = 1.45;
let SMEAR_ALPHA   = 0.62;
let ASPHALT_ALPHA = 0.36;

// Hyperloop multipliers
const HYPER = { streaks:1.8, smear:1.6, asphalt:1.7, auroraW:1.6, zoom:1.07 };

/* Track assets */
let TRACK = 'night'; // 'night' | 'day'
const TRACK_BG = {
  night: '/static/game/sprites/road_bg.jpg',
  day:   '/static/game/sprites/daytrack_bg.jpg'
};
const GARAGE_BG = '/static/game/sprites/garage_bg.jpg';

const carImg = new Image();
carImg.src = '/static/game/sprites/tracks/coupe.png';
const bgImg = new Image();
bgImg.src = TRACK_BG[TRACK];

/* Garage card background */
(function setGarageBG(){
  const card = document.getElementById('garageCard');
  card.style.setProperty('--garage-bg', `url(${GARAGE_BG})`);
  card.style.backgroundImage = 'none';
  card.classList.add('hasBG');
  card.style.setProperty('--garage-bg-bright', '1');
  card.style.setProperty('--garage-bg-alpha', '.22');
  card.style.setProperty('--garage-bg-url', `url(${GARAGE_BG})`);
  card.style.setProperty('background-image', `linear-gradient(to bottom, rgba(0,0,0,.12), rgba(0,0,0,.18)), url(${GARAGE_BG})`);
})();

/* Track selector buttons */
const trackNightBtn = document.getElementById('trackNightBtn');
const trackDayBtn   = document.getElementById('trackDayBtn');
function setTrack(t){
  if (t !== 'night' && t !== 'day') return;
  TRACK = t;
  bgImg.src = TRACK_BG[t];
  trackNightBtn.classList.toggle('active', t==='night');
  trackDayBtn.classList.toggle('active', t==='day');

  // Brighten garage lighting on day track
  const card = document.getElementById('garageCard');
  if (t==='day'){
    card.style.setProperty('filter', 'brightness(1.05)');
    card.style.setProperty('background-image', `linear-gradient(to bottom, rgba(255,255,255,.06), rgba(0,0,0,.12)), url(${GARAGE_BG})`);
  } else {
    card.style.setProperty('filter', 'brightness(1.0)');
    card.style.setProperty('background-image', `linear-gradient(to bottom, rgba(0,0,0,.12), rgba(0,0,0,.18)), url(${GARAGE_BG})`);
  }
}
trackNightBtn.addEventListener('click', ()=> setTrack('night'));
trackDayBtn.addEventListener('click',   ()=> setTrack('day'));

/* Tinted sprite for garage preview and mini car */
function makeTintedSprite(rgb){
  if (!carImg.complete || !carImg.width) return null;
  const off = document.createElement('canvas');
  off.width  = carImg.width;
  off.height = carImg.height;
  const o = off.getContext('2d');
  o.drawImage(carImg, 0, 0);
  o.globalCompositeOperation = 'multiply';
  o.fillStyle = `rgb(${rgb.r},${rgb.g},${rgb.b})`;
  o.fillRect(0,0,off.width,off.height);
  o.globalCompositeOperation = 'destination-in';
  o.drawImage(carImg, 0, 0);
  o.globalCompositeOperation = 'source-atop';
  o.fillStyle = 'rgba(255,255,255,0.08)';
  o.fillRect(0,0,off.width,off.height);
  o.globalCompositeOperation = 'source-over';
  return off;
}

/* Garage Paint */
const PAINTS = [
  {name:'Cherry',    r:255, g:70,  b:70 },
  {name:'Sunburst',  r:255, g:190, b:40 },
  {name:'Neo Blue',  r:90,  g:180, b:255},
  {name:'Lime',      r:120, g:230, b:90 },
  {name:'Violet',    r:170, g:120, b:255},
  {name:'Graphite',  r:185, g:195, b:205}
];
let paint = JSON.parse(localStorage.getItem('izza_paint')||'null') || PAINTS[0];
let tintedSprite = null;
const swatches = document.getElementById('swatches');
PAINTS.forEach(p=>{
  const d = document.createElement('div');
  d.className = 'swatch';
  d.style.background = `rgb(${p.r},${p.g},${p.b})`;
  if (p.name===paint.name) d.classList.add('active');
  d.title = p.name;
  d.onclick = ()=>{
    paint = p;
    localStorage.setItem('izza_paint', JSON.stringify(paint));
    [...swatches.children].forEach(x=>x.classList.remove('active'));
    d.classList.add('active');
    rebuildTintAndPreview();
    drawMiniCar();
  };
  swatches.appendChild(d);
});
const prev = document.getElementById('garagePreview');
const pctx = prev.getContext('2d');
function rebuildTintAndPreview(){
  tintedSprite = makeTintedSprite(paint);
  if (!tintedSprite) return;
  pctx.clearRect(0,0,prev.width,prev.height);
  const pad = 8;
  const availW = prev.width - pad*2;
  const scale  = Math.min(availW / carImg.width, (prev.height-pad*2) / carImg.height);
  const w = Math.round(carImg.width * scale);
  const h = Math.round(carImg.height * scale);
  const x = Math.round((prev.width - w)/2);
  const y = Math.round((prev.height - h)/2);
  const cx = x + w/2, cy = y + h*0.92, rx = w*0.42, ry = h*0.10;
  const g = pctx.createRadialGradient(cx,cy,1,cx,cy,Math.max(rx,ry));
  g.addColorStop(0, `rgba(${paint.r},${paint.g},${paint.b},.22)`);
  g.addColorStop(1, `rgba(${paint.r},${paint.g},${paint.b},0)`);
  pctx.fillStyle = g;
  pctx.beginPath(); pctx.ellipse(cx,cy,rx,ry,0,0,Math.PI*2); pctx.fill();
  pctx.drawImage(tintedSprite, x, y, w, h);
}

/* mini car drawer */
function drawMiniCar(){
  if (!tintedSprite) return;
  miniCtx.clearRect(0,0,miniCar.width,miniCar.height);
  const scale = Math.min(miniCar.width / tintedSprite.width, miniCar.height / tintedSprite.height);
  const w = tintedSprite.width * scale;
  const h = tintedSprite.height * scale;
  miniCtx.drawImage(tintedSprite, (miniCar.width-w)/2, (miniCar.height-h)/2, w, h);
}
carImg.onload = ()=>{ rebuildTintAndPreview(); drawMiniCar(); };

/* ============== Sizing / Camera ============== */
let dpr=1, W=0, H=0;
let VANISH_Y = -800;
let TOP_FADE_PX=90;
let VPT_X=0, VPT_Y=0;
let roadBottomHalf=0, roadTopHalf=0;

function resize(){
  W = arena.clientWidth;
  H = arena.clientHeight;
  dpr = Math.min(window.devicePixelRatio || 1, 2);
  canvas.width  = Math.floor(W * dpr);
  canvas.height = Math.floor(H * dpr);
  canvas.style.width  = W + 'px';
  canvas.style.height = H + 'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);

  roadBottomHalf = W*1.02;
  roadTopHalf    = W*0.10;

  VANISH_Y = -Math.max(H * 0.8, 600);
  TOP_FADE_PX  = Math.max(60, Math.min(110, Math.round(H*0.10)));

  VPT_Y = H*0.62;

  buildNoise();
  updateCarPlacement();
}
window.addEventListener('resize', resize, {passive:true});

/* ============== Background (parallax) ============== */
let bgParallaxX = 0, bgTarget = 0;
function drawBackground(zoom=1){
  const carCenter = (carX + carW/2) / W;
  bgTarget = (carCenter - 0.5) * 28;
  bgParallaxX += (bgTarget - bgParallaxX) * 0.08;

  if (bgImg.complete && bgImg.naturalWidth) {
    const iw = bgImg.naturalWidth, ih = bgImg.naturalHeight;
    const r  = Math.max(W/iw, H/ih) * zoom;
    const nw = iw*r, nh = ih*r;
    const x  = (W - nw) / 2 + bgParallaxX;
    const y  = (H - nh) / 2;
    ctx.drawImage(bgImg, x, y, nw, nh);
  } else {
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, '#0c1120'); g.addColorStop(1, '#090d14');
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
  }
}

/* ---------- Aurora + horizon glow ---------- */
function drawAurora(t, hyperFactor=1){
  const topH = H*0.42;
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  ctx.globalAlpha = AURORA_ALPHA;
  const wob = AURORA_WOBBLE * (hyperFactor>1 ? HYPER.auroraW : 1);
  for (let i=0;i<3;i++){
    const phase = t*AURORA_SPEED*(i+1)*hyperFactor;
    const sway  = Math.sin(phase)*wob*(i?0.6:1);
    const gx = VPT_X + sway;
    const gy0 = 0, gy1 = topH;
    const g = ctx.createLinearGradient(gx, gy0, gx, gy1);
    g.addColorStop(0.00, 'rgba(0,255,255,0.55)');
    g.addColorStop(0.35, 'rgba(0,180,220,0.25)');
    g.addColorStop(1.00, 'rgba(0,120,180,0.00)');
    ctx.fillStyle = g;
    const w = W*0.32*(i?0.7:1);
    ctx.beginPath();
    ctx.moveTo(gx-w, gy0);
    ctx.lineTo(gx+w, gy0);
    ctx.lineTo(gx+w*0.7, gy1);
    ctx.lineTo(gx-w*0.7, gy1);
    ctx.closePath();
    ctx.fill();
  }
  ctx.restore();
}
function drawVanishingGlow(t, heat){
  const rBase = Math.min(W,H)*0.070;
  const pulse = 1 + 0.06*Math.sin(t*3.2);
  const r2 = rBase*(4.8 + heat*1.0)*pulse;
  const g = ctx.createRadialGradient(VPT_X, VPT_Y, 1, VPT_X, VPT_Y, r2);
  g.addColorStop(0,   `rgba(0,255,255,${0.70+0.25*heat})`);
  g.addColorStop(0.4, `rgba(0,200,255,${0.30+0.20*heat})`);
  g.addColorStop(1,   'rgba(0,200,255,0.00)');
  ctx.save();
  ctx.globalCompositeOperation = 'screen';
  ctx.globalAlpha = GLOW_ALPHA;
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.arc(VPT_X, VPT_Y, r2, 0, Math.PI*2); ctx.fill();
  ctx.restore();
}

/* Asphalt noise layer (scrolling) */
let noiseCanvas=null, noiseCtx=null, noiseW=512, noiseH=512;
function buildNoise(){
  noiseCanvas = document.createElement('canvas');
  noiseCanvas.width = noiseW; noiseCanvas.height = noiseH;
  noiseCtx = noiseCanvas.getContext('2d');

  noiseCtx.clearRect(0,0,noiseW,noiseH);
  noiseCtx.fillStyle = 'rgba(255,255,255,0.02)';
  noiseCtx.fillRect(0,0,noiseW,noiseH);
  const g = noiseCtx.createLinearGradient(0,0,noiseW,noiseH);
  g.addColorStop(0,'rgba(255,255,255,0.10)');
  g.addColorStop(1,'rgba(255,255,255,0.00)');
  noiseCtx.strokeStyle = g;
  for(let i=0;i<160;i++){
    const y = Math.random()*noiseH;
    noiseCtx.globalAlpha = 0.08 + Math.random()*0.10;
    noiseCtx.lineWidth = 1 + Math.random()*2;
    noiseCtx.beginPath();
    noiseCtx.moveTo(0,y);
    noiseCtx.lineTo(noiseW, y - 30 - Math.random()*60);
    noiseCtx.stroke();
  }
}

/* ======== Projection helpers ======== */
const lerp = (a,b,t)=>a+(b-a)*t;
function project(z){
  const k = 0.0105;
  const t = 1 - Math.exp(-k*z);
  const y   = lerp(VANISH_Y, H, t);
  const half= lerp(roadTopHalf, roadBottomHalf, t);
  return { y, half, t };
}

/* ======= Road params ======= */
const DEPTH_Z=24000, STEP_Z=48, RAIL_SCALE=1.08;
function edgesAt(z){
  const p = project(z);
  const y = Math.max(p.y, VANISH_Y);
  const half = (y === VANISH_Y) ? 0.0001 : p.half;
  return { y, lx: W/2 - half*RAIL_SCALE - 8, rx: W/2 + half*RAIL_SCALE + 8, t:p.t };
}

/* ======== SPEED GRID (no center dotted line) ======== */
function drawSpeedGrid(worldZ, speed, hyper=false){
  const baseAlpha = hyper ? 0.75 : 0.55;
  const edgeColor = `rgba(170,210,255,${baseAlpha})`;

  ctx.save();
  ctx.lineWidth = 1.4;
  ctx.setLineDash([6,10]);
  const dashShift = -(worldZ * (0.045 + speed/6000));

  // Left edge
  ctx.strokeStyle = edgeColor;
  ctx.lineDashOffset = dashShift;
  ctx.beginPath();
  let started=false;
  for (let z=0; z<=DEPTH_Z; z+=STEP_Z){
    const e = edgesAt(z);
    if (!started){ ctx.moveTo(e.lx, Math.min(e.y,H)); started=true; }
    else ctx.lineTo(e.lx, Math.min(e.y,H));
    if (e.y>H) break;
  }
  ctx.stroke();

  // Right edge
  ctx.beginPath();
  started=false;
  for (let z=0; z<=DEPTH_Z; z+=STEP_Z){
    const e = edgesAt(z);
    if (!started){ ctx.moveTo(e.rx, Math.min(e.y,H)); started=true; }
    else ctx.lineTo(e.rx, Math.min(e.y,H));
    if (e.y>H) break;
  }
  ctx.stroke();

  // Perspective rungs
  const rungStep = 260;
  const rungOffset = worldZ % rungStep;
  ctx.setLineDash([]);
  for (let z=rungStep - rungOffset; z<=DEPTH_Z; z+=rungStep){
    const e = edgesAt(z);
    if (e.y < VPT_Y + H*0.02) continue;
    const wL = e.lx, wR = e.rx;
    const alpha = Math.min(1, e.t*1.4) * (hyper ? 0.28 : 0.20);
    ctx.strokeStyle = `rgba(160,200,255,${alpha})`;
    ctx.lineWidth = 0.9 + e.t*1.2;
    ctx.beginPath();
    ctx.moveTo(wL + (wR-wL)*0.16, e.y);
    ctx.quadraticCurveTo(W*0.5, e.y - 10 - 90*(1-e.t), wR - (wR-wL)*0.16, e.y);
    ctx.stroke();
    if (e.y>H) break;
  }
  ctx.restore();
}

/* ======== Independent color wave (as-is) ======== */
function drawIndependentWave(worldZ, speed, hyper=false, heat=0, t=0){
  const APEX_LIFT = 22;
  const FAN_SPAN  = 1.40;
  const FAN_COUNT = 30;
  const FAN_LEN   = H * 2.10;
  const FAN_LEN_HYPER = H * 2.50;
  const WOBBLE_AMP = 16 * (hyper?1.2:1);
  const SPEED_K = Math.min(1, (speed/240)) * (hyper?1.25:1.0);

  const TIP_COLOR = { r: 80, g: 220, b: 255 };
  const TIP_ALPHA = 0.40;
  const START_FADE = 0.08;
  const MID_FADE   = 0.26;
  const BODY_ALPHA = 0.28 + 0.18*heat;

  const START_CUT  = 0.12;
  const LINE_BASE  = 7;
  const LINE_GAIN  = 20;

  const apexX = W*0.5;
  const apexY = (VPT_Y - 6) - APEX_LIFT;
  const span  = FAN_SPAN;
  const count = FAN_COUNT;
  const len   = hyper ? FAN_LEN_HYPER : FAN_LEN;

  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  ctx.globalAlpha = 0.42 + 0.18*SPEED_K;
  ctx.lineCap = 'butt';
  ctx.lineJoin = 'miter';

  for (let i = 0; i < count; i++){
    const u = i/(count-1);
    const ang = (-span/2) + u*span;

    const wob = Math.sin((worldZ*0.028) + t*3 + i*0.7) * WOBBLE_AMP;
    const x2  = apexX + Math.tan(ang)*(len*0.85) + wob;
    const y2  = H + 80;

    const sx = apexX + (x2 - apexX)*START_CUT;
    const sy = apexY + (y2 - apexY)*START_CUT;

    const grad = ctx.createLinearGradient(sx, sy, x2, y2);
    const tip = (a)=>`rgba(${TIP_COLOR.r},${TIP_COLOR.g},${TIP_COLOR.b},${a})`;
    grad.addColorStop(0.00, tip(0.00));
    grad.addColorStop(START_FADE, tip(TIP_ALPHA));
    grad.addColorStop(MID_FADE, tip(Math.max(0.18, BODY_ALPHA)));

    const base = (i%2===0)? `rgba(70,200,255,${BODY_ALPHA})` : `rgba(235,60,255,${BODY_ALPHA*0.9})`;
    grad.addColorStop(0.60, base);
    grad.addColorStop(1.00, 'rgba(0,0,0,0)');

    ctx.strokeStyle = grad;
    ctx.lineWidth = LINE_BASE + LINE_GAIN*SPEED_K*(hyper?1.10:1.0);

    ctx.beginPath();
    ctx.moveTo(sx, sy);
    ctx.lineTo(x2, y2);
    ctx.stroke();
  }

  ctx.restore();
}

/* ===== Motion streaks + side smears + asphalt scroll + tire beams ===== */
function drawMotion(worldZ, speed, hyper=false, heat=0){
  const hyperK = hyper ? HYPER : {streaks:1, smear:1, asphalt:1};
  const k = Math.min(1, (speed/240)) * STREAK_SPEED;

  const count = Math.round((hyper?58:42) * hyperK.streaks * (1+0.5*heat));
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  ctx.globalAlpha = STREAK_ALPHA*(hyper?1.08:1);
  for (let i=0;i<count;i++){
    const ang = (-0.52 + i/(count-1)*1.04);
    const len = H*(hyper?1.38:1.18);
    const wob = Math.sin((worldZ*0.033)+i)*10*(hyper?1.6:1);
    const x2 = VPT_X + Math.tan(ang)*(len*0.82) + wob;
    const y2 = H + 36;
    const grad = ctx.createLinearGradient(VPT_X, VPT_Y, x2, y2);
    const base = (i%2===0)? 'rgba(0,255,255,' : 'rgba(255,0,200,';
    grad.addColorStop(0.00, base + (0.75*k) + ')');
    grad.addColorStop(0.20, base + (0.45*k) + ')');
    grad.addColorStop(1.00, base + '0)');
    ctx.strokeStyle = grad;
    ctx.lineWidth = 2 + 14*k*(hyper?1.55:1.1);
    ctx.beginPath(); ctx.moveTo(VPT_X, VPT_Y); ctx.lineTo(x2, y2); ctx.stroke();
  }
  ctx.restore();

  const smearW = W*(hyper?0.46:0.38);
  const smearAlpha = (0.16 + SMEAR_ALPHA*0.9*k) * hyperK.smear * (1+0.25*heat);
  const smearG_L = ctx.createLinearGradient(0,0,smearW,0);
  smearG_L.addColorStop(0,   `rgba(0,0,0,${smearAlpha})`);
  smearG_L.addColorStop(1.0, 'rgba(0,0,0,0)');
  const smearG_R = ctx.createLinearGradient(W,0,W-smearW,0);
  smearG_R.addColorStop(0,   `rgba(0,0,0,${smearAlpha})`);
  smearG_R.addColorStop(1.0, 'rgba(0,0,0,0)');
  ctx.fillStyle = smearG_L; ctx.fillRect(0,0,smearW,H);
  ctx.fillStyle = smearG_R; ctx.fillRect(W-smearW,0,smearW,H);

  // road polygon clip
  const L=[], R=[];
  for (let z=0; z<=DEPTH_Z; z+=STEP_Z){ const e=edgesAt(z); L.push([e.lx,e.y]); R.push([e.rx,e.y]); }
  ctx.save();
  ctx.beginPath(); ctx.moveTo(W/2, VANISH_Y);
  for(let i=R.length-1;i>=0;i--) ctx.lineTo(R[i][0], Math.min(R[i][1],H));
  for(let i=0;i<L.length;i++)    ctx.lineTo(L[i][0], Math.min(L[i][1],H));
  ctx.closePath(); 
  ctx.clip();

  // perspective asphalt scroll
  const kspd = (2.0 + k*1.7) * hyperK.asphalt;
  const scroll = (worldZ * kspd) % noiseH;
  for(let y=-noiseH; y<H+noiseH; y+=noiseH){
    const near = Math.min(1, Math.max(0, (y+noiseH - VPT_Y) / (H - VPT_Y + 1)));
    ctx.globalAlpha = ASPHALT_ALPHA * (0.35 + 0.65*near) * (hyper?1.25:1);
    ctx.drawImage(noiseCanvas, 0, y + scroll, W, noiseH);
  }

  // tire glow beams
  const tireL = carX + carW*0.27;
  const tireR = carX + carW*0.73;
  const baseY = H*0.86;
  const laneHeight = H*(hyper?0.30:0.24);
  ctx.globalAlpha = 0.26 + 0.28*k*(hyper?1.2:1);
  ctx.globalCompositeOperation = 'lighter';
  const lane = (x)=>{
    const gg = ctx.createLinearGradient(x, baseY, x, baseY+laneHeight);
    gg.addColorStop(0,'rgba(0,255,255,0.00)');
    gg.addColorStop(0.25,`rgba(0,255,255,${0.30+0.32*k})`);
    gg.addColorStop(1,'rgba(0,255,255,0.00)');
    ctx.fillStyle = gg;
    ctx.beginPath();
    ctx.ellipse(x, baseY+laneHeight*0.55, W*0.070, laneHeight*0.58, 0, 0, Math.PI*2);
    ctx.fill();
  };
  lane(tireL); lane(tireR);
  ctx.restore();

  // hyper vignette
  ctx.save();
  const inner = Math.min(W,H)*0.10;
  const outer = Math.max(W,H)*(hyper?0.78:0.66)*(1-0.10*heat);
  const vg = ctx.createRadialGradient(VPT_X, VPT_Y, inner, VPT_X, VPT_Y, outer);
  vg.addColorStop(0,'rgba(0,0,0,0)');
  vg.addColorStop(1,`rgba(0,0,0,${hyper? (0.40+0.12*heat) : 0.20})`);
  ctx.fillStyle = vg;
  ctx.fillRect(0,0,W,H);
  ctx.restore();
}

/* ======= Headlights ======= */
function drawHeadlights(){
  const leftRoot  = { x: carX + carW*0.32, y: carY + carH*0.74 };
  const rightRoot = { x: carX + carW*0.68, y: carY + carH*0.74 };
  const aim = { x: VPT_X, y: VPT_Y - 12 };

  const drawBeam = (root, spread)=> {
    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    const gx = ctx.createLinearGradient(root.x, root.y, aim.x, aim.y);
    gx.addColorStop(0, 'rgba(120,220,255,0.55)');
    gx.addColorStop(0.25,'rgba(80,200,255,0.28)');
    gx.addColorStop(1, 'rgba(80,200,255,0.00)');
    ctx.fillStyle = gx;
    ctx.beginPath();
    ctx.moveTo(root.x - spread, root.y);
    ctx.lineTo(root.x + spread, root.y);
    ctx.lineTo(aim.x + spread*0.35, aim.y);
    ctx.lineTo(aim.x - spread*0.35, aim.y);
    ctx.closePath(); ctx.fill();

    const gy = ctx.createLinearGradient(root.x, root.y, aim.x, aim.y);
    gy.addColorStop(0, 'rgba(180,255,255,0.90)');
    gy.addColorStop(0.2,'rgba(120,240,255,0.50)');
    gy.addColorStop(1, 'rgba(120,240,255,0.00)');
    ctx.fillStyle = gy;
    ctx.beginPath();
    ctx.moveTo(root.x - spread*0.45, root.y);
    ctx.lineTo(root.x + spread*0.45, root.y);
    ctx.lineTo(aim.x + spread*0.22, aim.y);
    ctx.lineTo(aim.x - spread*0.22, aim.y);
    ctx.closePath(); ctx.fill();
    ctx.restore();
  };

  const baseSpread = Math.max(10, carW*0.06);
  drawBeam(leftRoot,  baseSpread);
  drawBeam(rightRoot, baseSpread);
}

/* ======= Road overlay shading ======= */
function drawRoad(){
  const L=[], R=[];
  for (let z=0; z<=DEPTH_Z; z+=STEP_Z){
    const e = edgesAt(z);
    if (e.y>H && L.length && R.length) break;
    L.push([e.lx, e.y]); R.push([e.rx, e.y]);
  }
  ctx.save();
  ctx.beginPath();
  ctx.moveTo(W/2, VANISH_Y);
  for (let i=R.length-1;i>=0;i--) ctx.lineTo(R[i][0], Math.min(R[i][1], H));
  for (let i=0;i<L.length;i++)    ctx.lineTo(L[i][0], Math.min(L[i][1], H));
  ctx.closePath();
  ctx.clip();

  const roadG = ctx.createLinearGradient(0, VANISH_Y, 0, H);
  roadG.addColorStop(0, 'rgba(15,20,29,1)');
  roadG.addColorStop(1, 'rgba(10,15,23,1)');
  ctx.globalAlpha = OVERLAY_ALPHA;
  ctx.fillStyle = roadG;
  ctx.fillRect(0, 0, W, H);
  ctx.globalAlpha = 1;

  const topFade = ctx.createLinearGradient(0, 0, 0, TOP_FADE_PX);
  topFade.addColorStop(0, 'rgba(0,0,0,1)');
  topFade.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.globalCompositeOperation = 'destination-out';
  ctx.fillStyle = topFade;
  ctx.fillRect(0, 0, W, TOP_FADE_PX);
  ctx.globalCompositeOperation = 'source-over';
  ctx.restore();
}

/* =================== PARTICLES =================== */
const particles = [];
class Particle{
  constructor(x,y, vx,vy, life, size, color, glow=0, grav=0){
    this.x=x; this.y=y; this.vx=vx; this.vy=vy;
    this.life=life; this.age=0; this.size=size; this.color=color;
    this.glow=glow; this.grav=grav;
  }
  step(dt){
    this.age+=dt; if(this.age>=this.life) return false;
    this.vy += this.grav*dt;
    this.x += this.vx*dt; this.y += this.vy*dt;
    return true;
  }
  draw(ctx){
    const t = 1 - (this.age/this.life);
    ctx.save();
    if (this.glow>0){
      ctx.globalCompositeOperation='lighter';
      ctx.shadowBlur = this.glow;
      ctx.shadowColor = this.color;
    }
    ctx.globalAlpha = t;
    ctx.fillStyle = this.color;
    ctx.beginPath(); ctx.ellipse(this.x, this.y, this.size, this.size*0.8, 0, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }
}
function burstCoins(x,y, count=16){
  for(let i=0;i<count;i++){
    const a = Math.random()*Math.PI*2;
    const s = 180 + Math.random()*220;
    particles.push(new Particle(
      x + (Math.random()*12-6),
      y + (Math.random()*8-4),
      Math.cos(a)*s,
      Math.sin(a)*s - 60,
      0.5+Math.random()*0.35,
      3+Math.random()*2,
      'rgba(255,220,80,1)', 10, 600
    ));
  }
}
function burstNitro(x,y, count=12){
  for(let i=0;i<count;i++){
    const a = Math.random()*Math.PI*2;
    const s = 140 + Math.random()*180;
    particles.push(new Particle(
      x, y,
      Math.cos(a)*s, Math.sin(a)*s - 40,
      0.45+Math.random()*0.35,
      3+Math.random()*2,
      'rgba(80,255,200,1)', 12, 500
    ));
  }
}
function explodeBomb(x,y){
  for(let i=0;i<24;i++){
    const a = (i/24)*Math.PI*2;
    const s = 160 + Math.random()*220;
    particles.push(new Particle(
      x, y,
      Math.cos(a)*s, Math.sin(a)*s,
      0.55+Math.random()*0.35,
      4+Math.random()*3,
      'rgba(255,120,40,1)', 14, 420
    ));
  }
  for(let i=0;i<18;i++){
    const a = Math.random()*Math.PI*2;
    const s = 40 + Math.random()*90;
    particles.push(new Particle(
      x, y,
      Math.cos(a)*s, Math.sin(a)*s - 30,
      0.9+Math.random()*0.6,
      6+Math.random()*4,
      'rgba(60,60,70,0.9)', 0, 120
    ));
  }
}

/* =================== AUDIO =================== */
let AC=null, master=null, sfxGain=null, musicGain=null;
let muted = JSON.parse(localStorage.getItem('izza_muted')||'false');

function ensureAudio(){
  if (AC) return;
  AC = new (window.AudioContext||window.webkitAudioContext)();
  master = AC.createGain(); master.gain.value = muted?0:1; master.connect(AC.destination);
  sfxGain = AC.createGain(); sfxGain.gain.value = 0.9; sfxGain.connect(master);
  musicGain = AC.createGain(); musicGain.gain.value = 0.6; musicGain.connect(master);
  const src = AC.createMediaElementSource(bgm);
  src.connect(musicGain);
}
function clickStartAudio(){
  ensureAudio();
  if (AC.state === 'suspended') AC.resume();
  if (!bgmStarted){
    try{ bgm.currentTime = 0; bgm.play(); }catch(e){}
    bgmStarted = true;
  }
}
let bgmStarted=false;

function playCoin(){
  ensureAudio();
  const o = AC.createOscillator();
  const g = AC.createGain();
  o.type='triangle';
  o.frequency.setValueAtTime(620, AC.currentTime);
  o.frequency.exponentialRampToValueAtTime(1240, AC.currentTime+0.08);
  g.gain.setValueAtTime(0.0001, AC.currentTime);
  g.gain.exponentialRampToValueAtTime(0.7, AC.currentTime+0.01);
  g.gain.exponentialRampToValueAtTime(0.001, AC.currentTime+0.15);
  o.connect(g); g.connect(sfxGain); o.start(); o.stop(AC.currentTime+0.16);
}
function playNitroPickup(){
  ensureAudio();
  const n = AC.createBuffer(1, AC.sampleRate*0.18, AC.sampleRate);
  const d = n.getChannelData(0);
  for(let i=0;i<d.length;i++){ d[i] = (Math.random()*2-1) * Math.pow(1-i/d.length, 2); }
  const s = AC.createBufferSource(); s.buffer = n;
  const f = AC.createBiquadFilter(); f.type='highpass'; f.frequency.value = 500;
  const g = AC.createGain(); g.gain.value = 0.8;
  s.connect(f); f.connect(g); g.connect(sfxGain);
  s.start(); s.stop(AC.currentTime+0.18);
}
function playBomb(){
  ensureAudio();
  const n = AC.createBuffer(1, AC.sampleRate*0.5, AC.sampleRate);
  const d = n.getChannelData(0);
  for(let i=0;i<d.length;i++){ d[i] = (Math.random()*2-1) * Math.pow(1-i/d.length, 0.6); }
  const s = AC.createBufferSource(); s.buffer = n; s.playbackRate.value = 0.9;
  const f = AC.createBiquadFilter(); f.type='lowpass'; f.frequency.value = 220;
  const g = AC.createGain(); g.gain.setValueAtTime(1.0, AC.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001, AC.currentTime+0.5);
  s.connect(f); f.connect(g); g.connect(sfxGain);
  s.start(); s.stop(AC.currentTime+0.52);
}
let nitroLoop = null;
function setNitroWhoosh(on){
  ensureAudio();
  if (on){
    if (nitroLoop) return;
    const noiseBuf = AC.createBuffer(1, AC.sampleRate*2, AC.sampleRate);
    const ch = noiseBuf.getChannelData(0);
    for(let i=0;i<ch.length;i++){ ch[i] = Math.random()*2-1; }
    const src = AC.createBufferSource(); src.buffer = noiseBuf; src.loop = true;
    const bp = AC.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value = 900; bp.Q.value = 0.9;
    const g = AC.createGain(); g.gain.value = 0.0001;
    src.connect(bp); bp.connect(g); g.connect(sfxGain);
    const now = AC.currentTime;
    g.gain.exponentialRampToValueAtTime(0.6, now+0.08);
    src.start();
    nitroLoop = {src, g};
  } else {
    if (!nitroLoop) return;
    const now = AC.currentTime;
    nitroLoop.g.gain.exponentialRampToValueAtTime(0.0001, now+0.12);
    try{ nitroLoop.src.stop(now+0.14); }catch(e){}
    nitroLoop = null;
  }
}

/* Sound toggle */
function applyMuteUI(){
  soundBtn.classList.toggle('muted', muted);
  soundLabel.textContent = muted? 'SOUND OFF' : 'SOUND ON';
  if (master) master.gain.value = muted?0:1;
  localStorage.setItem('izza_muted', JSON.stringify(muted));
}
soundBtn.addEventListener('click', ()=>{
  muted = !muted; applyMuteUI();
  if (!muted) clickStartAudio();
});
applyMuteUI();

/* =================== PICKUPS =================== */
class Pickup {
  constructor(type, spawnZ, laneT){
    this.type = type;
    this.spawnZ = spawnZ;
    this.laneT = laneT;
    this.spin = Math.random()*Math.PI*2;
    this.alive = true;
  }
  zRel(worldZ){ return Math.max(0, worldZ - this.spawnZ); }

  draw(worldZ){
    const z = this.zRel(worldZ);
    if (z>DEPTH_Z) { this.alive=false; return; }
    const e = edgesAt(z);

    // Clamp below horizon for readability
    const startClamp = VPT_Y + H*0.02;
    let y = Math.max(e.y, startClamp);
    const x = e.lx + (e.rx-e.lx)*this.laneT;

    const ease = (p)=>p*p*(3-2*p);
    const s = 0.030 + ease(e.t) * 0.90;

    const carMid = carX + carW*0.5;
    const aligned = Math.abs(x - carMid) < W*0.12;
    if (aligned && e.t>0.75){
      const t2 = (e.t-0.75)/0.25;
      y += (H*0.92 - y) * t2 * 0.85;
    }

    this.spin += 0.15 + (this.type==='coin'?0.22:0.12);

    if (this.type==='coin')      drawCoin(x,y,s,this.spin);
    else if (this.type==='nitro')drawNitro(x,y,s*1.06,this.spin);
    else                         drawBomb(x,y,s*1.12,this.spin);

    // HARD DESPAWN
    if (y > H*0.97 || e.t > 0.995) this.alive = false;
  }

  hitTest(carRect, worldZ){
    const z = this.zRel(worldZ);
    const e = edgesAt(z);
    const x = e.lx + (e.rx-e.lx)*this.laneT;
    const startClamp = VPT_Y + H*0.02;
    const y = Math.max(e.y, startClamp);
    const r = 12 + 40*e.t;
    const cx=x, cy=y;
    const nx = Math.max(carRect.x, Math.min(cx, carRect.x+carRect.w));
    const ny = Math.max(carRect.y, Math.min(cy, carRect.y+carRect.h));
    const dx = cx-nx, dy = cy-ny;

    /* Middle lane strict-center */
    const isMiddleLane = Math.abs(this.laneT - 0.50) < 1e-3;
    if (isMiddleLane){
      const carCenter = carX + carW*0.5;
      const centerEps = Math.max(8, W*0.02);
      if (Math.abs(carCenter - W*0.5) > centerEps) return false;
    }

    return (dx*dx + dy*dy) < (r*r*0.85);
  }
}

/* Procedural sprites for pickups */
function drawCoin(x,y,s,ang){
  const w = 26*s, h = 26*s*Math.max(0.28, Math.abs(Math.cos(ang)));
  ctx.save();
  ctx.translate(x,y);
  ctx.globalCompositeOperation='lighter';
  ctx.fillStyle='rgba(255,214,70,0.95)'; ctx.beginPath(); ctx.ellipse(0,0,w,h,0,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='rgba(255,186,0,1)';     ctx.beginPath(); ctx.ellipse(0,0,w*0.82,h*0.82,0,0,Math.PI*2); ctx.fill();
  ctx.globalCompositeOperation='source-over';
  ctx.fillStyle='rgba(40,28,0,0.7)';
  ctx.font = `${Math.max(8,10*s)}px Arial Black`;
  ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('IZZA',0,0);
  ctx.restore();
}
function drawNitro(x,y,s,ang){
  const w = 16*s, h = 34*s;
  ctx.save(); ctx.translate(x,y); ctx.rotate(Math.sin(ang)*0.25);
  const g = ctx.createLinearGradient(0,-h/2,0,h/2);
  g.addColorStop(0,'#65ffd1'); g.addColorStop(1,'#17a56a');
  ctx.fillStyle=g; ctx.strokeStyle='rgba(0,0,0,0.35)'; ctx.lineWidth=2;
  if (!CanvasRenderingContext2D.prototype.roundRect){
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      r = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+r, y);
      this.arcTo(x+w, y, x+w, y+h, r);
      this.arcTo(x+w, y+h, x, y+h, r);
      this.arcTo(x, y+h, x, y, r);
      this.arcTo(x, y, x+w, y, r);
      return this;
    };
  }
  ctx.beginPath(); ctx.roundRect(-w/2,-h/2,w,h,6); ctx.fill(); ctx.stroke();
  ctx.fillStyle='rgba(0,0,0,0.25)'; ctx.fillRect(-w*0.45,-h*0.05,w*0.9,h*0.1);
  ctx.fillStyle='rgba(255,255,255,0.9)';
  ctx.font=`${Math.max(6,8*s)}px Arial Black`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('N2O',0,0);
  ctx.fillStyle='#0e2130'; ctx.fillRect(-w*0.25,-h*0.62,w*0.5,h*0.14);
  ctx.restore();
}
function drawBomb(x,y,s,ang){
  const r = 16*s;
  ctx.save(); ctx.translate(x,y); ctx.rotate(ang*0.7);
  ctx.fillStyle='rgba(30,30,35,1)'; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
  ctx.globalCompositeOperation='lighter';
  const flick = 0.6+0.4*Math.sin(ang*3);
  ctx.fillStyle=`rgba(255,120,20,${0.5+0.5*flick})`;
  ctx.beginPath(); ctx.arc(r*0.6,-r*0.6,4+2*flick,0,Math.PI*2); ctx.fill();
  ctx.restore();
}

/* ============== CAR + FX ============== */
let carW=0, carH=0, carX=0, carY=0;
function updateCarPlacement(){
  carW = Math.min(W*0.78, 480);
  const ratio = (carImg.height||512) / (carImg.width||1024);
  carH = carW * ratio;
  carX = Math.round((W - carW)/2);
  carY = Math.round(H - carH*1.02);
  VPT_X = carX + carW*0.5;
  drawMiniCar();
}
function carRect(){ return {x:carX+carW*0.18, y:carY+carH*0.30, w:carW*0.64, h:carH*0.52}; }

function buildCarFXCanvas(nitroBoost, t){
  const fx = document.createElement('canvas');
  fx.width = Math.max(2, Math.floor(carW));
  fx.height = Math.max(2, Math.floor(carH));
  const c = fx.getContext('2d');

  const flick = 0.75 + 0.25*Math.sin(t*12);
  const lightY = carH*0.50;
  const leftX  = carW*0.29;
  const rightX = carW*0.71;

  c.globalCompositeOperation = 'lighter';
  c.shadowBlur = 22;
  c.shadowColor = `rgba(255,60,40,${0.85*flick})`;
  c.fillStyle   = `rgba(255,70,50,${0.55*flick})`;
  const lamp = (x) => {
    c.beginPath();
    c.moveTo(x-18, lightY);
    c.lineTo(x+18, lightY);
    c.lineTo(x+8,  lightY+10);
    c.lineTo(x-8,  lightY+10);
    c.closePath(); c.fill();
  };
  lamp(leftX); lamp(rightX);

  const flame = (nitroBoost? 1.0 : 0.35) * (0.7+0.3*Math.sin(t*20));
  c.shadowBlur  = 28;
  c.shadowColor = `rgba(${paint.r},${paint.g},${paint.b},1)`;
  c.fillStyle   = `rgba(${paint.r},${paint.g},${paint.b},${0.22+0.35*flame})`;
  const jet = (x) => {
    c.beginPath();
    c.moveTo(x, carH*0.82);
    c.quadraticCurveTo(x-12, carH*0.92, x, carH*1.02);
    c.quadraticCurveTo(x+12, carH*0.92, x, carH*0.82);
    c.closePath(); c.fill();
  };
  jet(carW*0.33);
  jet(carW*0.67);

  return fx;
}

/* ============== INPUT ============== */
let time = 0;
const steer = { x:0, nitro:false };
canvas.addEventListener('pointerdown', e=>{
  const x = e.clientX - canvas.getBoundingClientRect().left;
  steer.x = (x < W/2) ? -1 : 1;
  clickStartAudio();
});
canvas.addEventListener('pointermove', e=>{
  if (e.buttons) {
    const x = e.clientX - canvas.getBoundingClientRect().left;
    steer.x = (x < W/2) ? -1 : 1;
  }
});
window.addEventListener('pointerup', ()=>{ steer.x=0; });
window.addEventListener('keydown', e=>{
  if(e.key==='ArrowLeft')  steer.x=-1;
  if(e.key==='ArrowRight') steer.x=1;
  if(e.key.toLowerCase()===' ') steer.nitro=true;
  clickStartAudio();
});
window.addEventListener('keyup', e=>{
  if(e.key==='ArrowLeft' || e.key==='ArrowRight') steer.x = 0;
  if(e.key.toLowerCase()===' ') steer.nitro=false;
});

/* Nitro meter hold */
function bindNitroHold(el){
  const on=()=>{ steer.nitro=true; clickStartAudio(); };
  const off=()=>{ steer.nitro=false; };
  el.addEventListener('pointerdown', e=>{ e.preventDefault(); on(); });
  window.addEventListener('pointerup', off);
  el.addEventListener('touchstart', e=>{ e.preventDefault(); on(); }, {passive:false});
  el.addEventListener('touchend', off);
}
bindNitroHold(nitroWrap);

/* ============== GAME STATE ============== */
let worldZ = 0, last = performance.now();
const state = { running:false, speed:0, dist:0, bombsHit:0 };
let nitro = 1.0; // 0..1 meter
let heat = 0;    // nitro “glow heat” 0..1
let nitroActive = false;

/* pickups & spawn controller */
let lastSpawn = 0;
const pickups = [];
const LANE_TS = [0.26, 0.50, 0.74];

/* Safety planner to avoid impossible collisions */
const MIN_LANE_SEP_Z = 640;             // per-lane separation (slightly denser than before)
const MIN_MULTI_SEP_Z = 380;            // avoid horizontal walling (keep items staggered in Z)
const laneLastSpawnZ = [ -1e9, -1e9, -1e9 ];
let lastMultiZ = -1e9;

// Faster cadence (~100ms baseline) with mild scaling + nitro cut
function currentSpawnInterval(){
  const base = 100;                                 // was 420 → much quicker
  const far  = Math.max(0, Math.min(1, state.dist/2500)); // keep your scaling
  const hyperCut = nitroActive ? 0.50 : 1.0;        // slightly faster during nitro
  const jitter = 0.90 + Math.random()*0.25;         // keep some randomness
  return base * (1.0 - 0.25*far) * hyperCut * jitter;
}
function bombChance(){
  // never block all lanes; this is just raw desire, planner enforces safety
  const d = Math.max(0, Math.min(1, state.dist/4000));
  return 0.22 + d*0.38; // up to ~60%
}

/* Decide safe lane mask near a given Z */
function computeUnsafeLanes(targetZ){
  // mark lanes that would conflict with MIN_MULTI_SEP_Z around targetZ
  const unsafe=[false,false,false];
  for (const p of pickups){
    if (!p.alive) continue;
    const z = p.spawnZ;
    if (Math.abs(z - targetZ) < MIN_MULTI_SEP_Z){
      const li = LANE_TS.indexOf(p.laneT);
      if (li>=0) unsafe[li]=true;
    }
  }
  return unsafe;
}
function spawnOne(z0 = worldZ){
  // --- tunables for spacing / cadence (keeps room to dodge) ---
  const DODGE_GAP_Z      = 170;   // stagger gap if we add a quick follow-up
  const BOMB_EXTRA_GAP_Z = 220;   // extra room after bombs
  const MULTI_PROB       = 0.28;  // ↑ more frequent quick follow-ups

  // which lanes are available by per-lane spacing?
  const spaceOK = [];
  for (let i=0;i<LANE_TS.length;i++){
    if (z0 - laneLastSpawnZ[i] >= MIN_LANE_SEP_Z) spaceOK.push(i);
  }
  if (spaceOK.length === 0) return;

  // avoid same-Z lane walls near existing pickups
  const unsafe = computeUnsafeLanes(z0);
  let candidates = spaceOK.filter(i => !unsafe[i]);
  if (candidates.length === 0) {
    // pick the safest by largest gap since last spawn
    let best = 0, bestScore = -1e9;
    for (const i of spaceOK){
      const score = z0 - laneLastSpawnZ[i];
      if (score > bestScore){ bestScore = score; best = i; }
    }
    candidates = [best];
  }

  // --- choose ONE lane randomly for this tick ---
  const li = candidates[(Math.random()*candidates.length)|0];
  const laneT = LANE_TS[li];

  // type selection (mostly coins, some bombs, some nitro)
  let type = 'coin';
  const roll = Math.random();
  const pNitro = 0.14 * (1 - Math.min(0.7, state.dist/6000));
  const pBomb  = 0.22 + Math.min(0.28, state.dist/5000);
  if (roll < pNitro) type = 'nitro';
  else if (roll < pNitro + pBomb) type = 'bomb';

  // prevent three-bomb walls at ~same Z across all lanes
  if (type === 'bomb'){
    const nearSameZ = pickups.filter(p => p.alive && p.type==='bomb' && Math.abs(p.spawnZ - z0) < MIN_MULTI_SEP_Z);
    const bombLanes = new Set(nearSameZ.map(p=>p.laneT));
    bombLanes.add(laneT);
    if (bombLanes.size >= 3) type = 'coin';
  }

  // place primary item now
  pickups.push(new Pickup(type, z0, laneT));
  laneLastSpawnZ[li] = z0 + (type==='bomb' ? BOMB_EXTRA_GAP_Z : 0); // hold lane a bit longer if bomb

  // --- occasional quick follow-up in another lane, staggered in Z ---
  if (Math.random() < MULTI_PROB){
    const targetZ = z0 + DODGE_GAP_Z;
    const unsafe2 = computeUnsafeLanes(targetZ);
    const others = LANE_TS.map((_,i)=>i).filter(i =>
      i!==li && (targetZ - laneLastSpawnZ[i] >= MIN_LANE_SEP_Z) && !unsafe2[i]
    );
    if (others.length){
      const li2 = others[(Math.random()*others.length)|0];
      const laneT2 = LANE_TS[li2];

      const roll2 = Math.random();
      let type2 = roll2 < 0.10 ? 'nitro' : (roll2 < 0.30 ? 'bomb' : 'coin');

      // safety: don’t double-bomb in this pair
      if (type==='bomb' && type2==='bomb') type2 = 'coin';

      // safety: also forbid creating a three-bomb wall near targetZ
      if (type2 === 'bomb'){
        const near2 = pickups.filter(p => p.alive && p.type==='bomb' && Math.abs(p.spawnZ - targetZ) < MIN_MULTI_SEP_Z);
        const bombLanes2 = new Set(near2.map(p=>p.laneT));
        bombLanes2.add(laneT2);
        if (bombLanes2.size >= 3) type2 = 'coin';
      }

      pickups.push(new Pickup(type2, targetZ, laneT2));
      laneLastSpawnZ[li2] = targetZ + (type2==='bomb' ? BOMB_EXTRA_GAP_Z : 0);
      lastMultiZ = targetZ;
    }
  }
}
/* Nitro consumption / heat */
function useNitro(dt){
  const can = nitro>0.02;
  const wasActive = nitroActive;
  nitroActive = steer.nitro && can;
  if (nitroActive){ nitro = Math.max(0, nitro - dt*0.25); heat = Math.min(1, heat + dt*2.4); }
  else            { heat = Math.max(0, heat - dt*1.6); }
  if (nitroActive !== wasActive) setNitroWhoosh(nitroActive);
  nitroFill.style.width = Math.round(nitro*100)+'%';
  HUD.speedoWrap.classList.toggle('shake', nitroActive);
}

/* Strikes: update SVG bombs */
function updateStrikes(){
  for(let i=0;i<3;i++){
    const on = i < state.bombsHit;
    strikeSvgs[i].classList.toggle('hit', on);
  }
}

/* Speedometer needle and text */
function updateSpeedo(speed){
  // map 0..300 km/h to -90..+90 deg
  const clamped = Math.max(0, Math.min(300, speed));
  const deg = -90 + (clamped/300)*180;
  HUD.needle.setAttribute('transform', `translate(70,42) rotate(${deg.toFixed(1)})`);
  HUD.speedText.textContent = Math.round(clamped) + ' km/h';
}

/* END GAME popup (called after 3rd strike) */
function showEndPopup(coinsEarned, craftEarned){
  const end = document.getElementById('endOverlay');
  document.getElementById('finalDist').textContent  = Math.round(state.dist);
  document.getElementById('finalCoins').textContent = coinsEarned|0;
  document.getElementById('finalCraft').textContent = craftEarned|0;
  end.style.display = 'flex';
}

/* draw car last */
function drawCar(nitroBoost){
  const src = tintedSprite || carImg;
  ctx.drawImage(src, carX, carY, carW, carH);
  const fx = buildCarFXCanvas(nitroBoost, time);
  ctx.globalCompositeOperation = 'lighter';
  ctx.drawImage(fx, carX, carY);
  ctx.globalCompositeOperation = 'source-over';
}

/* ======= WALLET HUD ======= */
let WALLET_READY = false, walletDirty=false, runStartCoins=0, runStartCraft=0;
function paintCoinsHUD(n){
  const val = Math.max(0, n|0);
  HUD.coins.textContent = String(val);
}
function updateCoinsHUD(){
  if(!WALLET_READY) return;
  const cur = readCoinsLS();
  const shown = parseInt(HUD.coins.textContent||'0',10) || 0;
  const val = (cur===0 && shown>0) ? shown : cur;
  paintCoinsHUD(val);
}
function syncCoinsHUD(){ updateCoinsHUD(); }
async function applyCoins(amount){
  const cur = (readCoinsLS()|0) + (amount|0);
  writeCoinsLS(cur);
  walletDirty = true;
  try{ window.dispatchEvent(new Event('izza-coins-changed')); }catch(_){}
  try{ if (window.IZZA_PERSIST?.save){ await IZZA_PERSIST.save(); walletDirty = false; } }catch(_){}
  try{ window.dispatchEvent(new CustomEvent('izza-wallet-changed', { detail:{ coins:cur, crafting:readCraftAny() } })); }catch(_){}
  WALLET_READY = true; updateCoinsHUD(); return cur;
}
async function applyCraftDelta(delta){
  const val = readCraftAny() + (delta|0);
  writeCraftAll(val);
  walletDirty = true;
  try{ if (window.IZZA_PERSIST?.save){ await IZZA_PERSIST.save(); walletDirty = false; } }catch(_){}
  try{ window.dispatchEvent(new CustomEvent('izza-wallet-changed', { detail:{ coins: readCoinsLS(), crafting:val } })); }catch(_){}
}

/* ============== MAIN LOOP ============== */
let coinsThisRun = 0;
function frame(now){
  if(!state.running) return;
  const dt = Math.min(0.033, (now - last)/1000); last = now;
  time += dt;

  // Nitro & speed
  useNitro(dt);
  const target = (nitroActive ? 270 : 190);
  state.speed += (target - state.speed) * 0.10;
  updateSpeedo(state.speed);

  const hyper = nitroActive;
  const mps = state.speed / 3.6 * (hyper?1.22:1);
  worldZ += mps * dt;
  state.dist += mps * dt;

  // Spawns (denser but safe)
  if (now - lastSpawn > currentSpawnInterval()) {
    lastSpawn = now; spawnOne();
  }

  // steering + anchor visuals to car center
  const steerSpeed = Math.max(2.6, W * 0.0072) * (hyper?1.08:1);
  carX += steer.x * steerSpeed;
  const off = carW*0.12;
  carX = Math.max(-off, Math.min(W - carW + off, carX));
  VPT_X = carX + carW*0.5;

  // Draw
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawBackground(hyper?HYPER.zoom:1);
  drawRoad();

  drawIndependentWave(worldZ, state.speed, hyper, heat, time);
  drawSpeedGrid(worldZ, state.speed, hyper);

  drawAurora(time, hyper?1.25:1);
  drawVanishingGlow(time, heat);

  drawMotion(worldZ, state.speed, hyper, heat);
  drawHeadlights();

  // Colliders
  const cRect = carRect();

  // Quick chain-spawn distance after a pickup (keeps flow continuous)
  const CHAIN_GAP_Z = 140;

  // Pickups + collisions + FX
  for (const p of pickups) {
    if (!p.alive) continue;
    p.draw(worldZ);
    if (!p.alive) continue;

    if (p.hitTest(cRect, worldZ)) {
      p.alive = false;

      // screen-space for particles
      const ez = p.zRel(worldZ);
      const e  = edgesAt(ez);
      const x  = e.lx + (e.rx-e.lx)*p.laneT;
      const y  = Math.max(e.y, VPT_Y + H*0.02);

      if (p.type === 'coin') {
        coinsThisRun += 100;
        burstCoins(x,y);
        playCoin();
      } else if (p.type === 'nitro') {
        nitro = Math.min(1, nitro + 0.25);
        burstNitro(x,y);
        playNitroPickup();
      } else {
        state.bombsHit++;
        updateStrikes();
        explodeBomb(x,y);
        playBomb();

        if (state.bombsHit >= 3) {
          // Show third red bomb first, then popup
          updateStrikes();
          endRun(); // will pop overlay after wallet/craft sync
          return;
        }
      }

      // 🔗 Instant follow-up spawn(s) to reduce gaps between items.
      // Spawn regardless of type, but avoid doing so if the run just ended.
      if (state.bombsHit < 3) {
        spawnOne(worldZ + CHAIN_GAP_Z);
        // Extra occasional second follow-up for smoother chains when not a bomb
        if (p.type !== 'bomb' && Math.random() < 0.45) {
          spawnOne(worldZ + CHAIN_GAP_Z * 2);
        }
      }
    }
  }
  for (let i = pickups.length - 1; i >= 0; i--) if (!pickups[i].alive) pickups.splice(i, 1);

  // Particles
  for (let i=particles.length-1; i>=0; i--){
    if (!particles[i].step(dt)) { particles.splice(i,1); continue; }
    particles[i].draw(ctx);
  }

  // Apply coins in HUD smoothly from run pot (batch)
  if (coinsThisRun >= 100){
    const toApply = coinsThisRun - (coinsThisRun % 100);
    coinsThisRun -= toApply;
    applyCoins(toApply);
  }

  drawCar(nitroActive);

  // HUD
  HUD.dist.textContent  = Math.round(state.dist);

  requestAnimationFrame(frame);
}

/* ======= START / END ======= */
const startOverlay = document.getElementById('startOverlay');
const endOverlay = document.getElementById('endOverlay');

function softHide(el){ if(el) el.style.display='none'; }
function softShow(el){ if(el) el.style.display='flex'; }

async function persistWalletAndSave(){
  try{
    writeCraftAll(readCraftAny());
    if (window.IZZA_PERSIST && typeof IZZA_PERSIST.save === 'function'){ await IZZA_PERSIST.save(); walletDirty = false; }
    else if (typeof window._izzaForceSave === 'function'){ window._izzaForceSave(); walletDirty = false; }
  }catch(_){}
}

async function endRun(){
  if (!state.running) return;
  state.running=false;
  try{ bgm.pause(); }catch(_){}
  setNitroWhoosh(false);

  // finalize run coins still buffered
  if (coinsThisRun>0){
    await applyCoins(coinsThisRun);
    coinsThisRun = 0;
  }

  // Craft credits: every 1000 coins earned this run
  const coinsNow = readCoinsLS();
  const coinsEarned = Math.max(0, (coinsNow|0) - (runStartCoins|0));
  const craftEarned = Math.floor(coinsEarned / 1000);
  if (craftEarned>0) await applyCraftDelta(craftEarned);

  // Save and show popup (but ensure third bomb was shown red already)
  try{ const p = persistWalletAndSave(); await Promise.race([p, new Promise(r=>setTimeout(r, 180))]); }catch(_){}

  // Publish stats
  showEndPopup(coinsEarned, craftEarned);
}

function resetStateForRun(){
  tintedSprite = makeTintedSprite(paint);
  state.running   = true;
  state.speed     = 90;
  state.dist      = 0;
  worldZ          = 0;
  last            = performance.now();
  state.bombsHit  = 0;
  updateStrikes();
  nitro           = 1.0;
  heat            = 0.0;
  nitroFill.style.width = '100%';
  pickups.length  = 0;
  particles.length= 0;
  laneLastSpawnZ[0]=laneLastSpawnZ[1]=laneLastSpawnZ[2]=-1e9;
  lastSpawn       = performance.now();
  lastMultiZ      = -1e9;
  coinsThisRun    = 0;
}

document.getElementById('againBtn').addEventListener('click', async ()=>{
  endOverlay.style.display='none';
  startOverlay.style.display='flex';
});

/* init sizing early */
resize();

/* ======= START button flow (like Basketball) ======= */
document.getElementById('startBtn').addEventListener('click', async ()=>{
  try{
    // Player name on card
    publishUser();

    // 0) Wallet handoff from Arena if present
    const handoff = consumeWalletHandoff();
    if (handoff){ publishWalletToHUD({coins:handoff.coins, crafting:handoff.craft}); paintCoinsHUD(handoff.coins); }

    // 1) Prime session via hidden City iframe
    try{ await primeViaCityIframe(); }catch(_){}

    // 2) Best-effort session check (no redirect)
    try{ await ensureSession(); }catch(_){}
    publishUser();

    // 3) Hydrate from Persist snapshot (server → LS)
    const snapCoins = await hydrateFromSnapshot();

    // do not regress the shown value after snapshot
    {
      const shown = parseInt((HUD.coins.textContent||'0'), 10) || 0;
      const safe = Math.max(shown, snapCoins, readCoinsLS()||0);
      paintCoinsHUD(safe);
    }

    // 4) Authoritative wallet fetch; adopt without decreasing
    try{
      const r = await fetch(withAuth('/izza-game/api/wallet'), { credentials:'include', headers: bearerHeaders() });
      if (r.ok){
        const parsed = parseWalletResponse(await r.json().catch(()=>({})));
        const apiCoins = Number(parsed.coins)||0;
        const apiCraft = Number(parsed.crafting)||0;

        const shown = parseInt((HUD.coins.textContent||'0'), 10) || 0;
        const nextCoins = Math.max(shown, apiCoins);

        try{
          localStorage.setItem('izzaCoins', String(nextCoins));
          if (apiCraft>=0) writeCraftAll(apiCraft);
          window.dispatchEvent(new Event('izza-coins-changed'));
          window.dispatchEvent(new Event('izza-crafting-changed'));
        }catch(_){}

        paintCoinsHUD(nextCoins);
        publishWalletToHUD({coins:nextCoins, crafting:readCraftAny()});
      } else {
        publishWalletToHUD({coins:readCoinsLS(), crafting:readCraftAny()});
      }
    }catch(_){
      publishWalletToHUD({coins:readCoinsLS(), crafting:readCraftAny()});
    }

    WALLET_READY = true;
    runStartCoins = parseInt((HUD.coins.textContent||'0'), 10) || (readCoinsLS()||0);
    runStartCraft = readCraftAny()|0;

    // Apply track choice to background immediately
    bgImg.src = TRACK_BG[TRACK];

    // Enter race
    startOverlay.style.display='none';
    endOverlay.style.display='none';
    resize();
    resetStateForRun();

    if (!muted){ clickStartAudio(); }
    requestAnimationFrame(frame);
  }catch(e){
    console.error('start failed', e);
  }
}, {passive:true});

/* Garage preview day/night hint */
(function(){
  const wrap = document.getElementById('garagePreviewWrap');
  function paintHint(){
    const hint = document.getElementById('garageHint');
    hint.textContent = (TRACK==='day') ? 'Day track selected' : 'Night track selected';
  }
  trackNightBtn.addEventListener('click', paintHint);
  trackDayBtn.addEventListener('click', paintHint);
  paintHint();
})();

/* END overlay links keep auth */
(function keepAuthOnCity(){
  const a = document.getElementById('cityBtn');
  a.setAttribute('href', withAuth(a.getAttribute('href')));
})();

/* Wallet listeners (as in Basketball) */
window.addEventListener('storage', (e)=>{
  if (e && (e.key === 'izzaCoins' || (e.key && CRAFT_KEYS.includes(e.key)))) updateCoinsHUD();
});
window.addEventListener('izza-coins-changed', syncCoinsHUD);
window.addEventListener('izza-wallet-changed', syncCoinsHUD);
window.addEventListener('izza-crafting-changed', syncCoinsHUD);
document.addEventListener('visibilitychange', async () => {
  if (document.hidden){
    if (walletDirty) { try{ await persistWalletAndSave(); }catch(_){ } }
  } else {
    updateCoinsHUD();
  }
});
window.addEventListener('pagehide', () => {
  if (walletDirty && window.IZZA_PERSIST && typeof IZZA_PERSIST.save === 'function'){
    try{ IZZA_PERSIST.save(); walletDirty = false; }catch(_){}
  }
});

/* ======= INIT ======= */
rebuildTintAndPreview();
drawMiniCar();

})();
</script>
</body>
</html>
