<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Street Race — IZZA GAME</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  <!-- Persist base -->
  <script>window.IZZA_PERSIST_BASE='https://izzagame.onrender.com';</script>
  <script src="/static/game/js/izza-persist.js"></script>

  <link rel="stylesheet" href="/static/themes.css">
  <style>
    :root { --bg:#0a0c12; --panel:#06080e; --hud:rgba(0,0,0,.55); --hudLine:rgba(255,255,255,.18); --ok:#72ff9d; --bad:#ff5b5b; }
    html,body{height:100%}
    body{
      margin:0;background:var(--bg);color:#e8eef7;font-family:Arial,Helvetica,sans-serif;
      -webkit-user-select:none; user-select:none; -webkit-touch-callout:none;
    }
    .topbar{max-width:520px;margin:0 auto;padding:8px 12px;display:flex;justify-content:space-between;gap:8px}
    .btn{display:inline-flex;align-items:center;gap:8px;border:1px solid var(--hudLine);
         background:rgba(255,255,255,.06);padding:8px 12px;border-radius:10px;color:inherit;text-decoration:none;font-size:13px}
    .btn:hover{filter:brightness(1.06)}

    .arena{position:relative;height:100vh;max-width:520px;margin:0 auto;
      border-left:1px solid rgba(255,255,255,.08);
      border-right:1px solid rgba(255,255,255,.08);
      background:var(--panel);overflow:hidden}

    /* HUD */
    .hud{position:absolute;top:8px;left:8px;right:8px;z-index:9;display:flex;justify-content:space-between;align-items:center;gap:8px}
    .hud .left, .hud .right{display:flex;align-items:center;gap:6px}

    /* Exciting small font vibe */
    .tag{background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.16);border-radius:999px;padding:4px 8px;font-weight:900;letter-spacing:.3px;font-size:11px;text-shadow:0 1px 6px rgba(0,0,0,.35)}
    .tag .val{font-size:13px; margin-left:4px}

    /* Speedometer SVG */
    .speedWrap{display:flex;align-items:center;gap:6px}
    .speedSVG{width:88px;height:44px;filter:drop-shadow(0 2px 10px rgba(0,0,0,.5));transition:transform .06s}
    .speedSVG.nitroShake{transform:rotate(-1.5deg) translateY(-1px)}
    .speedNeedle{transform-origin:50% 100%}
    .speedLabel{font-weight:900;font-size:11px;letter-spacing:.4px;opacity:.9}

    /* Mini HUD (mini car + bombs) */
    .strikeHud{display:flex;align-items:center;gap:8px}
    .bombTray{display:flex;gap:4px;align-items:center}
    .bombIcon{width:20px;height:20px;opacity:.85;transition:filter .12s}
    .bombIcon .bombBody{fill:#2c2f39}
    .bombIcon .bombSpark{fill:#ffaa40}
    .bombIcon.hit .bombBody{fill:#ff3b3b}
    .bombIcon.hit{filter:drop-shadow(0 0 6px #ff3b3b)}

    /* Overlays / cards */
    .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:8;
      background:linear-gradient(to bottom, rgba(0,0,0,.7), rgba(0,0,0,.55));}
    .card{background:rgba(10,12,18,.95);border:1px solid rgba(255,255,255,.16);border-radius:14px;
      padding:16px 18px;display:flex;flex-direction:column;gap:12px;width:min(92%,480px)}
    .row{display:flex;gap:10px;align-items:center;justify-content:space-between;flex-wrap:wrap}
    .preview{height:164px;border:1px dashed rgba(255,255,255,.18);border-radius:12px;
      display:flex;align-items:center;justify-content:center;overflow:hidden;position:relative}
    .startBtn{padding:12px 16px;border-radius:10px;border:1px solid rgba(255,255,255,.1);
      background:rgba(255,255,255,.08);font-weight:800;color:white;width:100%}
    .swatches{display:flex;gap:10px;flex-wrap:wrap}
    .swatch{width:26px;height:26px;border-radius:50%;border:2px solid rgba(255,255,255,.28);cursor:pointer}
    .swatch.active{box-shadow:0 0 0 3px rgba(255,255,255,.18) inset}
    .trackPick{display:flex;gap:8px}
    .trackBtn{padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.18);background:rgba(255,255,255,.06);font-weight:800;font-size:12px;cursor:pointer}
    .trackBtn.active{box-shadow:0 0 0 2px rgba(255,255,255,.2) inset}

    canvas{display:block;width:100%;height:100%;background:transparent;touch-action:none;
      -webkit-user-select:none; user-select:none; -webkit-touch-callout:none;}

    /* Nitro meter */
    .nitroWrap{position:absolute;right:8px;bottom:12px;z-index:7;width:120px;height:40px;
      border-radius:999px;border:1px solid rgba(255,255,255,.12);background:#121a2b;overflow:hidden;
      display:flex;align-items:center;justify-content:center;font-weight:800;color:#e8eef7}
    .nitroFill{position:absolute;left:2px;top:2px;bottom:2px;border-radius:999px;
      background:linear-gradient(180deg,#53ffb2,#1ecb7b);width:100%;}
    .nitroLabel{position:relative;z-index:1;pointer-events:none}

    /* Sound toggle */
    .soundBtn{position:absolute;right:8px;top:8px;z-index:9;display:flex;align-items:center;gap:8px;
      background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.12);color:#e8eef7;
      border-radius:999px;padding:8px 12px;font-size:12px;cursor:pointer;user-select:none}
    .dot{width:10px;height:10px;border-radius:50%;background:#40ff8a;box-shadow:0 0 6px #40ff8a;}
    .soundBtn.muted .dot{background:#ff4b4b;box-shadow:0 0 6px #ff4b4b;}

    /* Finish popup */
    .finishRow{display:flex;gap:10px;flex-wrap:wrap}
    .pill{background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.16);border-radius:999px;padding:6px 10px;font-size:12px;font-weight:800}
  </style>
</head>
<body>

  <!-- Nav with auth-preserving links -->
  <div class="topbar">
    <a class="btn" id="backBtn" href="/izza-game/minigames">← Back to Arena</a>
    <a class="btn" id="cityBtnTop" href="/izza-game/play">Enter IZZA City</a>
  </div>

  <div class="arena" id="arena">
    <!-- HUD -->
    <div class="hud">
      <div class="left">
        <div class="speedWrap">
          <svg class="speedSVG" id="speedSVG" viewBox="0 0 160 80" aria-label="Speedometer">
            <defs>
              <linearGradient id="spdGrad" x1="0" y1="0" x2="0" y2="1">
                <stop offset="0%" stop-color="#fffad2"/><stop offset="100%" stop-color="#ffc74d"/>
              </linearGradient>
            </defs>
            <!-- bezel -->
            <path d="M10,70 A60,60 0 0 1 150,70" fill="none" stroke="rgba(255,255,255,.2)" stroke-width="10" />
            <!-- arc -->
            <path id="spdArc" d="M20,70 A50,50 0 0 1 140,70" fill="none" stroke="url(#spdGrad)" stroke-width="8" stroke-linecap="round" opacity=".9"/>
            <!-- ticks -->
            <g stroke="rgba(255,255,255,.5)" stroke-width="2" opacity=".6">
              <!-- simple 7 ticks -->
              <line x1="40" y1="66" x2="40" y2="58"/>
              <line x1="60" y1="66" x2="60" y2="58"/>
              <line x1="80" y1="66" x2="80" y2="56"/>
              <line x1="100" y1="66" x2="100" y2="58"/>
              <line x1="120" y1="66" x2="120" y2="58"/>
            </g>
            <!-- needle -->
            <g transform="translate(80,70)">
              <rect x="-2" y="-44" width="4" height="44" fill="#ff6a00" class="speedNeedle" id="needle"/>
              <circle cx="0" cy="0" r="5" fill="#ff6a00"/>
            </g>
          </svg>
          <div class="speedLabel"><span id="speedVal">0</span> km/h</div>
        </div>

        <div class="tag">DIST<span class="val" id="dist">0</span></div>
        <div class="tag">COINS<span class="val" id="coinsRun">0</span></div>
      </div>

      <!-- Mini HUD (mini car + bomb SVGs) -->
      <div class="right">
        <div class="strikeHud">
          <canvas id="miniCar" width="60" height="24" style="filter:drop-shadow(0 0 2px rgba(0,0,0,.5))"></canvas>
          <div class="bombTray">
            <svg class="bombIcon" id="b1" viewBox="0 0 24 24">
              <circle class="bombBody" cx="12" cy="13" r="7"/>
              <rect x="11" y="4" width="2" height="5" rx="1" fill="#444955"/>
              <circle class="bombSpark" cx="17.5" cy="4.5" r="2.5"/>
            </svg>
            <svg class="bombIcon" id="b2" viewBox="0 0 24 24">
              <circle class="bombBody" cx="12" cy="13" r="7"/>
              <rect x="11" y="4" width="2" height="5" rx="1" fill="#444955"/>
              <circle class="bombSpark" cx="17.5" cy="4.5" r="2.5"/>
            </svg>
            <svg class="bombIcon" id="b3" viewBox="0 0 24 24">
              <circle class="bombBody" cx="12" cy="13" r="7"/>
              <rect x="11" y="4" width="2" height="5" rx="1" fill="#444955"/>
              <circle class="bombSpark" cx="17.5" cy="4.5" r="2.5"/>
            </svg>
          </div>
        </div>
      </div>
    </div>

    <!-- Sound toggle -->
    <div id="soundBtn" class="soundBtn"><span class="dot"></span><span id="soundLabel">SOUND ON</span></div>

    <!-- Garage (start overlay) -->
    <div id="startOverlay" class="overlay">
      <div class="card">
        <h3 style="margin:0">Garage</h3>
        <div class="row" style="opacity:.9;font-size:12px">
          <span>Player: <b id="wUser">—</b></span>
          <span>Coins: <b id="wCoins">—</b></span>
          <span>Crafting: <b id="wCraft">—</b></span>
        </div>
        <div class="preview">
          <!-- Garage background placeholder (will use /static/game/sprites/garage_bg.jpg if present) -->
          <img id="garageBG" alt="" style="position:absolute;inset:0;width:100%;height:100%;object-fit:cover;opacity:.25;pointer-events:none;display:none">
          <canvas id="garagePreview" width="512" height="256"></canvas>
        </div>

        <div class="row">
          <div style="font-size:12px;margin:6px 0 8px">Paint (tint)</div>
          <div class="swatches" id="swatches"></div>
        </div>

        <div class="row">
          <div style="font-size:12px;margin:6px 0 8px">Track</div>
          <div class="trackPick">
            <button class="trackBtn active" data-track="night" id="pickNight">Night</button>
            <button class="trackBtn" data-track="day" id="pickDay">Day</button>
          </div>
        </div>

        <div class="row">
          <button id="startBtn" class="startBtn">START</button>
        </div>
      </div>
    </div>

    <!-- Finish overlay -->
    <div id="finishOverlay" class="overlay" style="display:none">
      <div class="card">
        <h3 style="margin:0">Run Complete</h3>
        <div class="finishRow">
          <span class="pill">Distance: <b id="finDist">0</b> m</span>
          <span class="pill">Coins Earned: <b id="finCoins">0</b></span>
          <span class="pill">Craft Credits: <b id="finCraft">0</b></span>
        </div>
        <div class="row" style="gap:8px">
          <a class="btn" id="againBtn" href="/izza-game/minigames">Play Again</a>
          <a class="btn" id="cityBtn" href="/izza-game/play">GO TO IZZA CITY</a>
        </div>
      </div>
    </div>

    <!-- Nitro meter -->
    <div class="nitroWrap" id="nitroWrap" title="Hold to boost">
      <div class="nitroFill" id="nitroFill" style="width:100%"></div>
      <div class="nitroLabel">NITRO</div>
    </div>

    <!-- Background music -->
    <audio id="bgm" src="/static/game/audio/RACEBGM.wav" loop preload="auto"></audio>

    <canvas id="scene"></canvas>
  </div>

<script>
(() => {
/* ===================== Auth / Wallet plumb-in (mirrors Basketball) ===================== */
const T_KEY='izzaTokenT', U_KEY='izzaUserU';
const urlParams = new URLSearchParams(location.search);
let T = urlParams.get('t') || '';
let U = (urlParams.get('u') || '').toString().trim();

try{
  if (T) localStorage.setItem(T_KEY, T);
  else {
    const s = localStorage.getItem(T_KEY)||'';
    if (s){ const url=new URL(location.href); url.searchParams.set('t',s); history.replaceState(null,'',url.toString()); T=s; }
  }
}catch(_){}

function publishUsername(u){
  if (!u) return;
  u = u.replace(/^@+/, '').toLowerCase();
  try{ localStorage.setItem(U_KEY, u); }catch(_){}
  window.__IZZA_PROFILE__ = Object.assign({}, window.__IZZA_PROFILE__, { username: u });
  window.izzaUserKey = { get: () => u };
  try{ if (!localStorage.getItem('piAuthUser')) localStorage.setItem('piAuthUser', JSON.stringify({ username: u })); }catch(_){}
  return u;
}

try{
  if (U) publishUsername(U);
  else {
    const su = (localStorage.getItem(U_KEY)||'').toString().trim();
    if (su){
      const url=new URL(location.href); url.searchParams.set('u',su);
      history.replaceState(null,'',url.toString()); U = publishUsername(su);
    }
  }
}catch(_){}

function withAuth(href){
  const url = new URL(href, location.origin);
  if (T) url.searchParams.set('t', T);
  if (U) url.searchParams.set('u', U);
  return url.pathname + (url.search ? url.search : '');
}
document.getElementById('backBtn').href = withAuth('/izza-game/minigames');
document.getElementById('cityBtnTop').href = withAuth('/izza-game/play');
document.getElementById('cityBtn').href = withAuth('/izza-game/play');
document.getElementById('againBtn').href = withAuth('/izza-game/minigames');

/* Helpers from Basketball */
function bearerHeaders(base = {}) {
  const headers = Object.assign({ 'content-type':'application/json' }, base || {});
  try{ const bearer = localStorage.getItem('izzaBearer') || ''; if (bearer) headers['authorization'] = 'Bearer ' + bearer; }catch(_){}
  return headers;
}
function parseWalletResponse(j){
  if (!j || typeof j !== 'object') return { coins:0, crafting:0 };
  if ('coins' in j || 'crafting' in j || 'credits' in j){
    return { coins: Number(j.coins)||0, crafting: Number(j.crafting ?? j.credits)||0 };
  }
  if (j.wallet)   return parseWalletResponse(j.wallet);
  if (j.balance)  return parseWalletResponse(j.balance);
  return { coins:0, crafting:0 };
}
const CRAFT_KEYS=['izzaCrafting','craftingCredits','izzaCraftCredits'];
function readCraftAny(){ for(const k of CRAFT_KEYS){ const v=parseInt(localStorage.getItem(k)||'0',10); if(Number.isFinite(v)&&v>0) return v|0; } return (parseInt(localStorage.getItem(CRAFT_KEYS[0])||'0',10)||0)|0; }
function writeCraftAll(v){ const n=Math.max(0,v|0); for(const k of CRAFT_KEYS) localStorage.setItem(k,String(n)); try{window.dispatchEvent(new Event('izza-crafting-changed'));}catch(_){ } }
function readCoinsLS(){ return (parseInt(localStorage.getItem('izzaCoins')||'0',10)|0); }
function writeCoinsLS(v){ localStorage.setItem('izzaCoins', String((v|0))); }

/* Handoff & snapshot hydrate (Mayor enters) */
function consumeWalletHandoff(maxAgeMs = 120000){
  try{
    const raw = sessionStorage.getItem('izzaWalletHandoff');
    if(!raw) return null;
    const s = JSON.parse(raw);
    if(!s || !s.ts || (Date.now() - s.ts) > maxAgeMs) return null;

    if (s.user){
      const u = s.user.toString().trim().replace(/^@+/, '').toLowerCase();
      window.__IZZA_PROFILE__ = Object.assign({}, window.__IZZA_PROFILE__, { username: u });
      window.izzaUserKey = { get: () => u };
      try{ localStorage.setItem('izzaUserU', u); localStorage.setItem('piAuthUser', JSON.stringify({ username:u })); }catch(_){}
      U = u;
    }
    localStorage.setItem('izzaCoins', String(s.coins|0));
    localStorage.setItem('izzaCrafting', String(s.craft|0));
    return { coins:s.coins|0, craft:s.craft|0, user:U };
  }catch(_){ return null; }
}
function waitForPersistReady({timeout=3000, interval=40} = {}){
  return new Promise((res)=> {
    const t0 = performance.now();
    const check = () => {
      if (window.IZZA_PERSIST && typeof IZZA_PERSIST.load === 'function') return res(true);
      if (performance.now() - t0 > timeout) return res(false);
      setTimeout(check, interval);
    };
    if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', check, {once:true});
    else check();
  });
}
async function primeViaCityIframe({maxWaitMs=8000, pollMs=120} = {}){
  return new Promise((resolve)=>{
    let f=null, done=false, hard=null, poll=null;
    const finish=(why)=>{ if(done) return; done=true;
      try{ clearTimeout(hard); clearInterval(poll); f && f.remove(); }catch(_){}
      resolve(why||'ok');
    };
    const src = withAuth('/izza-game/play?prime=1&silent=1');
    f=document.createElement('iframe'); f.src=src;
    Object.assign(f.style,{position:'fixed',width:'0',height:'0',opacity:'0',pointerEvents:'none',border:'0'});
    document.body.appendChild(f);
    f.addEventListener('load', ()=>{
      try{
        const w=f.contentWindow; let tick=0;
        poll=setInterval(async ()=>{
          try{
            if (w?.IZZA_PERSIST?.load && tick<1){ tick++; await w.IZZA_PERSIST.load(); finish('iframe-load'); }
          }catch(_){}
        }, pollMs);
      }catch(_){}
    }, {once:true});
    hard=setTimeout(()=>finish('timeout'), maxWaitMs);
  });
}
async function hydrateFromSnapshot(){
  try{
    await waitForPersistReady();
    if (window.IZZA_PERSIST && typeof IZZA_PERSIST.load === 'function'){
      await IZZA_PERSIST.load();  // server → LS
    }
  }catch(_){}
  try{ writeCraftAll(readCraftAny()); }catch(_){}
  return readCoinsLS();
}
async function ensureSession(){
  try{
    const r = await fetch(withAuth('/izza-game/api/character'), { credentials:'include', headers: bearerHeaders() });
    if (r.ok){
      const j = await r.json().catch(()=> ({}));
      const uname = (j.user && j.user.username) || j.username || j.handle || '';
      if (uname) { U = publishUsername(uname); try{ localStorage.setItem('izzaCharacter', JSON.stringify(j)); }catch(_){} }
    }
  }catch(_){}
}
async function persistWalletAndSave(){
  try{
    writeCraftAll(readCraftAny());
    if (window.IZZA_PERSIST && typeof IZZA_PERSIST.save === 'function'){ await IZZA_PERSIST.save(); }
    else if (typeof window._izzaForceSave === 'function'){ window._izzaForceSave(); }
  }catch(_){}
}

/* ===================== Base Setup ===================== */
['contextmenu','selectstart','gesturestart'].forEach(ev=>{
  window.addEventListener(ev, e=>e.preventDefault(), {passive:false});
});

const arena  = document.getElementById('arena');
const canvas = document.getElementById('scene');
const ctx    = canvas.getContext('2d', { alpha:true });
ctx.imageSmoothingEnabled = true;
ctx.imageSmoothingQuality = 'high';

const HUD = {
  speedVal: document.getElementById('speedVal'),
  speedSVG: document.getElementById('speedSVG'),
  needle  : document.getElementById('needle'),
  dist    : document.getElementById('dist'),
  coins   : document.getElementById('coinsRun')
};
const nitroWrap = document.getElementById('nitroWrap');
const nitroFill = document.getElementById('nitroFill');
const bgm = document.getElementById('bgm');
const soundBtn = document.getElementById('soundBtn');
const soundLabel = document.getElementById('soundLabel');

/* mini car canvas + bomb icons */
const miniCar = document.getElementById('miniCar');
const miniCtx = miniCar.getContext('2d');
const strikeDots = [document.getElementById('b1'), document.getElementById('b2'), document.getElementById('b3')];

/* ======= Tunables ======= */
const OVERLAY_ALPHA = 0.10;

// Aurora + horizon glow (night defaults)
let AURORA_ALPHA  = 0.16, AURORA_SPEED = 0.06, AURORA_WOBBLE = 18;
let GLOW_ALPHA    = 0.26;

// Motion boosters (existing)
let STREAK_ALPHA  = 0.55;
let STREAK_SPEED  = 1.45;
let SMEAR_ALPHA   = 0.62;
let ASPHALT_ALPHA = 0.36;

// Hyperloop multipliers
const HYPER = { streaks:1.8, smear:1.6, asphalt:1.7, auroraW:1.6, zoom:1.07 };

/* Track theme ('night' | 'day') */
let TRACK='night';

/* ============== Sizing / Camera ============== */
let dpr=1, W=0, H=0;
let VANISH_Y = -800;
let TOP_FADE_PX=90;
/* Car-anchored vanishing-point X stays intact */
let VPT_X=0, VPT_Y=0;
let roadBottomHalf=0, roadTopHalf=0;

function resize(){
  W = arena.clientWidth;
  H = arena.clientHeight;
  dpr = Math.min(window.devicePixelRatio || 1, 2);
  canvas.width  = Math.floor(W * dpr);
  canvas.height = Math.floor(H * dpr);
  canvas.style.width  = W + 'px';
  canvas.style.height = H + 'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);

  roadBottomHalf = W*1.02;
  roadTopHalf    = W*0.10;

  VANISH_Y = -Math.max(H * 0.8, 600);
  TOP_FADE_PX  = Math.max(60, Math.min(110, Math.round(H*0.10)));

  VPT_Y = H*0.62;

  buildNoise();
  updateCarPlacement();
}
window.addEventListener('resize', resize, {passive:true});

/* ============== Assets ============== */
const carImg = new Image();
carImg.src = '/static/game/sprites/tracks/coupe.png';
const bgImg = new Image();
const bgNight = '/static/game/sprites/road_bg.jpg';
const bgDay   = '/static/game/sprites/daytrack_bg.jpg';
bgImg.src = bgNight;

/* garage background placeholder */
const garageBG = document.getElementById('garageBG');
(function tryGarageBG(){
  const test = new Image();
  test.onload = ()=>{ garageBG.src = '/static/game/sprites/garage_bg.jpg'; garageBG.style.display='block'; };
  test.onerror= ()=>{};
  test.src = '/static/game/sprites/garage_bg.jpg';
})();

/* Tinted sprite for garage preview and mini car */
function makeTintedSprite(rgb){
  if (!carImg.complete || !carImg.width) return null;
  const off = document.createElement('canvas');
  off.width  = carImg.width;
  off.height = carImg.height;
  const o = off.getContext('2d');
  o.drawImage(carImg, 0, 0);
  o.globalCompositeOperation = 'multiply';
  o.fillStyle = `rgb(${rgb.r},${rgb.g},${rgb.b})`;
  o.fillRect(0,0,off.width,off.height);
  o.globalCompositeOperation = 'destination-in';
  o.drawImage(carImg, 0, 0);
  o.globalCompositeOperation = 'source-over';
  return off;
}

/* ============== Garage Paint ============== */
const PAINTS = [
  {name:'Cherry',    r:255, g:70,  b:70 },
  {name:'Sunburst',  r:255, g:190, b:40 },
  {name:'Neo Blue',  r:90,  g:180, b:255},
  {name:'Lime',      r:120, g:230, b:90 },
  {name:'Violet',    r:170, g:120, b:255},
  {name:'Graphite',  r:185, g:195, b:205}
];
let paint = JSON.parse(localStorage.getItem('izza_paint')||'null') || PAINTS[0];
let tintedSprite = null;

const swatches = document.getElementById('swatches');
PAINTS.forEach(p=>{
  const d = document.createElement('div');
  d.className = 'swatch';
  d.style.background = `rgb(${p.r},${p.g},${p.b})`;
  if (p.name===paint.name) d.classList.add('active');
  d.title = p.name;
  d.onclick = ()=>{
    paint = p;
    localStorage.setItem('izza_paint', JSON.stringify(paint));
    [...swatches.children].forEach(x=>x.classList.remove('active'));
    d.classList.add('active');
    rebuildTintAndPreview();
    drawMiniCar();
  };
  swatches.appendChild(d);
});
const prev = document.getElementById('garagePreview');
const pctx = prev.getContext('2d');
function rebuildTintAndPreview(){
  tintedSprite = makeTintedSprite(paint);
  if (!tintedSprite) return;
  pctx.clearRect(0,0,prev.width,prev.height);
  const pad = 8;
  const availW = prev.width - pad*2;
  const scale  = Math.min(availW / carImg.width, (prev.height-pad*2) / carImg.height);
  const w = Math.round(carImg.width * scale);
  const h = Math.round(carImg.height * scale);
  const x = Math.round((prev.width - w)/2);
  const y = Math.round((prev.height - h)/2);
  const cx = x + w/2, cy = y + h*0.92, rx = w*0.42, ry = h*0.10;
  const g = pctx.createRadialGradient(cx,cy,1,cx,cy,Math.max(rx,ry));
  g.addColorStop(0, `rgba(${paint.r},${paint.g},${paint.b},.22)`);
  g.addColorStop(1, `rgba(${paint.r},${paint.g},${paint.b},0)`);
  pctx.fillStyle = g;
  pctx.beginPath(); pctx.ellipse(cx,cy,rx,ry,0,0,Math.PI*2); pctx.fill();
  pctx.drawImage(tintedSprite, x, y, w, h);
}

/* Track pickers */
document.getElementById('pickNight').onclick = ()=>setTrack('night');
document.getElementById('pickDay').onclick   = ()=>setTrack('day');
function setTrack(name){
  TRACK = name === 'day' ? 'day' : 'night';
  document.getElementById('pickNight').classList.toggle('active', TRACK==='night');
  document.getElementById('pickDay').classList.toggle('active', TRACK==='day');
  // Background swap
  bgImg.src = TRACK==='day' ? bgDay : bgNight;

  // Day vibe tuning (same effects, brighter palette)
  if (TRACK==='day'){
    AURORA_ALPHA = 0.10; AURORA_SPEED = 0.05; AURORA_WOBBLE = 14;
    GLOW_ALPHA   = 0.20;
    STREAK_ALPHA = 0.50; SMEAR_ALPHA = 0.50; ASPHALT_ALPHA = 0.30;
  } else {
    AURORA_ALPHA = 0.16; AURORA_SPEED = 0.06; AURORA_WOBBLE = 18;
    GLOW_ALPHA   = 0.26;
    STREAK_ALPHA = 0.55; SMEAR_ALPHA = 0.62; ASPHALT_ALPHA = 0.36;
  }
}

/* mini car drawer */
function drawMiniCar(){
  if (!tintedSprite) return;
  miniCtx.clearRect(0,0,miniCar.width,miniCar.height);
  const scale = Math.min(miniCar.width / tintedSprite.width, miniCar.height / tintedSprite.height);
  const w = tintedSprite.width * scale;
  const h = tintedSprite.height * scale;
  miniCtx.drawImage(tintedSprite, (miniCar.width-w)/2, (miniCar.height-h)/2, w, h);
}
carImg.onload = ()=>{ rebuildTintAndPreview(); drawMiniCar(); };

/* ============== Projection helpers ============== */
const lerp = (a,b,t)=>a+(b-a)*t;
function project(z){
  const k = 0.0105;
  const t = 1 - Math.exp(-k*z);
  const y   = lerp(VANISH_Y, H, t);
  const half= lerp(roadTopHalf, roadBottomHalf, t);
  return { y, half, t };
}

/* ======= Road params ======= */
const DEPTH_Z=24000, STEP_Z=48, RAIL_SCALE=1.08;
function edgesAt(z){
  const p = project(z);
  const y = Math.max(p.y, VANISH_Y);
  const half = (y === VANISH_Y) ? 0.0001 : p.half;
  return { y, lx: W/2 - half*RAIL_SCALE - 8, rx: W/2 + half*RAIL_SCALE + 8, t:p.t };
}

/* ============== Background (parallax) ============== */
let bgParallaxX = 0, bgTarget = 0;
function drawBackground(zoom=1){
  const carCenter = (carX + carW/2) / W;
  bgTarget = (carCenter - 0.5) * 28;
  bgParallaxX += (bgTarget - bgParallaxX) * 0.08;

  if (bgImg.complete && bgImg.naturalWidth) {
    const iw = bgImg.naturalWidth, ih = bgImg.naturalHeight;
    const r  = Math.max(W/iw, H/ih) * zoom;
    const nw = iw*r, nh = ih*r;
    const x  = (W - nw) / 2 + bgParallaxX;
    const y  = (H - nh) / 2;
    ctx.drawImage(bgImg, x, y, nw, nh);
  } else {
    const g = ctx.createLinearGradient(0,0,0,H);
    if (TRACK==='day'){ g.addColorStop(0, '#bfe1ff'); g.addColorStop(1, '#8fc8ff'); }
    else { g.addColorStop(0, '#0c1120'); g.addColorStop(1, '#090d14'); }
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
  }
}

/* ---------- Aurora + horizon glow ---------- */
function drawAurora(t, hyperFactor=1){
  const topH = H*0.42;
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  ctx.globalAlpha = AURORA_ALPHA;
  const wob = AURORA_WOBBLE * (hyperFactor>1 ? HYPER.auroraW : 1);

  for (let i=0;i<3;i++){
    const phase = t*AURORA_SPEED*(i+1)*hyperFactor;
    const sway  = Math.sin(phase)*wob*(i?0.6:1);
    const gx = VPT_X + sway;
    const gy0 = 0, gy1 = topH;
    const g = ctx.createLinearGradient(gx, gy0, gx, gy1);
    if (TRACK==='day'){
      g.addColorStop(0.00, 'rgba(255,255,180,0.45)');
      g.addColorStop(0.35, 'rgba(255,220,120,0.20)');
      g.addColorStop(1.00, 'rgba(255,210,120,0.00)');
    } else {
      g.addColorStop(0.00, 'rgba(0,255,255,0.55)');
      g.addColorStop(0.35, 'rgba(0,180,220,0.25)');
      g.addColorStop(1.00, 'rgba(0,120,180,0.00)');
    }
    ctx.fillStyle = g;
    const w = W*0.32*(i?0.7:1);
    ctx.beginPath();
    ctx.moveTo(gx-w, gy0);
    ctx.lineTo(gx+w, gy0);
    ctx.lineTo(gx+w*0.7, gy1);
    ctx.lineTo(gx-w*0.7, gy1);
    ctx.closePath();
    ctx.fill();
  }
  ctx.restore();
}
function drawVanishingGlow(t, heat){
  const rBase = Math.min(W,H)*0.070;
  const pulse = 1 + 0.06*Math.sin(t*3.2);
  const r2 = rBase*(4.8 + heat*1.0)*pulse;
  const g = ctx.createRadialGradient(VPT_X, VPT_Y, 1, VPT_X, VPT_Y, r2);
  if (TRACK==='day'){
    g.addColorStop(0,   `rgba(255,240,160,${0.60+0.22*heat})`);
    g.addColorStop(0.4, `rgba(255,220,120,${0.28+0.18*heat})`);
  } else {
    g.addColorStop(0,   `rgba(0,255,255,${0.70+0.25*heat})`);
    g.addColorStop(0.4, `rgba(0,200,255,${0.30+0.20*heat})`);
  }
  g.addColorStop(1,   'rgba(0,0,0,0)');
  ctx.save();
  ctx.globalCompositeOperation = 'screen';
  ctx.globalAlpha = GLOW_ALPHA;
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.arc(VPT_X, VPT_Y, r2, 0, Math.PI*2); ctx.fill();
  ctx.restore();
}

/* Asphalt noise layer (scrolling) */
let noiseCanvas=null, noiseCtx=null, noiseW=512, noiseH=512;
function buildNoise(){
  noiseCanvas = document.createElement('canvas');
  noiseCanvas.width = noiseW; noiseCanvas.height = noiseH;
  noiseCtx = noiseCanvas.getContext('2d');

  noiseCtx.clearRect(0,0,noiseW,noiseH);
  noiseCtx.fillStyle = 'rgba(255,255,255,0.02)';
  noiseCtx.fillRect(0,0,noiseW,noiseH);
  const g = noiseCtx.createLinearGradient(0,0,noiseW,noiseH);
  g.addColorStop(0,'rgba(255,255,255,0.10)');
  g.addColorStop(1,'rgba(255,255,255,0.00)');
  noiseCtx.strokeStyle = g;
  for(let i=0;i<160;i++){
    const y = Math.random()*noiseH;
    noiseCtx.globalAlpha = 0.08 + Math.random()*0.10;
    noiseCtx.lineWidth = 1 + Math.random()*2;
    noiseCtx.beginPath();
    noiseCtx.moveTo(0,y);
    noiseCtx.lineTo(noiseW, y - 30 - Math.random()*60);
    noiseCtx.stroke();
  }
}

/* ======== SPEED GRID (no center line) ======== */
function drawSpeedGrid(worldZ, speed, hyper=false){
  const baseAlpha = hyper ? 0.75 : 0.55;
  const edgeColor = `rgba(170,210,255,${baseAlpha})`;

  ctx.save();
  ctx.lineWidth = 1.4;
  ctx.setLineDash([6,10]);
  const dashShift = -(worldZ * (0.045 + speed/6000));

  // Left edge
  ctx.strokeStyle = edgeColor;
  ctx.lineDashOffset = dashShift;
  ctx.beginPath();
  let started=false;
  for (let z=0; z<=DEPTH_Z; z+=STEP_Z){
    const e = edgesAt(z);
    if (!started){ ctx.moveTo(e.lx, Math.min(e.y,H)); started=true; }
    else ctx.lineTo(e.lx, Math.min(e.y,H));
    if (e.y>H) break;
  }
  ctx.stroke();

  // Right edge
  ctx.beginPath();
  started=false;
  for (let z=0; z<=DEPTH_Z; z+=STEP_Z){
    const e = edgesAt(z);
    if (!started){ ctx.moveTo(e.rx, Math.min(e.y,H)); started=true; }
    else ctx.lineTo(e.rx, Math.min(e.y,H));
    if (e.y>H) break;
  }
  ctx.stroke();

  // Perspective rungs
  const rungStep = 260;
  const rungOffset = worldZ % rungStep;
  ctx.setLineDash([]);
  for (let z=rungStep - rungOffset; z<=DEPTH_Z; z+=rungStep){
    const e = edgesAt(z);
    if (e.y < VPT_Y + H*0.02) continue;
    const wL = e.lx, wR = e.rx;
    const alpha = Math.min(1, e.t*1.4) * (hyper ? 0.28 : 0.20);
    ctx.strokeStyle = `rgba(160,200,255,${alpha})`;
    ctx.lineWidth = 0.9 + e.t*1.2;
    ctx.beginPath();
    ctx.moveTo(wL + (wR-wL)*0.16, e.y);
    ctx.quadraticCurveTo(W*0.5, e.y - 10 - 90*(1-e.t), wR - (wR-wL)*0.16, e.y);
    ctx.stroke();
    if (e.y>H) break;
  }
  ctx.restore();
}

/* ======== Independent color wave (UNCHANGED by request) ======== */
function drawIndependentWave(worldZ, speed, hyper=false, heat=0, t=0){
  /* --------------------- EASY TWEAKS (edit these) --------------------- */
  const APEX_LIFT = 22;
  const FAN_SPAN  = 1.40;
  const FAN_COUNT = 30;
  const FAN_LEN   = H * 2.10;
  const FAN_LEN_HYPER = H * 2.50;
  const WOBBLE_AMP = 16 * (hyper?1.2:1);
  const SPEED_K = Math.min(1, (speed/240)) * (hyper?1.25:1.0);

  const TIP_COLOR = { r: 80, g: 220, b: 255 };
  const TIP_ALPHA = 0.40;
  const START_FADE = 0.08;
  const MID_FADE   = 0.26;
  const BODY_ALPHA = 0.28 + 0.18*heat;

  const START_CUT  = 0.12;
  const LINE_BASE  = 7;
  const LINE_GAIN  = 20;
  /* -------------------------------------------------------------------- */

  const apexX = W*0.5;
  const apexY = (VPT_Y - 6) - APEX_LIFT;
  const span  = FAN_SPAN;
  const count = FAN_COUNT;
  const len   = hyper ? FAN_LEN_HYPER : FAN_LEN;

  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  ctx.globalAlpha = 0.42 + 0.18*SPEED_K;
  ctx.lineCap = 'butt';
  ctx.lineJoin = 'miter';

  for (let i = 0; i < count; i++){
    const u = i/(count-1);
    const ang = (-span/2) + u*span;
    const wob = Math.sin((worldZ*0.028) + t*3 + i*0.7) * WOBBLE_AMP;
    const x2  = apexX + Math.tan(ang)*(len*0.85) + wob;
    const y2  = H + 80;

    const sx = apexX + (x2 - apexX)*START_CUT;
    const sy = apexY + (y2 - apexY)*START_CUT;

    const grad = ctx.createLinearGradient(sx, sy, x2, y2);
    const tip = (a)=>`rgba(${TIP_COLOR.r},${TIP_COLOR.g},${TIP_COLOR.b},${a})`;
    grad.addColorStop(0.00, tip(0.00));
    grad.addColorStop(START_FADE, tip(TIP_ALPHA));
    grad.addColorStop(MID_FADE, tip(Math.max(0.18, BODY_ALPHA)));
    const base = (i%2===0)? `rgba(70,200,255,${BODY_ALPHA})` : `rgba(235,60,255,${BODY_ALPHA*0.9})`;
    grad.addColorStop(0.60, base);
    grad.addColorStop(1.00, 'rgba(0,0,0,0)');

    ctx.strokeStyle = grad;
    ctx.lineWidth = LINE_BASE + LINE_GAIN*SPEED_K*(hyper?1.10:1.0);

    ctx.beginPath();
    ctx.moveTo(sx, sy);
    ctx.lineTo(x2, y2);
    ctx.stroke();
  }
  ctx.restore();
}

/* ===== Motion + road ===== */
function drawMotion(worldZ, speed, hyper=false, heat=0){
  const hyperK = hyper ? HYPER : {streaks:1, smear:1, asphalt:1};
  const k = Math.min(1, (speed/240)) * STREAK_SPEED;

  // radial streaks
  const count = Math.round((hyper?58:42) * hyperK.streaks * (1+0.5*heat));
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  ctx.globalAlpha = STREAK_ALPHA*(hyper?1.08:1);
  for (let i=0;i<count;i++){
    const ang = (-0.52 + i/(count-1)*1.04);
    const len = H*(hyper?1.38:1.18);
    const wob = Math.sin((worldZ*0.033)+i)*10*(hyper?1.6:1);
    const x2 = VPT_X + Math.tan(ang)*(len*0.82) + wob;
    const y2 = H + 36;
    const grad = ctx.createLinearGradient(VPT_X, VPT_Y, x2, y2);
    const baseC0 = (TRACK==='day') ? 'rgba(255,220,120,' : 'rgba(0,255,255,';
    const baseC1 = (TRACK==='day') ? 'rgba(255,140,80,'  : 'rgba(255,0,200,';
    const base = (i%2===0)? baseC0 : baseC1;
    grad.addColorStop(0.00, base + (0.75*k) + ')');
    grad.addColorStop(0.20, base + (0.45*k) + ')');
    grad.addColorStop(1.00, base + '0)');
    ctx.strokeStyle = grad;
    ctx.lineWidth = 2 + 14*k*(hyper?1.55:1.1);
    ctx.beginPath(); ctx.moveTo(VPT_X, VPT_Y); ctx.lineTo(x2, y2); ctx.stroke();
  }
  ctx.restore();

  // side smears
  const smearW = W*(hyper?0.46:0.38);
  const smearAlpha = (0.16 + SMEAR_ALPHA*0.9*k) * hyperK.smear * (1+0.25*heat);
  const smearG_L = ctx.createLinearGradient(0,0,smearW,0);
  smearG_L.addColorStop(0,   `rgba(0,0,0,${smearAlpha})`);
  smearG_L.addColorStop(1.0, 'rgba(0,0,0,0)');
  const smearG_R = ctx.createLinearGradient(W,0,W-smearW,0);
  smearG_R.addColorStop(0,   `rgba(0,0,0,${smearAlpha})`);
  smearG_R.addColorStop(1.0, 'rgba(0,0,0,0)');
  ctx.fillStyle = smearG_L; ctx.fillRect(0,0,smearW,H);
  ctx.fillStyle = smearG_R; ctx.fillRect(W-smearW,0,smearW,H);

  // road polygon clip
  const L=[], R=[];
  for (let z=0; z<=DEPTH_Z; z+=STEP_Z){ const e=edgesAt(z); L.push([e.lx,e.y]); R.push([e.rx,e.y]); }
  ctx.save();
  ctx.beginPath(); ctx.moveTo(W/2, VANISH_Y);
  for(let i=R.length-1;i>=0;i--) ctx.lineTo(R[i][0], Math.min(R[i][1],H));
  for(let i=0;i<L.length;i++)    ctx.lineTo(L[i][0], Math.min(L[i][1],H));
  ctx.closePath(); 
  ctx.clip();

  // perspective asphalt scroll
  const kspd = (2.0 + k*1.7) * hyperK.asphalt;
  const scroll = (worldZ * kspd) % noiseH;
  for(let y=-noiseH; y<H+noiseH; y+=noiseH){
    const near = Math.min(1, Math.max(0, (y+noiseH - VPT_Y) / (H - VPT_Y + 1)));
    ctx.globalAlpha = ASPHALT_ALPHA * (0.35 + 0.65*near) * (hyper?1.25:1);
    ctx.drawImage(noiseCanvas, 0, y + scroll, W, noiseH);
  }

  // tire glow beams
  const tireL = carX + carW*0.27;
  const tireR = carX + carW*0.73;
  const baseY = H*0.86;
  const laneHeight = H*(hyper?0.30:0.24);
  ctx.globalAlpha = 0.26 + 0.28*k*(hyper?1.2:1);
  ctx.globalCompositeOperation = 'lighter';
  const lane = (x)=>{
    const gg = ctx.createLinearGradient(x, baseY, x, baseY+laneHeight);
    if (TRACK==='day'){
      gg.addColorStop(0,'rgba(255,240,150,0.00)');
      gg.addColorStop(0.25,`rgba(255,240,150,${0.30+0.32*k})`);
    } else {
      gg.addColorStop(0,'rgba(0,255,255,0.00)');
      gg.addColorStop(0.25,`rgba(0,255,255,${0.30+0.32*k})`);
    }
    gg.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle = gg;
    ctx.beginPath();
    ctx.ellipse(x, baseY+laneHeight*0.55, W*0.070, laneHeight*0.58, 0, 0, Math.PI*2);
    ctx.fill();
  };
  lane(tireL); lane(tireR);
  ctx.restore();

  // hyperloop vignette
  ctx.save();
  const inner = Math.min(W,H)*0.10;
  const outer = Math.max(W,H)*(hyper?0.78:0.66)*(1-0.10*heat);
  const vg = ctx.createRadialGradient(VPT_X, VPT_Y, inner, VPT_X, VPT_Y, outer);
  vg.addColorStop(0,'rgba(0,0,0,0)');
  vg.addColorStop(1,`rgba(0,0,0,${hyper? (0.40+0.12*heat) : 0.20})`);
  ctx.fillStyle = vg;
  ctx.fillRect(0,0,W,H);
  ctx.restore();
}

/* ======= Headlights (ATTACHED TO CAR): tighter base + yellow/white tip ======= */
function drawHeadlights(){
  const leftRoot  = { x: carX + carW*0.32, y: carY + carH*0.74 };
  const rightRoot = { x: carX + carW*0.68, y: carY + carH*0.74 };
  const aim = { x: VPT_X, y: VPT_Y - 12 };

  const drawBeam = (root, spread)=> {
    ctx.save();
    ctx.globalCompositeOperation = 'screen';

    // warm tip gradient (yellow-white near root → fade out)
    const gTip = ctx.createLinearGradient(root.x, root.y, aim.x, aim.y);
    gTip.addColorStop(0, 'rgba(255,255,230,0.95)');  // white-yellow tip
    gTip.addColorStop(0.15,'rgba(255,240,160,0.65)');
    gTip.addColorStop(1, 'rgba(255,220,120,0.00)');
    ctx.fillStyle = gTip;
    ctx.beginPath();
    ctx.moveTo(root.x - spread*0.36, root.y);  // tighter base
    ctx.lineTo(root.x + spread*0.36, root.y);
    ctx.lineTo(aim.x + spread*0.24, aim.y);    // fans out less
    ctx.lineTo(aim.x - spread*0.24, aim.y);
    ctx.closePath(); ctx.fill();

    // soft body
    const gBody = ctx.createLinearGradient(root.x, root.y, aim.x, aim.y);
    gBody.addColorStop(0, 'rgba(255,230,120,0.75)');
    gBody.addColorStop(0.2,'rgba(255,210,90,0.40)');
    gBody.addColorStop(1, 'rgba(255,210,90,0.00)');
    ctx.fillStyle = gBody;
    ctx.beginPath();
    ctx.moveTo(root.x - spread*0.26, root.y);
    ctx.lineTo(root.x + spread*0.26, root.y);
    ctx.lineTo(aim.x + spread*0.18, aim.y);
    ctx.lineTo(aim.x - spread*0.18, aim.y);
    ctx.closePath(); ctx.fill();
    ctx.restore();
  };

  const baseSpread = Math.max(10, carW*0.05); // slightly tighter
  drawBeam(leftRoot,  baseSpread);
  drawBeam(rightRoot, baseSpread);
}

/* ======= Road shading ======= */
function drawRoad(){
  const L=[], R=[];
  for (let z=0; z<=DEPTH_Z; z+=STEP_Z){
    const e = edgesAt(z);
    if (e.y>H && L.length && R.length) break;
    L.push([e.lx, e.y]); R.push([e.rx, e.y]);
  }
  ctx.save();
  ctx.beginPath();
  ctx.moveTo(W/2, VANISH_Y);
  for (let i=R.length-1;i>=0;i--) ctx.lineTo(R[i][0], Math.min(R[i][1], H));
  for (let i=0;i<L.length;i++)    ctx.lineTo(L[i][0], Math.min(L[i][1], H));
  ctx.closePath();
  ctx.clip();

  const roadG = ctx.createLinearGradient(0, VANISH_Y, 0, H);
  if (TRACK==='day'){
    roadG.addColorStop(0, 'rgba(180,190,205,1)');
    roadG.addColorStop(1, 'rgba(140,150,165,1)');
  } else {
    roadG.addColorStop(0, 'rgba(15,20,29,1)');
    roadG.addColorStop(1, 'rgba(10,15,23,1)');
  }
  ctx.globalAlpha = OVERLAY_ALPHA;
  ctx.fillStyle = roadG;
  ctx.fillRect(0, 0, W, H);
  ctx.globalAlpha = 1;

  const topFade = ctx.createLinearGradient(0, 0, 0, TOP_FADE_PX);
  topFade.addColorStop(0, 'rgba(0,0,0,1)');
  topFade.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.globalCompositeOperation = 'destination-out';
  ctx.fillStyle = topFade;
  ctx.fillRect(0, 0, W, TOP_FADE_PX);
  ctx.globalCompositeOperation = 'source-over';
  ctx.restore();
}

/* =================== PARTICLES =================== */
const particles = [];
class Particle{
  constructor(x,y, vx,vy, life, size, color, glow=0, grav=0){
    this.x=x; this.y=y; this.vx=vx; this.vy=vy;
    this.life=life; this.age=0; this.size=size; this.color=color;
    this.glow=glow; this.grav=grav;
  }
  step(dt){
    this.age+=dt; if(this.age>=this.life) return false;
    this.vy += this.grav*dt;
    this.x += this.vx*dt; this.y += this.vy*dt;
    return true;
  }
  draw(ctx){
    const t = 1 - (this.age/this.life);
    ctx.save();
    if (this.glow>0){
      ctx.globalCompositeOperation='lighter';
      ctx.shadowBlur = this.glow;
      ctx.shadowColor = this.color;
    }
    ctx.globalAlpha = t;
    ctx.fillStyle = this.color;
    ctx.beginPath(); ctx.ellipse(this.x, this.y, this.size, this.size*0.8, 0, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }
}
function burstCoins(x,y, count=16){
  for(let i=0;i<count;i++){
    const a = Math.random()*Math.PI*2;
    const s = 180 + Math.random()*220;
    particles.push(new Particle(
      x + (Math.random()*12-6),
      y + (Math.random()*8-4),
      Math.cos(a)*s,
      Math.sin(a)*s - 60,
      0.5+Math.random()*0.35,
      3+Math.random()*2,
      'rgba(255,220,80,1)', 10, 600
    ));
  }
}
function burstNitro(x,y, count=12){
  for(let i=0;i<count;i++){
    const a = Math.random()*Math.PI*2;
    const s = 140 + Math.random()*180;
    particles.push(new Particle(
      x, y,
      Math.cos(a)*s, Math.sin(a)*s - 40,
      0.45+Math.random()*0.35,
      3+Math.random()*2,
      'rgba(80,255,200,1)', 12, 500
    ));
  }
}
function explodeBomb(x,y){
  for(let i=0;i<24;i++){
    const a = (i/24)*Math.PI*2;
    const s = 160 + Math.random()*220;
    particles.push(new Particle(
      x, y,
      Math.cos(a)*s, Math.sin(a)*s,
      0.55+Math.random()*0.35,
      4+Math.random()*3,
      'rgba(255,120,40,1)', 14, 420
    ));
  }
  for(let i=0;i<18;i++){
    const a = Math.random()*Math.PI*2;
    const s = 40 + Math.random()*90;
    particles.push(new Particle(
      x, y,
      Math.cos(a)*s, Math.sin(a)*s - 30,
      0.9+Math.random()*0.6,
      6+Math.random()*4,
      'rgba(60,60,70,0.9)', 0, 120
    ));
  }
}

/* =================== AUDIO =================== */
let AC=null, master=null, sfxGain=null, musicGain=null;
let muted = JSON.parse(localStorage.getItem('izza_muted')||'false');

function ensureAudio(){
  if (AC) return;
  AC = new (window.AudioContext||window.webkitAudioContext)();
  master = AC.createGain(); master.gain.value = muted?0:1; master.connect(AC.destination);
  sfxGain = AC.createGain(); sfxGain.gain.value = 0.9; sfxGain.connect(master);
  musicGain = AC.createGain(); musicGain.gain.value = 0.6; musicGain.connect(master);
  const src = AC.createMediaElementSource(bgm);
  src.connect(musicGain);
}

function clickStartAudio(){
  ensureAudio();
  if (AC.state === 'suspended') AC.resume();
  if (!bgmStarted){
    try{ bgm.currentTime = 0; bgm.play(); }catch(e){}
    bgmStarted = true;
  }
}
let bgmStarted=false;

/* short SFX */
function playCoin(){
  ensureAudio();
  const o = AC.createOscillator();
  const g = AC.createGain();
  o.type='triangle';
  o.frequency.setValueAtTime(620, AC.currentTime);
  o.frequency.exponentialRampToValueAtTime(1240, AC.currentTime+0.08);
  g.gain.setValueAtTime(0.0001, AC.currentTime);
  g.gain.exponentialRampToValueAtTime(0.7, AC.currentTime+0.01);
  g.gain.exponentialRampToValueAtTime(0.001, AC.currentTime+0.15);
  o.connect(g); g.connect(sfxGain); o.start(); o.stop(AC.currentTime+0.16);
}
function playNitroPickup(){
  ensureAudio();
  const n = AC.createBuffer(1, AC.sampleRate*0.18, AC.sampleRate);
  const d = n.getChannelData(0);
  for(let i=0;i<d.length;i++){ d[i] = (Math.random()*2-1) * Math.pow(1-i/d.length, 2); }
  const s = AC.createBufferSource(); s.buffer = n;
  const f = AC.createBiquadFilter(); f.type='highpass'; f.frequency.value = 500;
  const g = AC.createGain(); g.gain.value = 0.8;
  s.connect(f); f.connect(g); g.connect(sfxGain);
  s.start(); s.stop(AC.currentTime+0.18);
}
function playBomb(){
  ensureAudio();
  const n = AC.createBuffer(1, AC.sampleRate*0.5, AC.sampleRate);
  const d = n.getChannelData(0);
  for(let i=0;i<d.length;i++){ d[i] = (Math.random()*2-1) * Math.pow(1-i/d.length, 0.6); }
  const s = AC.createBufferSource(); s.buffer = n; s.playbackRate.value = 0.9;
  const f = AC.createBiquadFilter(); f.type='lowpass'; f.frequency.value = 220;
  const g = AC.createGain(); g.gain.setValueAtTime(1.0, AC.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001, AC.currentTime+0.5);
  s.connect(f); f.connect(g); g.connect(sfxGain);
  s.start(); s.stop(AC.currentTime+0.52);
}

/* Continuous Nitro whoosh while holding */
let nitroLoop = null;
function setNitroWhoosh(on){
  ensureAudio();
  if (on){
    if (!nitroLoop){
      const n = AC.createBuffer(1, AC.sampleRate*1.5, AC.sampleRate);
      const d = n.getChannelData(0);
      for(let i=0;i<d.length;i++){
        d[i] = (Math.random()*2-1) * Math.pow(1 - i/d.length, 1.5);
      }
      const s = AC.createBufferSource(); s.buffer = n; s.loop = true;
      const f = AC.createBiquadFilter(); f.type='bandpass'; f.frequency.value = 420;
      const g = AC.createGain(); g.gain.value = 0.35;
      s.connect(f); f.connect(g); g.connect(sfxGain);
      s.start();
      nitroLoop = { s, g };
    }
  } else {
    if (nitroLoop){
      try{ nitroLoop.s.stop(); }catch(_){}
      nitroLoop = null;
    }
  }
}

/* ================= GAME LOOP STATE ================= */
let carX=0, carY=0, carW=0, carH=0;
let speed=0, dist=0, coins=0, strikes=0;
let nitro=1.0;
let running=false, hyper=false, t0=0, worldZ=0;
let frameReq=null;

function updateCarPlacement(){
  carW = W*0.20;
  carH = carW*0.55;
  carX = W*0.5 - carW/2;
  carY = H*0.82 - carH;
}

function startGame(){
  strikes=0; dist=0; coins=0; speed=0; worldZ=0;
  nitro=1.0; running=true; hyper=false;
  document.getElementById('startOverlay').style.display='none';
  document.getElementById('finishOverlay').style.display='none';
  clickStartAudio();
  t0 = performance.now();
  frameReq = requestAnimationFrame(frame);
}
function endGame(){
  running=false;
  cancelAnimationFrame(frameReq);
  persistWalletAndSave();
  document.getElementById('finDist').textContent = Math.round(dist);
  document.getElementById('finCoins').textContent = coins;
  const newCraft = Math.floor(coins/1000);
  const prevCraft = readCraftAny();
  writeCraftAll(prevCraft + newCraft);
  document.getElementById('finCraft').textContent = prevCraft + newCraft;
  document.getElementById('finishOverlay').style.display='flex';
}

function frame(ts){
  const dt = (ts - t0)/1000; t0 = ts;
  if (!running) return;
  ctx.clearRect(0,0,W,H);

  worldZ += speed*dt*55;
  dist += speed*dt*2;

  drawBackground();
  drawAurora(ts/1000);
  drawVanishingGlow(ts/1000, 0.3);
  drawSpeedGrid(worldZ, speed, hyper);
  drawIndependentWave(worldZ, speed, hyper, 0.3, ts/1000);
  drawMotion(worldZ, speed, hyper, 0.3);
  drawRoad();
  drawHeadlights();

  // Draw particles
  for(let i=particles.length-1;i>=0;i--){
    if (!particles[i].step(dt)) particles.splice(i,1);
    else particles[i].draw(ctx);
  }

  // Draw car
  if (tintedSprite){
    ctx.drawImage(tintedSprite, carX, carY, carW, carH);
  }

  // HUD updates
  HUD.speedVal.textContent = Math.round(speed*100);
  HUD.dist.textContent = Math.round(dist);
  HUD.coins.textContent = coins;

  frameReq = requestAnimationFrame(frame);
}

/* ============= INPUTS ============= */
let pressingNitro=false;
arena.addEventListener('touchstart', e=>{
  pressingNitro=true;
  setNitroWhoosh(true);
}, {passive:true});
arena.addEventListener('touchend', e=>{
  pressingNitro=false;
  setNitroWhoosh(false);
}, {passive:true});
arena.addEventListener('mousedown', e=>{
  pressingNitro=true;
  setNitroWhoosh(true);
});
arena.addEventListener('mouseup', e=>{
  pressingNitro=false;
  setNitroWhoosh(false);
});

/* ============= UI HOOKS ============= */
document.getElementById('startBtn').onclick = startGame;
soundBtn.onclick = ()=>{
  muted=!muted;
  localStorage.setItem('izza_muted', JSON.stringify(muted));
  master.gain.value = muted?0:1;
  soundBtn.classList.toggle('muted', muted);
  soundLabel.textContent = muted? 'SOUND OFF' : 'SOUND ON';
};

/* ============= INIT ============= */
resize();
hydrateFromSnapshot().then(()=> ensureSession().then(()=> primeViaCityIframe()));
})();
</script>
</body>
</html>
