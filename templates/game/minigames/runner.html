<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>IZZA RUNNER ‚Äî IZZA GAME</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="color-scheme" content="light">

  <!-- Persist/leaderboard base (already used across your app) -->
  <script>window.IZZA_PERSIST_BASE = 'https://izzagame.onrender.com';</script>
  <script src="/static/game/js/izza-persist.js"></script>

  <!-- Three.js -->
  <script src="https://unpkg.com/three@0.157.0/build/three.min.js"></script>

  <style>
    :root{
      --bg:#bfe8ff; --txt:#112; --line:#d7e5ff; --muted:#51607b;
      --chip-bg:rgba(255,255,255,.7); --card:rgba(255,255,255,.92);
      --accent:#1c7dff; --accent-2:#10c97b; --danger:#ff4f6b; --gold:#ffd86b;
      --grass:#27ff66; --grass-d:#12ca49; --path:#d7b97a; --path-d:#c39f4f;
    }
    html,body{height:100%}
    body{
      margin:0;
      background:linear-gradient(#c6ecff 0%, #bfe8ff 40%, #99d6ff 100%) no-repeat;
      color:var(--txt); font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      overflow:hidden;
    }

    /* HUD */
    .hud{
      position:fixed; inset:10px 10px auto 10px;
      display:flex; flex-wrap:wrap; align-items:center; gap:6px; z-index:20;
      max-width:calc(100vw - 120px);
    }
    .pill{
      display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px;
      background:var(--chip-bg); border:1px solid var(--line); font-weight:700; font-size:12px; backdrop-filter:blur(6px);
      white-space:nowrap;
    }
    .pill .v{min-width:36px; text-align:right;}
    .btn{
      display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:10px;
      background:var(--chip-bg); border:1px solid var(--line); color:#0b2b4b; cursor:pointer; user-select:none; font-weight:700; font-size:12px;
    }
    .btn:hover{filter:brightness(1.04)}
    .score{
      position:fixed; right:8px; top:8px; z-index:20; font-size:22px; font-weight:800; letter-spacing:0.5px;
      padding:6px 10px; background:var(--chip-bg); border:1px solid var(--line);
      border-radius:12px; backdrop-filter:blur(6px);
    }
    @media (min-width:420px){
      .score{font-size:26px; padding:8px 12px}
      .pill{font-size:13px; padding:8px 12px}
      .btn{font-size:13px; padding:8px 12px}
    }

    /* Start & GameOver overlays */
    .overlay{
      position:fixed; inset:0; display:grid; place-items:center; z-index:30; background:rgba(255,255,255,.35);
      opacity:0; pointer-events:none; transition:opacity .25s ease;
    }
    .overlay.show{opacity:1; pointer-events:auto;}
    .panel{
      width:min(92vw,740px); background:var(--card); border:1px solid var(--line); border-radius:18px;
      padding:16px; overflow:hidden; box-shadow:0 30px 120px rgba(0,0,0,.15);
    }
    .hero{
      height:220px; border-radius:12px; border:1px solid var(--line);
      background:linear-gradient(#a9ffcb,#b7f0ff) center/cover no-repeat; margin-bottom:12px;
    }
    .panel h1{margin:8px 0 4px; font-size:28px;}
    .muted{color:var(--muted); font-size:14px;}
    .center-row{display:flex; gap:8px; justify-content:center; align-items:center; flex-wrap:wrap; margin-top:10px;}

    #gameCanvas{position:fixed; inset:0; width:100vw; height:100vh; display:block;}

    /* Avatar preview (keep size, turn background fully green) */
    .avatar-corner{
      position:fixed; left:12px; bottom:12px; width:90px; height:90px; z-index:15; pointer-events:none;
      border-radius:12px; border:1px solid var(--line);
      background:linear-gradient(var(--grass), var(--grass));
      display:flex; align-items:center; justify-content:center; backdrop-filter:blur(6px);
    }
    canvas#avatarCursor{width:82px; height:82px; image-rendering:pixelated;}

    /* Make bottom strip green all the way to screen edge */
    .bottom-grass{
      position:fixed; left:0; right:0; bottom:0; height:160px; z-index:5;
      background:var(--grass);
      pointer-events:none;
    }

    .tips{
      position:fixed; left:12px; top:56px; z-index:20; color:#0b2b4b; font-weight:700; font-size:12px;
      background:var(--chip-bg); border:1px solid var(--line); border-radius:10px; padding:6px 8px; backdrop-filter:blur(6px);
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <!-- HUD -->
  <div class="hud">
    <div class="pill">IZZA Coins: <span id="coins" class="v">0</span></div>
    <div class="pill">Craft Credits: <span id="craft" class="v">0</span></div>
    <button id="muteBtn" class="btn" type="button">üîä Sound</button>
    <a id="exitBtn" class="btn" href="/izza-game/minigames">‚Ü©Ô∏é Exit</a>
  </div>
  <div class="tips">Swipe ‚Üë to jump ‚Ä¢ Swipe ‚Üì to slide ‚Ä¢ ‚Üë/‚Üì on desktop</div>
  <div class="score" id="scoreEl">0</div>

  <!-- Avatar preview -->
  <div class="avatar-corner">
    <canvas id="avatarCursor" width="96" height="96"></canvas>
  </div>

  <!-- Green footer slab -->
  <div class="bottom-grass"></div>

  <!-- Start Overlay -->
  <div id="startOverlay" class="overlay show">
    <div class="panel">
      <div class="hero"></div>
      <h1>IZZA RUNNER ‚Äî Meadow Dash</h1>
      <p class="muted">
        Morning in the Neon Meadows. You‚Äôre sprint-couriering craft credits across fields of charged grass.
        Leap <b>hay bales</b>, slide <b>banner gates</b>, and snatch shimmering <b>IZZA Coins</b> dropped by friends.
      </p>
      <div class="center-row">
        <button id="startBtn" class="btn">‚ñ∂ Start</button>
        <button id="lbBtn" class="btn">üèÜ Leaderboard</button>
      </div>
    </div>
  </div>

  <!-- Game Over Overlay -->
  <div id="overOverlay" class="overlay">
    <div class="panel" id="overPanel">
      <h1 style="margin:0 0 12px">You Tripped!</h1>
      <div class="muted" id="overStats">Distance: 0 ‚Ä¢ Coins: 0 ‚Ä¢ Best: 0</div>
      <div class="center-row">
        <button id="retryBtn" class="btn">‚Üª Retry</button>
        <button id="overLbBtn" class="btn">üèÜ Leaderboard</button>
        <a class="btn" href="/izza-game/minigames">‚Ü©Ô∏é Back to Arcade</a>
      </div>
    </div>
  </div>

<script>
/* -----------------------------
   USER + PERSIST BOOTSTRAP
------------------------------*/
(function ensureUser(){
  try{
    const params = new URLSearchParams(location.search);
    let u = (params.get('u') || '').toString().trim();
    if (!u) u = (localStorage.getItem('izzaUserU') || '').toString().trim();
    if (!u) {
      const raw = localStorage.getItem('piAuthUser');
      if (raw) { try { u = (JSON.parse(raw)||{}).username || ''; } catch(_){} }
    }
    if (u) {
      u = u.replace(/^@+/, '').toLowerCase();
      window.__IZZA_PROFILE__ = Object.assign({}, window.__IZZA_PROFILE__, { username: u });
      window.izzaUserKey = { get: () => u };
      try { localStorage.setItem('izzaUserU', u); } catch(_){}
      try { if (!localStorage.getItem('piAuthUser')) localStorage.setItem('piAuthUser', JSON.stringify({ username: u })); } catch(_){}
    }
  }catch(_){}
})();

/* Helpers consistent with Arena */
const CRAFT_KEYS = ['izzaCrafting','craftingCredits','izzaCraftCredits'];
function readCraftAny(){ for(const k of CRAFT_KEYS){ const v=parseInt(localStorage.getItem(k)||'0',10); if(Number.isFinite(v)&&v>0) return v|0; } return (parseInt(localStorage.getItem(CRAFT_KEYS[0])||'0',10)||0)|0; }
function writeCraftAll(v){ const n=Math.max(0,v|0); for(const k of CRAFT_KEYS) localStorage.setItem(k,String(n)); try{ window.dispatchEvent(new Event('izza-crafting-changed')); }catch(_){ } }
function renderWalletFromLS(){ document.getElementById('coins').textContent = String(parseInt(localStorage.getItem('izzaCoins')||'0',10)||0); document.getElementById('craft').textContent = String(readCraftAny()); }
renderWalletFromLS();

/* Load latest snapshot on entry */
(async function hydrate(){
  try{ if (window.IZZA_PERSIST?.load) await IZZA_PERSIST.load(); }catch(_){}
  renderWalletFromLS();
})();

/* -----------------------------
   AVATAR BUILDER (same as Arena)
------------------------------*/
const SPRITES = {
  body:{ default:"/static/game/sprites/body/default.png", street_a:"/static/game/sprites/body/street_a.png", street_b:"/static/game/sprites/body/street_b.png" },
  hair:{ short:"/static/game/sprites/hair/short.png", buzz:"/static/game/sprites/hair/buzz.png", long:"/static/game/sprites/hair/long.png" },
  outfit:{ street:"/static/game/sprites/outfit/street.png", athletic:"/static/game/sprites/outfit/athletic.png", luxury:"/static/game/sprites/outfit/luxury.png" }
};
const SKIN_BASE=["#F7D7C6","#E8BEA8","#D6A48E"];
const SKIN_TO={ light:["#FFE7D6","#F3C6A7","#D8A187"], medium:["#F1BD94","#D79A73","#B67955"], tan:["#E2A878","#C88756","#9F663C"], dark:["#B9825B","#9A6644","#714A31"], deep:["#8B5A3B","#432818"] };
const FEMALE_DRESS_BASE=["#7AB6FF","#4E84E3","#2F5CB5"];
const FEMALE_DRESS_TO={ blue:["#7AB6FF","#4E84E3","#2F5CB5"], red:["#FF7A7A","#E24C4C","#B12F2F"], green:["#7DD68A","#4CB56B","#2F7F47"], purple:["#B796FF","#8C6BE0","#6A49B8"], yellow:["#FFE08A","#E7C45A","#B89433"], pink:["#FFA6D6","#E57CB2","#C45C96"], black:["#3A3AD3","#232326","#0E0E10"], white:["#FFFFFF","#E6E6E6","#C9C9C9"], brown:["#A87854","#7C563A","#593D29"], orange:["#FFB46A","#E4873A","#B65E1F"] };
const HAIR_TO={ black:["#2C2C31","#17171B","#0A0A0D"], brown:["#7A5336","#5C3E28","#3E2B1B"], blonde:["#FBE58F","#E5C35A","#B89433"], red:["#E65F35","#B54426","#8E321A"], white:["#FFFFFF","#E6E6E6","#C9C9C9"], blue:["#7AB6FF","#4E84E3","#2F5CB5"], green:["#7DD68A","#4CB56B","#2F7F47"], pink:["#FFA6D6","#E57CB2","#C45C96"] };

function loadImg(src){ return new Promise(res=>{ const i=new Image(); i.crossOrigin='anonymous'; i.onload=()=>res(i); i.onerror=()=>res(null); i.src=src; }); }
const hexToRgb=h=>{ const n=parseInt(h.replace('#',''),16); return {r:(n>>16)&255,g:(n>>8)&255,b:n&255}; };
const rgbToHex=({r,g,b})=>('#'+[r,g,b].map(v=>v.toString(16).padStart(2,'0')).join(''));
const dist2=(a,b)=>{const dr=a.r-b.r,dg=a.g-b.g,db=a.b-b.b;return dr*dr+dg*dg+db*db;};
const lum=(r,g,b)=>0.2126*r+0.7152*g+0.0722*b;

function extractThreeToneRamp(img){
  const w=img.width,h=img.height, oc=document.createElement('canvas'); oc.width=w; oc.height=h;
  const c=oc.getContext('2d',{willReadFrequently:true}); c.imageSmoothingEnabled=false; c.drawImage(img,0,0);
  const d=c.getImageData(0,0,w,h).data, samples=[];
  for(let i=0;i<d.length;i+=4){ if(d[i+3]<10) continue; const r=d[i],g=d[i+1],b=d[i+2]; samples.push({r,g,b,L:lum(r,g,b)}); }
  if(samples.length<10) return ["#C8C8C8","#9C9C9C","#6E6E6E"];
  samples.sort((a,b)=>a.L-b.L);
  const pick=q=>{ const idx=Math.max(0,Math.min(samples.length-1,Math.floor(q*(samples.length-1)))); const s=samples[idx];
    return '#'+s.r.toString(16).padStart(2,'0')+s.g.toString(16).padStart(2,'0')+s.b.toString(16).padStart(2,'0'); };
  return [pick(0.2),pick(0.55),pick(0.85)];
}
function paletteSwap(img, fromRampHex, toRampHex, tolerance=2000){
  const from=fromRampHex.map(hexToRgb), to=toRampHex.map(hexToRgb);
  const w=img.width,h=img.height, oc=document.createElement('canvas'); oc.width=w; oc.height=h;
  const c=oc.getContext('2d',{willReadFrequently:true}); c.imageSmoothingEnabled=false; c.drawImage(img,0,0);
  const id=c.getImageData(0,0,w,h), d=id.data; let changed=0;
  for(let i=0;i<d.length;i+=4){
    if(d[i+3]===0) continue;
    const p={r:d[i],g:d[i+1],b:d[i+2]}; let best=-1,score=1e9;
    for(let k=0;k<from.length;k++){ const s=dist2(p,from[k]); if(s<score){score=s;best=k;} }
    if(score<=tolerance){ const t=to[best]||to[1]||to[0]; if(d[i]!==t.r||d[i+1]!==t.g||d[i+2]!==t.b) changed++; d[i]=t.r; d[i+1]=t.g; d[i+2]=t.b; }
  }
  c.putImageData(id,0,0);
  return {canvas:oc, changedPixels:changed};
}
function overlayTint(img, hex, strength=1.0){
  const w=img.width,h=img.height, oc=document.createElement('canvas'); oc.width=w; oc.height=h;
  const c=oc.getContext('2d',{willReadFrequently:true}); c.imageSmoothingEnabled=false; c.drawImage(img,0,0);
  const id=c.getImageData(0,0,w,h), d=id.data, t=hexToRgb(hex);
  function ov(a,b){a/=255;b/=255;const o=(a<.5)?(2*a*b):(1-2*(1-a)*(1-b));return Math.round(o*255);}
  for(let i=0;i<d.length;i+=4){ if(d[i+3]===0) continue;
    const r=ov(d[i],t.r), g=ov(d[i+1],t.g), b=ov(d[i+2],t.b);
    d[i]=Math.round(d[i]*(1-strength)+r*strength);
    d[i+1]=Math.round(d[i+1]*(1-strength)+g*strength);
    d[i+2]=Math.round(d[i+2]*(1-strength)+b*strength);
  }
  c.putImageData(id,0,0);
  return oc;
}

/* Inventory helpers for overlays */
function _invRead(){
  try{
    const iz = (window.IZZA && IZZA.api && IZZA.api.getInventory && IZZA.api.getInventory()) || null;
    if (iz) return JSON.parse(JSON.stringify(iz));
  }catch(_){}
  try{ return JSON.parse(localStorage.getItem('izzaInventory')||'{}'); }catch(_){ return {}; }
}
function _isEquipped(entry){ return !!(entry && (entry.equipped===true || entry.equip===true || (typeof entry.equippedCount==='number' && entry.equippedCount>0))); }
function _equippedIn(slot){
  const inv = _invRead();
  for(const k in inv){
    const it = inv[k]; if(!it) continue;
    if ((it.slot||'').toLowerCase()===slot && _isEquipped(it)){
      const svg = (it.overlaySvg && String(it.overlaySvg).trim()) || (it.iconSvg && String(it.iconSvg).trim()) || '';
      return { key:k, it, svg };
    }
  }
  return null;
}
const BOX = Object.freeze({
  head:{ w:44,h:44, ox:48,oy:24, scale:1.12 },
  chest:{w:46,h:46, ox:48,oy:56, scale:1.15 },
  arms:{ w:56,h:44, ox:48,oy:46, scale:1.15 },
  legs:{ w:54,h:46, ox:48,oy:74, scale:1.18 },
  hands:{w:64,h:46, ox:60,oy:64, scale:1.34 }
});
const BASE_SZ = 96;
function _scaleBox(b,k){ return { w:Math.round((b.w||0)*k), h:Math.round((b.h||0)*k), ox:Math.round((b.ox||0)*k), oy:Math.round((b.oy||0)*k), scale:b.scale }; }
const _svgCache = new Map();
function _svgToImg(svg){ if(!svg) return null; if(_svgCache.has(svg)) return _svgCache.get(svg); const img=new Image(); img.decoding='async'; img.src='data:image/svg+xml;utf8,'+encodeURIComponent(svg); _svgCache.set(svg,img); return img; }
function _drawOverlay(ctx, svg, box, per=1, flip=false){
  if(!svg) return false; const img=_svgToImg(svg); if(!img || !img.complete) return false;
  ctx.save(); ctx.imageSmoothingEnabled=false; ctx.translate(box.ox|0, box.oy|0); if(flip) ctx.scale(-1,1);
  const w=Math.max(8,box.w|0), h=Math.max(8,box.h|0); const s=(box.scale||1)*(per||1); if(s!==1) ctx.scale(s,s);
  try{ ctx.drawImage(img, -w/2, -h/2, w, h); }catch(_){}
  ctx.restore(); return true;
}

async function buildAvatarCanvas(dstCtx, size, profile){
  const DW=size,DH=size,X=0,Y=0;
  const type=profile.body_type||'male', tone=profile.skin_tone||'light', theme=profile.sprite_skin||'default';
  const outfitKey=profile.outfit||'street', hairKey=profile.hair||'short', hairCol=profile.hair_color||'black';
  const femaleOut=profile.female_outfit_color||'blue';

  let body=null;
  if(type==='female'){
    const femaleWide=`/static/game/sprites/body/${theme}__female_wide.png`;
    const femaleSlim=`/static/game/sprites/body/${theme}__female.png`;
    body = await loadImg(femaleWide) || await loadImg(femaleSlim);
  }
  if(!body){ body = await loadImg(SPRITES.body[theme]||SPRITES.body.default); }

  const hair = await loadImg(SPRITES.hair[hairKey]||SPRITES.hair.short);
  const outfit = (type==='female') ? null : (await loadImg(SPRITES.outfit[outfitKey]||SPRITES.outfit.street));

  let bodyCanvas;
  if(body){
    const targetSkin=SKIN_TO[tone]||SKIN_TO.light;
    const swapped=paletteSwap(body, SKIN_BASE, targetSkin, 4000);
    bodyCanvas=swapped.canvas;
    if(swapped.changedPixels<8){ bodyCanvas=overlayTint(body, targetSkin[1], 0.98); }
  }

  if(type==='female' && bodyCanvas){
    const targetDress=FEMALE_DRESS_TO[femaleOut]||FEMALE_DRESS_TO.blue;
    const reDress=paletteSwap(bodyCanvas, FEMALE_DRESS_BASE, targetDress, 4000);
    bodyCanvas=reDress.canvas;
    if(reDress.changedPixels<6){ bodyCanvas=overlayTint(bodyCanvas, targetDress[1], 0.85); }
  }

  dstCtx.clearRect(0,0,DW,DH);
  if(bodyCanvas) dstCtx.drawImage(bodyCanvas, X, Y, DW, DH);
  if(outfit) dstCtx.drawImage(outfit, X, Y, DW, DH);
  if(hair){
    const detected=extractThreeToneRamp(hair), target=HAIR_TO[hairCol]||HAIR_TO.black;
    const swap=paletteSwap(hair, detected, target, 4000);
    let hairCanvas=swap.canvas;
    if(swap.changedPixels<8){ hairCanvas=overlayTint(hairCanvas, target[1], 1.0); }
    const hairY=(type==='female' && hairKey==='buzz') ? (Y-4) : Y;
    dstCtx.drawImage(hairCanvas, X, hairY, DW, DH);
  }
}

/* Compose avatar + overlays (front) */
async function buildAvatarCanvasWithGear(dstCtx, size, profile){
  await buildAvatarCanvas(dstCtx, size, profile);
  const k = (size>0 ? size/BASE_SZ : 1);
  const head=_equippedIn('head'), chest=_equippedIn('chest'), arms=_equippedIn('arms'), legs=_equippedIn('legs'), hands=_equippedIn('hands');
  if(legs){ _drawOverlay(dstCtx, legs.svg, _scaleBox(BOX.legs,k), 1); }
  if(chest){ _drawOverlay(dstCtx, chest.svg, _scaleBox(BOX.chest,k), 1); }
  if(arms){ _drawOverlay(dstCtx, arms.svg, _scaleBox(BOX.arms,k), 1); }
  if(head){ _drawOverlay(dstCtx, head.svg, _scaleBox(BOX.head,k), 1); }
  if(hands){ _drawOverlay(dstCtx, hands.svg, _scaleBox(BOX.hands,k), 1); } // preview shows hands/weapon
}

/* Utility: average color inside ellipse on a canvas (skip transparent pixels) */
function sampleAverageColorInEllipse(ctx, cx, cy, rx, ry){
  const w=ctx.canvas.width, h=ctx.canvas.height;
  const xmin=Math.max(0, Math.floor(cx-rx)), xmax=Math.min(w-1, Math.ceil(cx+rx));
  const ymin=Math.max(0, Math.floor(cy-ry)), ymax=Math.min(h-1, Math.ceil(cy+ry));
  let r=0,g=0,b=0,n=0;
  const id=ctx.getImageData(xmin,ymin,(xmax-xmin+1),(ymax-ymin+1)), d=id.data;
  const rx2=rx*rx, ry2=ry*ry;
  for(let y=0;y<=ymax-ymin;y++){
    for(let x=0;x<=xmax-xmin;x++){
      const dx=x+xmin-cx, dy=y+ymin-cy;
      if((dx*dx)/rx2 + (dy*dy)/ry2 > 1) continue;
      const i=(y*(xmax-xmin+1)+x)*4;
      const a=d[i+3]; if(a<8) continue;
      r+=d[i]; g+=d[i+1]; b+=d[i+2]; n++;
    }
  }
  if(n===0) return null;
  return rgbToHex({r:Math.round(r/n), g:Math.round(g/n), b:Math.round(b/n)});
}

/* Build and then "backify" the avatar WITH GEAR for the in-game texture.
   Backify = compose body + overlays (excluding HANDS), mirror, then wipe face and refill
   using head/helmet dominant color, or hair mid-tone if no head overlay. */
async function buildBackAvatar(size){
  const profile = JSON.parse(localStorage.getItem('izzaCharacter')||'{}');

  // 1) Compose to a source canvas WITHOUT hands
  const src = document.createElement('canvas'); src.width=src.height=size;
  const sctx = src.getContext('2d',{willReadFrequently:true}); sctx.imageSmoothingEnabled=false;

  await buildAvatarCanvas(sctx, size, profile);

  const k = (size>0 ? size/BASE_SZ : 1);
  const head=_equippedIn('head'), chest=_equippedIn('chest'), arms=_equippedIn('arms'), legs=_equippedIn('legs');
  if(legs){ _drawOverlay(sctx, legs.svg, _scaleBox(BOX.legs,k), 1); }
  if(chest){ _drawOverlay(sctx, chest.svg, _scaleBox(BOX.chest,k), 1); }
  if(arms){ _drawOverlay(sctx, arms.svg, _scaleBox(BOX.arms,k), 1); }
  if(head){ _drawOverlay(sctx, head.svg, _scaleBox(BOX.head,k), 1); }

  // Face ellipse (on source/back have same coords)
  const cx=size*0.52, cy=size*0.28, rx=size*0.18, ry=size*0.15;

  // Decide fill color: head overlay dominant or hair mid-tone
  let fillCol = null;
  if (head && head.svg){
    fillCol = sampleAverageColorInEllipse(sctx, cx, cy, rx, ry);
  }
  if (!fillCol){
    const hairTone = (HAIR_TO[ (profile.hair_color||'black') ]||HAIR_TO.black);
    fillCol = hairTone[1]; // mid-tone
  }

  // 2) Mirror to simulate back view
  const back = document.createElement('canvas'); back.width=back.height=size;
  const bctx = back.getContext('2d',{willReadFrequently:true}); bctx.imageSmoothingEnabled=false;
  bctx.save(); bctx.scale(-1,1); bctx.drawImage(src, -size, 0, size, size); bctx.restore();

  // 3) Wipe face region, then refill with chosen color (no hole)
  bctx.save(); bctx.globalCompositeOperation='destination-out';
  bctx.beginPath(); bctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI*2); bctx.fill(); bctx.restore();

  bctx.save(); bctx.globalCompositeOperation='source-over'; bctx.fillStyle = fillCol;
  bctx.beginPath(); bctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI*2); bctx.fill(); bctx.restore();

  return back;
}

/* -----------------------------
   AUDIO (SFX via WebAudio)
------------------------------*/
const audio = {
  ctx:null, bg:null, gain:null, muted:false,
  ensure(){
    if (this.ctx) return;
    const ctx = new (window.AudioContext||window.webkitAudioContext)();
    const gain = ctx.createGain(); gain.gain.value = 0.7; gain.connect(ctx.destination);
    this.ctx = ctx; this.gain=gain;
  },
  blip({f1=440,f2=880,dur=0.18}={}){
    if (this.muted) return; this.ensure();
    const t=this.ctx.currentTime;
    const o=this.ctx.createOscillator(); o.type='triangle';
    const g=this.ctx.createGain(); g.gain.setValueAtTime(0.0001,t);
    o.connect(g); g.connect(this.gain);
    o.frequency.setValueAtTime(f1,t); o.frequency.exponentialRampToValueAtTime(f2,t+dur*0.8);
    g.gain.exponentialRampToValueAtTime(0.6,t+0.02); g.gain.exponentialRampToValueAtTime(0.0001,t+dur);
    o.start(t); o.stop(t+dur);
  },
  thump({f=110,dur=0.2}={}){
    if (this.muted) return; this.ensure();
    const t=this.ctx.currentTime;
    const o=this.ctx.createOscillator(); o.type='sine';
    const g=this.ctx.createGain(); o.connect(g); g.connect(this.gain);
    o.frequency.setValueAtTime(f,t); o.frequency.exponentialRampToValueAtTime(55,t+dur);
    g.gain.setValueAtTime(0.7,t); g.gain.exponentialRampToValueAtTime(0.0001,t+dur);
    o.start(t); o.stop(t+dur);
  },
  async bgm(){
    if (this.muted) return; this.ensure();
    if (this.bg){ try{ this.bg.stop(); }catch(_){ } this.bg=null; }
    try{
      const res = await fetch('/static/game/audio/izza_runner_theme.mp3',{cache:'force-cache'});
      const buf = await res.arrayBuffer();
      const ab = await this.ctx.decodeAudioData(buf);
      const src = this.ctx.createBufferSource(); src.buffer = ab; src.loop = true; src.connect(this.gain); src.start();
      this.bg = src;
    }catch(_){}
  },
  setMuted(flag){
    this.muted=!!flag; if(!this.ctx) return;
    this.gain.gain.setTargetAtTime(this.muted?0:0.7, this.ctx.currentTime, 0.05);
  }
};
document.getElementById('muteBtn').addEventListener('click', ()=>{
  audio.setMuted(!audio.muted);
  document.getElementById('muteBtn').textContent = audio.muted ? 'üîà Muted' : 'üîä Sound';
});

/* -----------------------------
   THREE.js GAME ‚Äî Daytime Meadow
------------------------------*/
const canvas = document.getElementById('gameCanvas');
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
renderer.setSize(innerWidth, innerHeight);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 2000);
camera.position.set(0, 1.05, 3.8);
scene.fog = new THREE.Fog(0xbfe8ff, 22, 80);

/* Sun + sky */
{
  const hemi = new THREE.HemisphereLight(0xbfe8ff, 0x22aa44, 0.8); scene.add(hemi);
  const sun  = new THREE.DirectionalLight(0xffffff, 1.04); sun.position.set(5,8,3); scene.add(sun);
  const skyGeo = new THREE.SphereGeometry(900, 24, 16);
  const skyMat = new THREE.MeshBasicMaterial({ color:0xbfe8ff, side:THREE.BackSide });
  const sky = new THREE.Mesh(skyGeo, skyMat); scene.add(sky);
}

/* Ground (bright neon grass) */
const grassMat = new THREE.MeshLambertMaterial({ color:0x27ff66 });
const ground = new THREE.Mesh(new THREE.PlaneGeometry(40, 2000), grassMat);
ground.rotation.x = -Math.PI/2; ground.position.z = -1000; scene.add(ground);

/* Infinite-looking path: a ring of segments recycled behind the player */
const PATH_SEGMENTS = [];
const PATH_SPACING = 5.0;
const PATH_COUNT = 80;                         // number of visible segments
const PATH_LOOP = PATH_SPACING * PATH_COUNT;   // recycle distance
(function buildPath(){
  const mat = new THREE.MeshStandardMaterial({ color:0xd7b97a, roughness:0.9, metalness:0.0 });
  for(let i=0;i<PATH_COUNT;i++){
    const seg = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.02, 4.5), mat);
    seg.position.set(0, 0.01, -i*PATH_SPACING - 5);
    scene.add(seg); PATH_SEGMENTS.push(seg);
  }
})();

/* Scenery blocks */
(function hedges(){
  const hedgeMat = new THREE.MeshLambertMaterial({ color:0x12ca49 });
  for(let i=0;i<80;i++){
    const h = new THREE.Mesh(new THREE.BoxGeometry(1.6, Math.random()*1.2+0.8, 1.6), hedgeMat);
    h.position.set( (Math.random()<0.5?-1:1)*(3.0+Math.random()*3.0), h.geometry.parameters.height/2, -i*16-8 - Math.random()*8);
    scene.add(h);
  }
})();

/* Avatar canvases (preview) */
const avatarCanvas = document.getElementById('avatarCursor');
const avCtx = avatarCanvas.getContext('2d', { willReadFrequently:true });
avCtx.imageSmoothingEnabled=false;
/* Build preview (front) ASAP */
(function(){ const profile = JSON.parse(localStorage.getItem('izzaCharacter')||'{}'); buildAvatarCanvasWithGear(avCtx, avatarCanvas.width, profile); })();

/* Build backified canvas for the in-game player ‚Äî async */
const backCanvasPlaceholder = document.createElement('canvas'); backCanvasPlaceholder.width=backCanvasPlaceholder.height=96;
const backTex = new THREE.CanvasTexture(backCanvasPlaceholder);
backTex.minFilter = THREE.NearestFilter; backTex.magFilter = THREE.NearestFilter;
(async function(){
  const c = await buildBackAvatar(96);
  backTex.image = c; backTex.needsUpdate = true;
})();

/* Player: smaller (about half old size), overlays already baked into texture */
const player = new THREE.Mesh(
  new THREE.PlaneGeometry(0.28,0.28),
  new THREE.MeshBasicMaterial({ map: backTex, transparent:true })
);
player.position.set(0, 0.78, 0); scene.add(player);

/* ‚Äî‚Äî‚Äî Coins ‚Äî‚Äî‚Äî */
function makeCoinTexture(){
  const s=128, cnv=document.createElement('canvas'); cnv.width=cnv.height=s;
  const ctx=cnv.getContext('2d');
  const g=ctx.createRadialGradient(s*.45,s*.45,6,s*.55,s*.55,s*.6);
  g.addColorStop(0,'#fff5c4'); g.addColorStop(.45,'#ffd86b'); g.addColorStop(1,'#9a6d1c');
  ctx.fillStyle=g; ctx.beginPath(); ctx.arc(s/2,s/2,s*0.46,0,Math.PI*2); ctx.fill();
  ctx.lineWidth=6; ctx.strokeStyle='rgba(255,255,255,0.35)'; ctx.stroke();
  ctx.fillStyle='rgba(40,30,0,0.85)'; ctx.font='700 48px Inter, Arial';
  ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('IZ', s/2, s/2);
  return new THREE.CanvasTexture(cnv);
}
const coinTex = makeCoinTexture(); coinTex.anisotropy=4;
const coinMat = new THREE.MeshStandardMaterial({ map: coinTex, metalness:0.85, roughness:0.3, emissive:0x2b1f00, emissiveIntensity:0.2 });

const obstacles=[]; const coins=[];

/* spawn helpers ‚Äî wider spacing + endless track */
const TRACK_LOOP = 900;               // obstacle recycle loop length
const OBSTACLE_SPACING = 28;          // wider than before
const COIN_CHANCE = 0.6;
const OBSTACLE_CHANCE = 0.45;

function spawnCoin(z){
  const m = new THREE.Mesh(new THREE.CylinderGeometry(0.20,0.20,0.05, 32), coinMat);
  m.rotation.x = Math.PI/2; m.position.set(0, 0.82, z); m.userData.kind='coin'; scene.add(m); coins.push(m);
}

function spawnObstacle(z){
  if (Math.random()<0.5){
    const bale = new THREE.Mesh(new THREE.BoxGeometry(1.1,0.55,0.7),
      new THREE.MeshStandardMaterial({ color:0xe6c15a, roughness:0.9, metalness:0.1 }));
    bale.position.set(0,0.28,z); bale.userData.kind='low'; scene.add(bale); obstacles.push(bale);
  }else{
    const arch = new THREE.Group();
    const postsMat = new THREE.MeshStandardMaterial({ color:0x1266cc, metalness:0.2, roughness:0.4 });
    const postL = new THREE.Mesh(new THREE.BoxGeometry(0.12,1.6,0.2), postsMat); postL.position.set(-0.7,0.8,0); arch.add(postL);
    const postR = postL.clone(); postR.position.x=0.7; arch.add(postR);
    const banner = new THREE.Mesh(new THREE.BoxGeometry(1.4,0.18,0.1),
      new THREE.MeshStandardMaterial({ color:0x10c97b, emissive:0x10c97b, emissiveIntensity:0.25 }));
    banner.position.set(0,1.35,0); arch.add(banner);
    arch.position.z=z; arch.userData.kind='high'; scene.add(arch); obstacles.push(arch);
  }
}

/* initial stretch with larger spacing */
let zCursor = -40;
for(let i=0;i<40;i++){
  if (Math.random() < COIN_CHANCE) spawnCoin(zCursor - 6);
  if (Math.random() < OBSTACLE_CHANCE) spawnObstacle(zCursor - 10);
  zCursor -= (OBSTACLE_SPACING + Math.random()*8);
}

/* continuous coin trickle ahead */
function spawnCoinsAheadBuffer(){
  const ahead = coins.filter(c=>c.position.z< -60).length;
  for(let k=ahead; k<8; k++){
    spawnCoin(-200 - Math.random()*600);
  }
}
spawnCoinsAheadBuffer();

/* Game state */
let running=false, over=false;
let vel = 0.18;
let dist = 0;
let sessionCoins = 0;
let best = parseInt(localStorage.getItem('runnerHighScore')||'0',10) || 0;
const scoreEl = document.getElementById('scoreEl');

/* Jump / Slide */
let jumpT = 0;     // 0..1
let slideT = 0;    // 0..1
function doJump(){ if (over || !running) return; if (jumpT>0 || slideT>0) return; jumpT = 1; audio.blip({f1:520,f2:980,dur:0.24}); }
function doSlide(){ if (over || !running) return; if (slideT>0 || jumpT>0) return; slideT = 1; audio.thump({f:95,dur:0.20}); }

/* Input */
(function input(){
  let startY=0, startT=0, swiping=false;
  window.addEventListener('pointerdown', e=>{ swiping=true; startY=e.clientY; startT=performance.now(); }, {passive:true});
  window.addEventListener('pointerup', e=>{
    if(!swiping) return; swiping=false;
    const dy = e.clientY - startY, dt = performance.now()-startT;
    if (Math.abs(dy)>40 && dt<400){ if (dy<0) doJump(); else doSlide(); }
  }, {passive:true});
  window.addEventListener('keydown', (e)=>{
    if (e.key==='ArrowUp' || e.key==='w' || e.key===' ') doJump();
    if (e.key==='ArrowDown' || e.key==='s') doSlide();
  });
})();

/* Collision helper */
function aabbHit(px, py, pz, bx, by, bz, sx, sy, sz){
  return Math.abs(px-bx) < (sx/2) && Math.abs(py-by) < (sy/2) && Math.abs(pz-bz) < (sz/2);
}

/* Wallet helpers */
function addCoins(n){
  const cur = parseInt(localStorage.getItem('izzaCoins')||'0',10) || 0;
  const next = Math.max(0, cur + (n|0));
  localStorage.setItem('izzaCoins', String(next));
  window.dispatchEvent(new Event('izza-coins-changed'));
  document.getElementById('coins').textContent = String(next);
}
function addCraftingCreditsFromCoins(sessionCoins){
  const gain = Math.floor(sessionCoins / 1000);
  if (gain<=0) return 0;
  const cur = readCraftAny();
  const next = cur + gain;
  writeCraftAll(next);
  document.getElementById('craft').textContent = String(next);
  return gain;
}

/* Leaderboard */
async function submitLeaderboard(score){
  try{
    if (window.IZZA_LEADERBOARD?.submit){
      await IZZA_LEADERBOARD.submit({ game:'runner', score: Math.max(0, score|0), hi: Math.max(0, best|0) });
    } else {
      await fetch('/izza-game/api/leaderboard/submit', { method:'POST', headers:{'content-type':'application/json'}, body:JSON.stringify({ game:'runner', score:score|0 }) });
    }
  }catch(_){}
}

/* Start / Over UX */
const startOverlay = document.getElementById('startOverlay');
const overOverlay  = document.getElementById('overOverlay');
document.getElementById('startBtn').onclick = ()=>{
  startOverlay.classList.remove('show');
  audio.bgm().catch(()=>{});
  running = true; over=false;
};
document.getElementById('lbBtn').onclick = ()=>{
  location.href = '/izza-game/minigames?t='+(localStorage.getItem('izzaTokenT')||'')+'&u='+(localStorage.getItem('izzaUserU')||'')+'#leaderboard';
};
document.getElementById('overLbBtn').onclick = ()=>{ document.getElementById('lbBtn').click(); };
document.getElementById('retryBtn').onclick = ()=>{ location.reload(); };
document.getElementById('exitBtn').href = (()=>{
  const url = new URL('/izza-game/minigames', location.origin);
  const T = localStorage.getItem('izzaTokenT')||''; const U=localStorage.getItem('izzaUserU')||'';
  if (T) url.searchParams.set('t',T); if (U) url.searchParams.set('u',U);
  return url.pathname + (url.search || '');
})();

/* Tiny coin sparkle */
const sparkleMat = new THREE.PointsMaterial({ size:0.06, color:0xfff2b0 });
function sparkle(x,y,z){
  const geo = new THREE.BufferGeometry();
  const N = 12, arr = new Float32Array(N*3);
  for(let i=0;i<N;i++){
    arr[i*3+0] = x + (Math.random()-0.5)*0.4;
    arr[i*3+1] = y + (Math.random()-0.5)*0.4;
    arr[i*3+2] = z + (Math.random()-0.5)*0.2;
  }
  geo.setAttribute('position', new THREE.BufferAttribute(arr,3));
  const pts = new THREE.Points(geo, sparkleMat.clone());
  scene.add(pts);
  let t=0;
  (function fade(){
    if (t>18){ scene.remove(pts); geo.dispose(); return; }
    t++; pts.material.opacity = 1 - t/18; pts.material.transparent = true;
    pts.position.z += vel*0.02;
    requestAnimationFrame(fade);
  })();
}

/* Main loop */
let last = performance.now();
function tick(now){
  requestAnimationFrame(tick);
  const dt = Math.min(40, now - last) / 16.666;
  last = now;

  // keep back texture live
  backTex.needsUpdate = true;

  if (!running || over) return;

  vel += 0.00025 * dt;

  // move world toward camera
  scene.traverse(obj=>{
    if (obj===player || obj===camera || obj===ground) return;
    if (obj.isMesh || obj.isGroup || obj.isPoints) obj.position.z += vel * dt * 1.3;
  });

  // recycle path segments for endless track look
  for (const seg of PATH_SEGMENTS){
    if (seg.position.z > 6){
      seg.position.z -= PATH_LOOP;
    }
  }

  dist += vel * dt * 3.0;
  scoreEl.textContent = String(dist|0);

  // Jump arc
  if (jumpT > 0){
    jumpT = Math.max(0, jumpT - 0.042*dt);
    const j = Math.sin((1-jumpT)*Math.PI);
    player.position.y = 0.78 + j*1.35;
  } else {
    player.position.y = (slideT>0) ? 0.40 : 0.78;
  }
  if (slideT > 0){ slideT = Math.max(0, slideT - 0.055*dt); }

  // Coins
  for (let i=coins.length-1; i>=0; i--){
    const c = coins[i]; if (!c) continue;
    c.rotation.z += 0.2 * dt;
    c.position.y = 0.82 + Math.sin(now*0.006 + i)*0.05;
    if (c.position.z > 2){ scene.remove(c); coins.splice(i,1); continue; }
    if (aabbHit(0, player.position.y, 0.2, c.position.x, c.position.y, c.position.z, 0.65,0.65,0.7)){
      sessionCoins += 1; addCoins(1); audio.blip({f1:760,f2:1350,dur:0.12}); sparkle(c.position.x,c.position.y,c.position.z);
      scene.remove(c); coins.splice(i,1);
    }
  }

  // Keep coins ahead stocked
  if (Math.random()<0.03) spawnCoinsAheadBuffer();

  // Obstacles ‚Äî endless via recycle
  for (let i=0;i<obstacles.length;i++){
    const o = obstacles[i]; if (!o) continue;
    if (o.position.z > 8){
      o.position.z -= TRACK_LOOP + Math.random()*40; // recycle far back for endless track
      continue;
    }
    if (o.userData.kind==='low'){
      const hit = aabbHit(0, player.position.y, 0.2, o.position.x, 0.28, o.position.z, 1.1, 0.55, 0.9) && player.position.y < 1.05;
      if (hit) return gameOver();
    } else {
      const hit = aabbHit(0, player.position.y, 0.2, o.position.x||0, 1.2, o.position.z, 1.4, 0.5, 0.9) && player.position.y > 0.7;
      if (hit) return gameOver();
    }
  }
}
requestAnimationFrame(tick);

/* Game over */
async function gameOver(){
  over = true; running=false;
  const finalScore = dist|0;
  best = Math.max(best|0, finalScore);
  localStorage.setItem('runnerHighScore', String(best));
  const gainedCC = addCraftingCreditsFromCoins(sessionCoins);
  try{ if (window.IZZA_PERSIST?.save) await IZZA_PERSIST.save(); }catch(_){}
  try{ await submitLeaderboard(best); }catch(_){}
  const stats = `Distance: ${finalScore} ‚Ä¢ Coins: ${sessionCoins} ‚Ä¢ Best: ${best}${gainedCC>0?` ‚Ä¢ +${gainedCC} CC`:''}`;
  document.getElementById('overStats').textContent = stats;
  document.getElementById('overOverlay').classList.add('show');
}

/* Resize */
window.addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

/* Render pass */
(function renderLoop(){
  requestAnimationFrame(renderLoop);
  renderer.render(scene, camera);
})();

/* Update avatar when equipment changes ‚Äî rebuild both front preview and back sprite */
window.addEventListener('izza-inventory-changed', async ()=>{
  const profile = JSON.parse(localStorage.getItem('izzaCharacter')||'{}');
  await buildAvatarCanvasWithGear(avCtx, avatarCanvas.width, profile);
  const fresh = await buildBackAvatar(96);
  backTex.image = fresh; backTex.needsUpdate = true;
}, {passive:true});
</script>
</body>
</html>
